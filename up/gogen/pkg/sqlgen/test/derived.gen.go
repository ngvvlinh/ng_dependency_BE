// Code generated by goderive DO NOT EDIT.

package test

import (
	"database/sql"
	"time"

	sq "etop.vn/backend/pkg/common/sql"
	core "etop.vn/backend/pkg/common/sql/core"
)

type SQLWriter = core.SQLWriter

// Type User represents table user
func sqlgenUser(_ *User) bool { return true }

type Users []*User

const __sqlUser_Table = "user"
const __sqlUser_ListCols = "\"id\",\"name\",\"created_at\",\"updated_at\",\"bool\",\"float64\",\"int\",\"int64\",\"string\",\"p_bool\",\"p_float64\",\"p_int\",\"p_int64\",\"p_string\""
const __sqlUser_Insert = "INSERT INTO \"user\" (" + __sqlUser_ListCols + ") VALUES"
const __sqlUser_Select = "SELECT " + __sqlUser_ListCols + " FROM \"user\""
const __sqlUser_Select_history = "SELECT " + __sqlUser_ListCols + " FROM history.\"user\""
const __sqlUser_UpdateAll = "UPDATE \"user\" SET (" + __sqlUser_ListCols + ")"

func (m *User) SQLTableName() string  { return "user" }
func (m *Users) SQLTableName() string { return "user" }

func (m *User) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.String(m.Name),
		core.Time(m.CreatedAt),
		m.UpdatedAt,
		core.Bool(m.Bool),
		core.Float64(m.Float64),
		core.Int(m.Int),
		core.Int64(m.Int64),
		core.String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	}
}

func (m *User) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		(*core.String)(&m.Name),
		(*core.Time)(&m.CreatedAt),
		&m.UpdatedAt,
		(*core.Bool)(&m.Bool),
		(*core.Float64)(&m.Float64),
		(*core.Int)(&m.Int),
		(*core.Int64)(&m.Int64),
		(*core.String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	}
}

func (m *User) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Users) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Users, 0, 128)
	for rows.Next() {
		m := new(User)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *User) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (_ *Users) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (m *User) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Users) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(14)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *User) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.UpdatedAt)
	}
	if m.Bool {
		flag = true
		w.WriteName("bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		w.WriteName("float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Float64)
	}
	if m.Int != 0 {
		flag = true
		w.WriteName("int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		w.WriteName("int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int64)
	}
	if m.String != "" {
		flag = true
		w.WriteName("string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.String)
	}
	if m.PBool != nil {
		flag = true
		w.WriteName("p_bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		w.WriteName("p_float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		w.WriteName("p_int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		w.WriteName("p_int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt64)
	}
	if m.PString != nil {
		flag = true
		w.WriteName("p_string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PString)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *User) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserHistory map[string]interface{}
type UserHistories []map[string]interface{}

func (m *UserHistory) SQLTableName() string  { return "history.\"user\"" }
func (m UserHistories) SQLTableName() string { return "history.\"user\"" }

func (m *UserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m UserHistory) Name() core.Interface      { return core.Interface{m["name"]} }
func (m UserHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m UserHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }
func (m UserHistory) Bool() core.Interface      { return core.Interface{m["bool"]} }
func (m UserHistory) Float64() core.Interface   { return core.Interface{m["float64"]} }
func (m UserHistory) Int() core.Interface       { return core.Interface{m["int"]} }
func (m UserHistory) Int64() core.Interface     { return core.Interface{m["int64"]} }
func (m UserHistory) String() core.Interface    { return core.Interface{m["string"]} }
func (m UserHistory) PBool() core.Interface     { return core.Interface{m["p_bool"]} }
func (m UserHistory) PFloat64() core.Interface  { return core.Interface{m["p_float64"]} }
func (m UserHistory) PInt() core.Interface      { return core.Interface{m["p_int"]} }
func (m UserHistory) PInt64() core.Interface    { return core.Interface{m["p_int64"]} }
func (m UserHistory) PString() core.Interface   { return core.Interface{m["p_string"]} }

func (m *UserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserHistory, 14)
	res["id"] = data[0]
	res["name"] = data[1]
	res["created_at"] = data[2]
	res["updated_at"] = data[3]
	res["bool"] = data[4]
	res["float64"] = data[5]
	res["int"] = data[6]
	res["int64"] = data[7]
	res["string"] = data[8]
	res["p_bool"] = data[9]
	res["p_float64"] = data[10]
	res["p_int"] = data[11]
	res["p_int64"] = data[12]
	res["p_string"] = data[13]
	*m = res
	return nil
}

func (ms *UserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	res := make(UserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["created_at"] = data[2]
		m["updated_at"] = data[3]
		m["bool"] = data[4]
		m["float64"] = data[5]
		m["int"] = data[6]
		m["int64"] = data[7]
		m["string"] = data[8]
		m["p_bool"] = data[9]
		m["p_float64"] = data[10]
		m["p_int"] = data[11]
		m["p_int64"] = data[12]
		m["p_string"] = data[13]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// *UserSubset is a substruct of *User
func substructUserSubset(_ *UserSubset, _ *User) bool { return true }

func UserSubsetsFromUsers(ps []*User) []*UserSubset {
	ss := make([]*UserSubset, len(ps))
	for i, p := range ps {
		ss[i] = NewUserSubsetFromUser(p)
	}
	return ss
}

func UserSubsetsToUsers(ss []*UserSubset) []*User {
	ps := make([]*User, len(ss))
	for i, s := range ss {
		ps[i] = s.ToUser()
	}
	return ps
}

func NewUserSubsetFromUser(sp *User) *UserSubset {
	if sp == nil {
		return nil
	}
	s := new(UserSubset)
	s.CopyFrom(sp)
	return s
}

func (s *UserSubset) ToUser() *User {
	if s == nil {
		return nil
	}
	sp := new(User)
	s.AssignTo(sp)
	return sp
}

func (s *UserSubset) CopyFrom(sp *User) {
	s.ID = sp.ID
	s.Bool = sp.Bool
	s.Float64 = sp.Float64
	s.Int = sp.Int
	s.Int64 = sp.Int64
	s.String = sp.String
	s.PBool = sp.PBool
	s.PFloat64 = sp.PFloat64
	s.PInt = sp.PInt
	s.PInt64 = sp.PInt64
	s.PString = sp.PString
}

func (s *UserSubset) AssignTo(sp *User) {
	sp.ID = s.ID
	sp.Bool = s.Bool
	sp.Float64 = s.Float64
	sp.Int = s.Int
	sp.Int64 = s.Int64
	sp.String = s.String
	sp.PBool = s.PBool
	sp.PFloat64 = s.PFloat64
	sp.PInt = s.PInt
	sp.PInt64 = s.PInt64
	sp.PString = s.PString
}

// Type UserSubset represents table user
func sqlgenUserSubset(_ *UserSubset, _ *User) bool { return true }

type UserSubsets []*UserSubset

const __sqlUserSubset_Table = "user"
const __sqlUserSubset_ListCols = "\"id\",\"bool\",\"float64\",\"int\",\"int64\",\"string\",\"p_bool\",\"p_float64\",\"p_int\",\"p_int64\",\"p_string\""
const __sqlUserSubset_Insert = "INSERT INTO \"user\" (" + __sqlUserSubset_ListCols + ") VALUES"
const __sqlUserSubset_Select = "SELECT " + __sqlUserSubset_ListCols + " FROM \"user\""
const __sqlUserSubset_Select_history = "SELECT " + __sqlUserSubset_ListCols + " FROM history.\"user\""
const __sqlUserSubset_UpdateAll = "UPDATE \"user\" SET (" + __sqlUserSubset_ListCols + ")"

func (m *UserSubset) SQLTableName() string  { return "user" }
func (m *UserSubsets) SQLTableName() string { return "user" }

func (m *UserSubset) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.Bool(m.Bool),
		core.Float64(m.Float64),
		core.Int(m.Int),
		core.Int64(m.Int64),
		core.String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	}
}

func (m *UserSubset) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		(*core.Bool)(&m.Bool),
		(*core.Float64)(&m.Float64),
		(*core.Int)(&m.Int),
		(*core.Int64)(&m.Int64),
		(*core.String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	}
}

func (m *UserSubset) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserSubsets) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserSubsets, 0, 128)
	for rows.Next() {
		m := new(UserSubset)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserSubset) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Select)
	return nil
}

func (_ *UserSubsets) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Select)
	return nil
}

func (m *UserSubset) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserSubsets) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(11)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserSubset) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Bool {
		flag = true
		w.WriteName("bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		w.WriteName("float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Float64)
	}
	if m.Int != 0 {
		flag = true
		w.WriteName("int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		w.WriteName("int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int64)
	}
	if m.String != "" {
		flag = true
		w.WriteName("string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.String)
	}
	if m.PBool != nil {
		flag = true
		w.WriteName("p_bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		w.WriteName("p_float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		w.WriteName("p_int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		w.WriteName("p_int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt64)
	}
	if m.PString != nil {
		flag = true
		w.WriteName("p_string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PString)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserSubset) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserSubsetHistory map[string]interface{}
type UserSubsetHistories []map[string]interface{}

func (m *UserSubsetHistory) SQLTableName() string  { return "history.\"user\"" }
func (m UserSubsetHistories) SQLTableName() string { return "history.\"user\"" }

func (m *UserSubsetHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Select_history)
	return nil
}

func (m UserSubsetHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserSubset_Select_history)
	return nil
}

func (m UserSubsetHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m UserSubsetHistory) Bool() core.Interface     { return core.Interface{m["bool"]} }
func (m UserSubsetHistory) Float64() core.Interface  { return core.Interface{m["float64"]} }
func (m UserSubsetHistory) Int() core.Interface      { return core.Interface{m["int"]} }
func (m UserSubsetHistory) Int64() core.Interface    { return core.Interface{m["int64"]} }
func (m UserSubsetHistory) String() core.Interface   { return core.Interface{m["string"]} }
func (m UserSubsetHistory) PBool() core.Interface    { return core.Interface{m["p_bool"]} }
func (m UserSubsetHistory) PFloat64() core.Interface { return core.Interface{m["p_float64"]} }
func (m UserSubsetHistory) PInt() core.Interface     { return core.Interface{m["p_int"]} }
func (m UserSubsetHistory) PInt64() core.Interface   { return core.Interface{m["p_int64"]} }
func (m UserSubsetHistory) PString() core.Interface  { return core.Interface{m["p_string"]} }

func (m *UserSubsetHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserSubsetHistory, 11)
	res["id"] = data[0]
	res["bool"] = data[1]
	res["float64"] = data[2]
	res["int"] = data[3]
	res["int64"] = data[4]
	res["string"] = data[5]
	res["p_bool"] = data[6]
	res["p_float64"] = data[7]
	res["p_int"] = data[8]
	res["p_int64"] = data[9]
	res["p_string"] = data[10]
	*m = res
	return nil
}

func (ms *UserSubsetHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	res := make(UserSubsetHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserSubsetHistory)
		m["id"] = data[0]
		m["bool"] = data[1]
		m["float64"] = data[2]
		m["int"] = data[3]
		m["int64"] = data[4]
		m["string"] = data[5]
		m["p_bool"] = data[6]
		m["p_float64"] = data[7]
		m["p_int"] = data[8]
		m["p_int64"] = data[9]
		m["p_string"] = data[10]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserInfo represents table user_info
func sqlgenUserInfo(_ *UserInfo) bool { return true }

type UserInfoes []*UserInfo

const __sqlUserInfo_Table = "user_info"
const __sqlUserInfo_ListCols = "\"user_id\",\"metadata\",\"bool\",\"float64\",\"int\",\"int64\",\"string\",\"p_bool\",\"p_float64\",\"p_int\",\"p_int64\",\"p_string\""
const __sqlUserInfo_Insert = "INSERT INTO \"user_info\" (" + __sqlUserInfo_ListCols + ") VALUES"
const __sqlUserInfo_Select = "SELECT " + __sqlUserInfo_ListCols + " FROM \"user_info\""
const __sqlUserInfo_Select_history = "SELECT " + __sqlUserInfo_ListCols + " FROM history.\"user_info\""
const __sqlUserInfo_UpdateAll = "UPDATE \"user_info\" SET (" + __sqlUserInfo_ListCols + ")"

func (m *UserInfo) SQLTableName() string   { return "user_info" }
func (m *UserInfoes) SQLTableName() string { return "user_info" }

func (m *UserInfo) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Int64(m.UserID),
		core.String(m.Metadata),
		core.Bool(m.Bool),
		core.Float64(m.Float64),
		core.Int(m.Int),
		core.Int64(m.Int64),
		core.String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	}
}

func (m *UserInfo) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Int64)(&m.UserID),
		(*core.String)(&m.Metadata),
		(*core.Bool)(&m.Bool),
		(*core.Float64)(&m.Float64),
		(*core.Int)(&m.Int),
		(*core.Int64)(&m.Int64),
		(*core.String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	}
}

func (m *UserInfo) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserInfoes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserInfoes, 0, 128)
	for rows.Next() {
		m := new(UserInfo)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserInfo) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Select)
	return nil
}

func (_ *UserInfoes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Select)
	return nil
}

func (m *UserInfo) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserInfoes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(12)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserInfo) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_info")
	w.WriteRawString(" SET ")
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.Metadata != "" {
		flag = true
		w.WriteName("metadata")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Metadata)
	}
	if m.Bool {
		flag = true
		w.WriteName("bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		w.WriteName("float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Float64)
	}
	if m.Int != 0 {
		flag = true
		w.WriteName("int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		w.WriteName("int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Int64)
	}
	if m.String != "" {
		flag = true
		w.WriteName("string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.String)
	}
	if m.PBool != nil {
		flag = true
		w.WriteName("p_bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		w.WriteName("p_float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		w.WriteName("p_int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		w.WriteName("p_int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PInt64)
	}
	if m.PString != nil {
		flag = true
		w.WriteName("p_string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(*m.PString)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserInfo) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserInfoHistory map[string]interface{}
type UserInfoHistories []map[string]interface{}

func (m *UserInfoHistory) SQLTableName() string  { return "history.\"user_info\"" }
func (m UserInfoHistories) SQLTableName() string { return "history.\"user_info\"" }

func (m *UserInfoHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Select_history)
	return nil
}

func (m UserInfoHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInfo_Select_history)
	return nil
}

func (m UserInfoHistory) UserID() core.Interface   { return core.Interface{m["user_id"]} }
func (m UserInfoHistory) Metadata() core.Interface { return core.Interface{m["metadata"]} }
func (m UserInfoHistory) Bool() core.Interface     { return core.Interface{m["bool"]} }
func (m UserInfoHistory) Float64() core.Interface  { return core.Interface{m["float64"]} }
func (m UserInfoHistory) Int() core.Interface      { return core.Interface{m["int"]} }
func (m UserInfoHistory) Int64() core.Interface    { return core.Interface{m["int64"]} }
func (m UserInfoHistory) String() core.Interface   { return core.Interface{m["string"]} }
func (m UserInfoHistory) PBool() core.Interface    { return core.Interface{m["p_bool"]} }
func (m UserInfoHistory) PFloat64() core.Interface { return core.Interface{m["p_float64"]} }
func (m UserInfoHistory) PInt() core.Interface     { return core.Interface{m["p_int"]} }
func (m UserInfoHistory) PInt64() core.Interface   { return core.Interface{m["p_int64"]} }
func (m UserInfoHistory) PString() core.Interface  { return core.Interface{m["p_string"]} }

func (m *UserInfoHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserInfoHistory, 12)
	res["user_id"] = data[0]
	res["metadata"] = data[1]
	res["bool"] = data[2]
	res["float64"] = data[3]
	res["int"] = data[4]
	res["int64"] = data[5]
	res["string"] = data[6]
	res["p_bool"] = data[7]
	res["p_float64"] = data[8]
	res["p_int"] = data[9]
	res["p_int64"] = data[10]
	res["p_string"] = data[11]
	*m = res
	return nil
}

func (ms *UserInfoHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	res := make(UserInfoHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserInfoHistory)
		m["user_id"] = data[0]
		m["metadata"] = data[1]
		m["bool"] = data[2]
		m["float64"] = data[3]
		m["int"] = data[4]
		m["int64"] = data[5]
		m["string"] = data[6]
		m["p_bool"] = data[7]
		m["p_float64"] = data[8]
		m["p_int"] = data[9]
		m["p_int64"] = data[10]
		m["p_string"] = data[11]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserUnion represents a join
func sqlgenUserUnion(_ *UserUnion, _ *User, as sq.AS, t0 sq.JOIN_TYPE, _ *UserInfo, a0 sq.AS, c0 string) bool {
	__sqlUserUnion_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlUserUnion_As = as
	__sqlUserUnion_JoinAs = []sq.AS{a0}
	__sqlUserUnion_JoinConds = []string{c0}
	return true
}

type UserUnions []*UserUnion

var __sqlUserUnion_JoinTypes []sq.JOIN_TYPE
var __sqlUserUnion_As sq.AS
var __sqlUserUnion_JoinAs []sq.AS
var __sqlUserUnion_JoinConds []string

func (m *UserUnion) SQLTableName() string  { return "user" }
func (m *UserUnions) SQLTableName() string { return "user" }

func (m *UserUnion) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserUnions) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserUnions, 0, 128)
	for rows.Next() {
		m := new(UserUnion)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnion) SQLSelect(w SQLWriter) error {
	(*UserUnion)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*UserUnion)(nil).__sqlJoin(w, __sqlUserUnion_JoinTypes)
	return nil
}

func (m *UserUnions) SQLSelect(w SQLWriter) error {
	return (*UserUnion)(nil).SQLSelect(w)
}

func (m *UserUnion) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlUserUnion_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *UserUnions) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*UserUnion)(nil).SQLJoin(w, types)
}

func (m *UserUnion) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlUserUnion_As), __sqlUser_ListCols)
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlUserUnion_JoinAs[0]), __sqlUserInfo_ListCols)
}

func (m *UserUnion) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("user")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlUserUnion_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName(__sqlUserInfo_Table)
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlUserUnion_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlUserUnion_JoinConds[0])
}

func (m *UserUnion) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	m.UserInfo = new(UserInfo)
	args = append(args, m.UserInfo.SQLScanArgs(opts)...)

	return args
}

// Type UserUnionMore represents a join
func sqlgenUserUnionMore(_ *UserUnionMore, _ *User, as sq.AS, t0 sq.JOIN_TYPE, _ *UserInfo, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *UserSubset, a1 sq.AS, c1 string) bool {
	__sqlUserUnionMore_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlUserUnionMore_As = as
	__sqlUserUnionMore_JoinAs = []sq.AS{a0, a1}
	__sqlUserUnionMore_JoinConds = []string{c0, c1}
	return true
}

type UserUnionMores []*UserUnionMore

var __sqlUserUnionMore_JoinTypes []sq.JOIN_TYPE
var __sqlUserUnionMore_As sq.AS
var __sqlUserUnionMore_JoinAs []sq.AS
var __sqlUserUnionMore_JoinConds []string

func (m *UserUnionMore) SQLTableName() string  { return "user" }
func (m *UserUnionMores) SQLTableName() string { return "user" }

func (m *UserUnionMore) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserUnionMores) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserUnionMores, 0, 128)
	for rows.Next() {
		m := new(UserUnionMore)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnionMore) SQLSelect(w SQLWriter) error {
	(*UserUnionMore)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*UserUnionMore)(nil).__sqlJoin(w, __sqlUserUnionMore_JoinTypes)
	return nil
}

func (m *UserUnionMores) SQLSelect(w SQLWriter) error {
	return (*UserUnionMore)(nil).SQLSelect(w)
}

func (m *UserUnionMore) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlUserUnionMore_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *UserUnionMores) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*UserUnionMore)(nil).SQLJoin(w, types)
}

func (m *UserUnionMore) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlUserUnionMore_As), __sqlUser_ListCols)
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlUserUnionMore_JoinAs[0]), __sqlUserInfo_ListCols)
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlUserUnionMore_JoinAs[1]), __sqlUserSubset_ListCols)
}

func (m *UserUnionMore) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("user")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlUserUnionMore_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName(__sqlUserInfo_Table)
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlUserUnionMore_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlUserUnionMore_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName(__sqlUserSubset_Table)
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlUserUnionMore_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlUserUnionMore_JoinConds[1])
}

func (m *UserUnionMore) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	m.UserInfo = new(UserInfo)
	args = append(args, m.UserInfo.SQLScanArgs(opts)...)
	m.UserSubset = new(UserSubset)
	args = append(args, m.UserSubset.SQLScanArgs(opts)...)

	return args
}

// Type ComplexInfo represents table complex_info
func sqlgenComplexInfo(_ *ComplexInfo) bool { return true }

type ComplexInfoes []*ComplexInfo

const __sqlComplexInfo_Table = "complex_info"
const __sqlComplexInfo_ListCols = "\"id\",\"address\",\"p_address\",\"metadata\",\"ints\",\"int64s\",\"strings\",\"times\",\"times_p\",\"alias_string\",\"alias_int64\",\"alias_int\",\"alias_bool\",\"alias_float64\",\"alias_p_string\",\"alias_p_int64\",\"alias_p_int\",\"alias_p_bool\",\"alias_p_float64\""
const __sqlComplexInfo_Insert = "INSERT INTO \"complex_info\" (" + __sqlComplexInfo_ListCols + ") VALUES"
const __sqlComplexInfo_Select = "SELECT " + __sqlComplexInfo_ListCols + " FROM \"complex_info\""
const __sqlComplexInfo_Select_history = "SELECT " + __sqlComplexInfo_ListCols + " FROM history.\"complex_info\""
const __sqlComplexInfo_UpdateAll = "UPDATE \"complex_info\" SET (" + __sqlComplexInfo_ListCols + ")"

func (m *ComplexInfo) SQLTableName() string   { return "complex_info" }
func (m *ComplexInfoes) SQLTableName() string { return "complex_info" }

func (m *ComplexInfo) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.JSON{&m.Address},
		core.JSON{m.PAddress},
		core.JSON{m.Metadata},
		core.Array{m.Ints, opts},
		core.Array{m.Int64s, opts},
		core.Array{m.Strings, opts},
		core.Array{m.Times, opts},
		core.Array{m.TimesP, opts},
		core.String(m.AliasString),
		core.Int64(m.AliasInt64),
		core.Int(m.AliasInt),
		core.Bool(m.AliasBool),
		core.Float64(m.AliasFloat64),
		m.AliasPString,
		m.AliasPInt64,
		m.AliasPInt,
		m.AliasPBool,
		m.AliasPFloat64,
	}
}

func (m *ComplexInfo) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		core.JSON{&m.Address},
		core.JSON{&m.PAddress},
		core.JSON{&m.Metadata},
		core.Array{&m.Ints, opts},
		core.Array{&m.Int64s, opts},
		core.Array{&m.Strings, opts},
		core.Array{&m.Times, opts},
		core.Array{&m.TimesP, opts},
		(*core.String)(&m.AliasString),
		(*core.Int64)(&m.AliasInt64),
		(*core.Int)(&m.AliasInt),
		(*core.Bool)(&m.AliasBool),
		(*core.Float64)(&m.AliasFloat64),
		&m.AliasPString,
		&m.AliasPInt64,
		&m.AliasPInt,
		&m.AliasPBool,
		&m.AliasPFloat64,
	}
}

func (m *ComplexInfo) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ComplexInfoes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ComplexInfoes, 0, 128)
	for rows.Next() {
		m := new(ComplexInfo)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ComplexInfo) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Select)
	return nil
}

func (_ *ComplexInfoes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Select)
	return nil
}

func (m *ComplexInfo) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ComplexInfoes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(19)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ComplexInfo) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("complex_info")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if true {
		flag = true
		w.WriteName("address")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{&m.Address})
	}
	if m.PAddress != nil {
		flag = true
		w.WriteName("p_address")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.PAddress})
	}
	if m.Metadata != nil {
		flag = true
		w.WriteName("metadata")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Metadata})
	}
	if m.Ints != nil {
		flag = true
		w.WriteName("ints")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Ints, opts})
	}
	if m.Int64s != nil {
		flag = true
		w.WriteName("int64s")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Int64s, opts})
	}
	if m.Strings != nil {
		flag = true
		w.WriteName("strings")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Strings, opts})
	}
	if m.Times != nil {
		flag = true
		w.WriteName("times")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Times, opts})
	}
	if m.TimesP != nil {
		flag = true
		w.WriteName("times_p")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.TimesP, opts})
	}
	if m.AliasString != "" {
		flag = true
		w.WriteName("alias_string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.AliasString))
	}
	if m.AliasInt64 != 0 {
		flag = true
		w.WriteName("alias_int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(int64(m.AliasInt64))
	}
	if m.AliasInt != 0 {
		flag = true
		w.WriteName("alias_int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(int(m.AliasInt))
	}
	if m.AliasBool {
		flag = true
		w.WriteName("alias_bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(bool(m.AliasBool))
	}
	if m.AliasFloat64 != 0 {
		flag = true
		w.WriteName("alias_float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(float64(m.AliasFloat64))
	}
	if m.AliasPString != nil {
		flag = true
		w.WriteName("alias_p_string")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg((*string)(m.AliasPString))
	}
	if m.AliasPInt64 != nil {
		flag = true
		w.WriteName("alias_p_int64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg((*int64)(m.AliasPInt64))
	}
	if m.AliasPInt != nil {
		flag = true
		w.WriteName("alias_p_int")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg((*int)(m.AliasPInt))
	}
	if m.AliasPBool != nil {
		flag = true
		w.WriteName("alias_p_bool")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg((*bool)(m.AliasPBool))
	}
	if m.AliasPFloat64 != nil {
		flag = true
		w.WriteName("alias_p_float64")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg((*float64)(m.AliasPFloat64))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ComplexInfo) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ComplexInfoHistory map[string]interface{}
type ComplexInfoHistories []map[string]interface{}

func (m *ComplexInfoHistory) SQLTableName() string  { return "history.\"complex_info\"" }
func (m ComplexInfoHistories) SQLTableName() string { return "history.\"complex_info\"" }

func (m *ComplexInfoHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Select_history)
	return nil
}

func (m ComplexInfoHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlComplexInfo_Select_history)
	return nil
}

func (m ComplexInfoHistory) ID() core.Interface           { return core.Interface{m["id"]} }
func (m ComplexInfoHistory) Address() core.Interface      { return core.Interface{m["address"]} }
func (m ComplexInfoHistory) PAddress() core.Interface     { return core.Interface{m["p_address"]} }
func (m ComplexInfoHistory) Metadata() core.Interface     { return core.Interface{m["metadata"]} }
func (m ComplexInfoHistory) Ints() core.Interface         { return core.Interface{m["ints"]} }
func (m ComplexInfoHistory) Int64s() core.Interface       { return core.Interface{m["int64s"]} }
func (m ComplexInfoHistory) Strings() core.Interface      { return core.Interface{m["strings"]} }
func (m ComplexInfoHistory) Times() core.Interface        { return core.Interface{m["times"]} }
func (m ComplexInfoHistory) TimesP() core.Interface       { return core.Interface{m["times_p"]} }
func (m ComplexInfoHistory) AliasString() core.Interface  { return core.Interface{m["alias_string"]} }
func (m ComplexInfoHistory) AliasInt64() core.Interface   { return core.Interface{m["alias_int64"]} }
func (m ComplexInfoHistory) AliasInt() core.Interface     { return core.Interface{m["alias_int"]} }
func (m ComplexInfoHistory) AliasBool() core.Interface    { return core.Interface{m["alias_bool"]} }
func (m ComplexInfoHistory) AliasFloat64() core.Interface { return core.Interface{m["alias_float64"]} }
func (m ComplexInfoHistory) AliasPString() core.Interface { return core.Interface{m["alias_p_string"]} }
func (m ComplexInfoHistory) AliasPInt64() core.Interface  { return core.Interface{m["alias_p_int64"]} }
func (m ComplexInfoHistory) AliasPInt() core.Interface    { return core.Interface{m["alias_p_int"]} }
func (m ComplexInfoHistory) AliasPBool() core.Interface   { return core.Interface{m["alias_p_bool"]} }
func (m ComplexInfoHistory) AliasPFloat64() core.Interface {
	return core.Interface{m["alias_p_float64"]}
}

func (m *ComplexInfoHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ComplexInfoHistory, 19)
	res["id"] = data[0]
	res["address"] = data[1]
	res["p_address"] = data[2]
	res["metadata"] = data[3]
	res["ints"] = data[4]
	res["int64s"] = data[5]
	res["strings"] = data[6]
	res["times"] = data[7]
	res["times_p"] = data[8]
	res["alias_string"] = data[9]
	res["alias_int64"] = data[10]
	res["alias_int"] = data[11]
	res["alias_bool"] = data[12]
	res["alias_float64"] = data[13]
	res["alias_p_string"] = data[14]
	res["alias_p_int64"] = data[15]
	res["alias_p_int"] = data[16]
	res["alias_p_bool"] = data[17]
	res["alias_p_float64"] = data[18]
	*m = res
	return nil
}

func (ms *ComplexInfoHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	res := make(ComplexInfoHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ComplexInfoHistory)
		m["id"] = data[0]
		m["address"] = data[1]
		m["p_address"] = data[2]
		m["metadata"] = data[3]
		m["ints"] = data[4]
		m["int64s"] = data[5]
		m["strings"] = data[6]
		m["times"] = data[7]
		m["times_p"] = data[8]
		m["alias_string"] = data[9]
		m["alias_int64"] = data[10]
		m["alias_int"] = data[11]
		m["alias_bool"] = data[12]
		m["alias_float64"] = data[13]
		m["alias_p_string"] = data[14]
		m["alias_p_int64"] = data[15]
		m["alias_p_int"] = data[16]
		m["alias_p_bool"] = data[17]
		m["alias_p_float64"] = data[18]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserTag represents table user_tag
func sqlgenUserTag(_ *UserTag) bool { return true }

type UserTags []*UserTag

const __sqlUserTag_Table = "user_tag"
const __sqlUserTag_ListCols = "\"province\",\"new_name\""
const __sqlUserTag_Insert = "INSERT INTO \"user_tag\" (" + __sqlUserTag_ListCols + ") VALUES"
const __sqlUserTag_Select = "SELECT " + __sqlUserTag_ListCols + " FROM \"user_tag\""
const __sqlUserTag_Select_history = "SELECT " + __sqlUserTag_ListCols + " FROM history.\"user_tag\""
const __sqlUserTag_UpdateAll = "UPDATE \"user_tag\" SET (" + __sqlUserTag_ListCols + ")"

func (m *UserTag) SQLTableName() string  { return "user_tag" }
func (m *UserTags) SQLTableName() string { return "user_tag" }

func (m *UserTag) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.Inline.Province),
		core.String(m.Rename),
	}
}

func (m *UserTag) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.Inline.Province),
		(*core.String)(&m.Rename),
	}
}

func (m *UserTag) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserTags) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserTags, 0, 128)
	for rows.Next() {
		m := new(UserTag)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserTag) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Select)
	return nil
}

func (_ *UserTags) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Select)
	return nil
}

func (m *UserTag) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserTags) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(2)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserTag) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_tag")
	w.WriteRawString(" SET ")
	if m.Inline.Province != "" {
		flag = true
		w.WriteName("province")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Inline.Province)
	}
	if m.Rename != "" {
		flag = true
		w.WriteName("new_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Rename)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserTag) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserTagHistory map[string]interface{}
type UserTagHistories []map[string]interface{}

func (m *UserTagHistory) SQLTableName() string  { return "history.\"user_tag\"" }
func (m UserTagHistories) SQLTableName() string { return "history.\"user_tag\"" }

func (m *UserTagHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Select_history)
	return nil
}

func (m UserTagHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserTag_Select_history)
	return nil
}

func (m UserTagHistory) Province() core.Interface { return core.Interface{m["province"]} }
func (m UserTagHistory) Rename() core.Interface   { return core.Interface{m["new_name"]} }

func (m *UserTagHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserTagHistory, 2)
	res["province"] = data[0]
	res["new_name"] = data[1]
	*m = res
	return nil
}

func (ms *UserTagHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	res := make(UserTagHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserTagHistory)
		m["province"] = data[0]
		m["new_name"] = data[1]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserInline represents table user_inline
func sqlgenUserInline(_ *UserInline) bool { return true }

type UserInlines []*UserInline

const __sqlUserInline_Table = "user_inline"
const __sqlUserInline_ListCols = "\"province\",\"district\""
const __sqlUserInline_Insert = "INSERT INTO \"user_inline\" (" + __sqlUserInline_ListCols + ") VALUES"
const __sqlUserInline_Select = "SELECT " + __sqlUserInline_ListCols + " FROM \"user_inline\""
const __sqlUserInline_Select_history = "SELECT " + __sqlUserInline_ListCols + " FROM history.\"user_inline\""
const __sqlUserInline_UpdateAll = "UPDATE \"user_inline\" SET (" + __sqlUserInline_ListCols + ")"

func (m *UserInline) SQLTableName() string  { return "user_inline" }
func (m *UserInlines) SQLTableName() string { return "user_inline" }

func (m *UserInline) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.Inline.Province),
		core.Ternary(m.PtrInline != nil, core.String(m.PtrInline.District), nil),
	}
}

func (m *UserInline) SQLScanArgs(opts core.Opts) []interface{} {
	m.PtrInline = new(Address2)
	return []interface{}{
		(*core.String)(&m.Inline.Province),
		(*core.String)(&m.PtrInline.District),
	}
}

func (m *UserInline) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserInlines) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserInlines, 0, 128)
	for rows.Next() {
		m := new(UserInline)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserInline) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Select)
	return nil
}

func (_ *UserInlines) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Select)
	return nil
}

func (m *UserInline) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserInlines) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(2)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserInline) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_inline")
	w.WriteRawString(" SET ")
	if m.Inline.Province != "" {
		flag = true
		w.WriteName("province")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Inline.Province)
	}
	if m.PtrInline != nil && m.PtrInline.District != "" {
		flag = true
		w.WriteName("district")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PtrInline.District)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserInline) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserInlineHistory map[string]interface{}
type UserInlineHistories []map[string]interface{}

func (m *UserInlineHistory) SQLTableName() string  { return "history.\"user_inline\"" }
func (m UserInlineHistories) SQLTableName() string { return "history.\"user_inline\"" }

func (m *UserInlineHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Select_history)
	return nil
}

func (m UserInlineHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInline_Select_history)
	return nil
}

func (m UserInlineHistory) Province() core.Interface { return core.Interface{m["province"]} }
func (m UserInlineHistory) District() core.Interface { return core.Interface{m["district"]} }

func (m *UserInlineHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserInlineHistory, 2)
	res["province"] = data[0]
	res["district"] = data[1]
	*m = res
	return nil
}

func (ms *UserInlineHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	res := make(UserInlineHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserInlineHistory)
		m["province"] = data[0]
		m["district"] = data[1]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Profile represents table profile
func sqlgenProfile(_ *Profile) bool { return true }

type Profiles []*Profile

const __sqlProfile_Table = "profile"
const __sqlProfile_ListCols = "\"id\",\"style\""
const __sqlProfile_Insert = "INSERT INTO \"profile\" (" + __sqlProfile_ListCols + ") VALUES"
const __sqlProfile_Select = "SELECT " + __sqlProfile_ListCols + " FROM \"profile\""
const __sqlProfile_Select_history = "SELECT " + __sqlProfile_ListCols + " FROM history.\"profile\""
const __sqlProfile_UpdateAll = "UPDATE \"profile\" SET (" + __sqlProfile_ListCols + ")"

func (m *Profile) SQLTableName() string  { return "profile" }
func (m *Profiles) SQLTableName() string { return "profile" }

func (m *Profile) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Int64(m.ID),
		core.String(m.Style),
	}
}

func (m *Profile) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Int64)(&m.ID),
		(*core.String)(&m.Style),
	}
}

func (m *Profile) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Profiles) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Profiles, 0, 128)
	for rows.Next() {
		m := new(Profile)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Profile) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Select)
	return nil
}

func (_ *Profiles) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Select)
	return nil
}

func (m *Profile) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Profiles) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(2)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Profile) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("profile")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Style != "" {
		flag = true
		w.WriteName("style")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Style)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Profile) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

func (m *Profile) SQLPreload(table string) *core.PreloadDesc {
	switch table {
	case "user_info":
		var items UserInfoes
		return &core.PreloadDesc{
			Fkey:  "user_id",
			IDs:   []interface{}{m.ID},
			Items: &items,
		}
	default:
		return nil
	}
}

func (m Profiles) SQLPreload(table string) *core.PreloadDesc {
	switch table {
	case "user_info":
		ids := make([]interface{}, len(m))
		for i, item := range m {
			ids[i] = item.ID
		}
		var items UserInfoes
		return &core.PreloadDesc{
			Fkey:  "user_id",
			IDs:   ids,
			Items: &items,
		}
	default:
		return nil
	}
}

func (m *Profile) SQLPopulate(items core.IFind) error {
	switch items := items.(type) {
	case *UserInfoes:
		m.UserInfos = *items
		return nil
	default:
		return core.Errorf("can not populate %T into %T", items, m)
	}
}

func (m Profiles) SQLPopulate(items core.IFind) error {
	mapID := make(map[int64]*Profile)
	for _, item := range m {
		mapID[item.ID] = item
	}

	switch items := items.(type) {
	case *UserInfoes:
		for _, item := range *items {
			mitem := mapID[item.UserID]
			if mitem == nil {
				return core.Errorf("can not populate id %v", item.UserID)
			}
			mitem.UserInfos = append(mitem.UserInfos, item)
		}
		return nil
	default:
		return core.Errorf("can not populate %T into %T", items, m)
	}
}

type ProfileHistory map[string]interface{}
type ProfileHistories []map[string]interface{}

func (m *ProfileHistory) SQLTableName() string  { return "history.\"profile\"" }
func (m ProfileHistories) SQLTableName() string { return "history.\"profile\"" }

func (m *ProfileHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Select_history)
	return nil
}

func (m ProfileHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlProfile_Select_history)
	return nil
}

func (m ProfileHistory) ID() core.Interface    { return core.Interface{m["id"]} }
func (m ProfileHistory) Style() core.Interface { return core.Interface{m["style"]} }

func (m *ProfileHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ProfileHistory, 2)
	res["id"] = data[0]
	res["style"] = data[1]
	*m = res
	return nil
}

func (ms *ProfileHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	res := make(ProfileHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ProfileHistory)
		m["id"] = data[0]
		m["style"] = data[1]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
