// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package shop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	externaltypes "o.o/api/top/external/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() CustomerAddressService:
		return NewCustomerAddressServiceServer(builder, hooks...), true
	case func() CustomerGroupRelationshipService:
		return NewCustomerGroupRelationshipServiceServer(builder, hooks...), true
	case func() CustomerGroupService:
		return NewCustomerGroupServiceServer(builder, hooks...), true
	case func() CustomerService:
		return NewCustomerServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() HistoryService:
		return NewHistoryServiceServer(builder, hooks...), true
	case func() InventoryService:
		return NewInventoryServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() ProductCollectionRelationshipService:
		return NewProductCollectionRelationshipServiceServer(builder, hooks...), true
	case func() ProductCollectionService:
		return NewProductCollectionServiceServer(builder, hooks...), true
	case func() ProductService:
		return NewProductServiceServer(builder, hooks...), true
	case func() ShipnowService:
		return NewShipnowServiceServer(builder, hooks...), true
	case func() ShippingService:
		return NewShippingServiceServer(builder, hooks...), true
	case func() VariantService:
		return NewVariantServiceServer(builder, hooks...), true
	case func() WebhookService:
		return NewWebhookServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type CustomerAddressServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerAddressService
}

func NewCustomerAddressServiceServer(builder func() CustomerAddressService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerAddressServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerAddressServicePathPrefix = "/shop.CustomerAddress/"

const Path_CustomerAddress_CreateAddress = "/shop.CustomerAddress/CreateAddress"
const Path_CustomerAddress_DeleteAddress = "/shop.CustomerAddress/DeleteAddress"
const Path_CustomerAddress_GetAddress = "/shop.CustomerAddress/GetAddress"
const Path_CustomerAddress_ListAddresses = "/shop.CustomerAddress/ListAddresses"
const Path_CustomerAddress_UpdateAddress = "/shop.CustomerAddress/UpdateAddress"

func (s *CustomerAddressServiceServer) PathPrefix() string {
	return CustomerAddressServicePathPrefix
}

func (s *CustomerAddressServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerAddressServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerAddressServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerAddress/CreateAddress":
		msg := &externaltypes.CreateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/DeleteAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/GetAddress":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/ListAddresses":
		msg := &externaltypes.ListCustomerAddressesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListAddresses(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/UpdateAddress":
		msg := &externaltypes.UpdateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupRelationshipServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerGroupRelationshipService
}

func NewCustomerGroupRelationshipServiceServer(builder func() CustomerGroupRelationshipService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerGroupRelationshipServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerGroupRelationshipServicePathPrefix = "/shop.CustomerGroupRelationship/"

const Path_CustomerGroupRelationship_CreateRelationship = "/shop.CustomerGroupRelationship/CreateRelationship"
const Path_CustomerGroupRelationship_DeleteRelationship = "/shop.CustomerGroupRelationship/DeleteRelationship"
const Path_CustomerGroupRelationship_ListRelationships = "/shop.CustomerGroupRelationship/ListRelationships"

func (s *CustomerGroupRelationshipServiceServer) PathPrefix() string {
	return CustomerGroupRelationshipServicePathPrefix
}

func (s *CustomerGroupRelationshipServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerGroupRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerGroupRelationshipServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroupRelationship/CreateRelationship":
		msg := &externaltypes.AddCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateRelationship(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroupRelationship/DeleteRelationship":
		msg := &externaltypes.RemoveCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteRelationship(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroupRelationship/ListRelationships":
		msg := &externaltypes.ListCustomerGroupRelationshipsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListRelationships(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerGroupService
}

func NewCustomerGroupServiceServer(builder func() CustomerGroupService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerGroupServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerGroupServicePathPrefix = "/shop.CustomerGroup/"

const Path_CustomerGroup_CreateGroup = "/shop.CustomerGroup/CreateGroup"
const Path_CustomerGroup_DeleteGroup = "/shop.CustomerGroup/DeleteGroup"
const Path_CustomerGroup_GetGroup = "/shop.CustomerGroup/GetGroup"
const Path_CustomerGroup_ListGroups = "/shop.CustomerGroup/ListGroups"
const Path_CustomerGroup_UpdateGroup = "/shop.CustomerGroup/UpdateGroup"

func (s *CustomerGroupServiceServer) PathPrefix() string {
	return CustomerGroupServicePathPrefix
}

func (s *CustomerGroupServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerGroupServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerGroupServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroup/CreateGroup":
		msg := &externaltypes.CreateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/DeleteGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/ListGroups":
		msg := &externaltypes.ListCustomerGroupsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListGroups(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/UpdateGroup":
		msg := &externaltypes.UpdateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerService
}

func NewCustomerServiceServer(builder func() CustomerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerServicePathPrefix = "/shop.Customer/"

const Path_Customer_CreateCustomer = "/shop.Customer/CreateCustomer"
const Path_Customer_DeleteCustomer = "/shop.Customer/DeleteCustomer"
const Path_Customer_GetCustomer = "/shop.Customer/GetCustomer"
const Path_Customer_ListCustomers = "/shop.Customer/ListCustomers"
const Path_Customer_UpdateCustomer = "/shop.Customer/UpdateCustomer"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Customer/CreateCustomer":
		msg := &externaltypes.CreateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomer":
		msg := &externaltypes.DeleteCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomer":
		msg := &externaltypes.GetCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/ListCustomers":
		msg := &externaltypes.ListCustomersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListCustomers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomer":
		msg := &externaltypes.UpdateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/shop.Fulfillment/"

const Path_Fulfillment_GetFulfillment = "/shop.Fulfillment/GetFulfillment"
const Path_Fulfillment_ListFulfillments = "/shop.Fulfillment/ListFulfillments"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Fulfillment/GetFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/ListFulfillments":
		msg := &externaltypes.ListFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() HistoryService
}

func NewHistoryServiceServer(builder func() HistoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &HistoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const HistoryServicePathPrefix = "/shop.History/"

const Path_History_GetChanges = "/shop.History/GetChanges"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.History/GetChanges":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetChanges(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InventoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() InventoryService
}

func NewInventoryServiceServer(builder func() InventoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &InventoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const InventoryServicePathPrefix = "/shop.Inventory/"

const Path_Inventory_ListInventoryLevels = "/shop.Inventory/ListInventoryLevels"

func (s *InventoryServiceServer) PathPrefix() string {
	return InventoryServicePathPrefix
}

func (s *InventoryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *InventoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *InventoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Inventory/ListInventoryLevels":
		msg := &externaltypes.ListInventoryLevelsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListInventoryLevels(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/shop.Misc/"

const Path_Misc_CurrentAccount = "/shop.Misc/CurrentAccount"
const Path_Misc_GetLocationList = "/shop.Misc/GetLocationList"
const Path_Misc_VersionInfo = "/shop.Misc/VersionInfo"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Misc/CurrentAccount":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CurrentAccount(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Misc/GetLocationList":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetLocationList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/shop.Order/"

const Path_Order_CancelOrder = "/shop.Order/CancelOrder"
const Path_Order_ConfirmOrder = "/shop.Order/ConfirmOrder"
const Path_Order_CreateOrder = "/shop.Order/CreateOrder"
const Path_Order_GetOrder = "/shop.Order/GetOrder"
const Path_Order_ListOrders = "/shop.Order/ListOrders"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Order/CancelOrder":
		msg := &externaltypes.CancelOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrder":
		msg := &externaltypes.ConfirmOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/CreateOrder":
		msg := &externaltypes.CreateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrder":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ListOrders":
		msg := &externaltypes.ListOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListOrders(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductCollectionRelationshipServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductCollectionRelationshipService
}

func NewProductCollectionRelationshipServiceServer(builder func() ProductCollectionRelationshipService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductCollectionRelationshipServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductCollectionRelationshipServicePathPrefix = "/shop.ProductCollectionRelationship/"

const Path_ProductCollectionRelationship_CreateRelationship = "/shop.ProductCollectionRelationship/CreateRelationship"
const Path_ProductCollectionRelationship_DeleteRelationship = "/shop.ProductCollectionRelationship/DeleteRelationship"
const Path_ProductCollectionRelationship_ListRelationships = "/shop.ProductCollectionRelationship/ListRelationships"

func (s *ProductCollectionRelationshipServiceServer) PathPrefix() string {
	return ProductCollectionRelationshipServicePathPrefix
}

func (s *ProductCollectionRelationshipServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ProductCollectionRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductCollectionRelationshipServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductCollectionRelationship/CreateRelationship":
		msg := &externaltypes.CreateProductCollectionRelationshipRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateRelationship(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollectionRelationship/DeleteRelationship":
		msg := &externaltypes.RemoveProductCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteRelationship(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollectionRelationship/ListRelationships":
		msg := &externaltypes.ListProductCollectionRelationshipsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListRelationships(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductCollectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductCollectionService
}

func NewProductCollectionServiceServer(builder func() ProductCollectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductCollectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductCollectionServicePathPrefix = "/shop.ProductCollection/"

const Path_ProductCollection_CreateCollection = "/shop.ProductCollection/CreateCollection"
const Path_ProductCollection_DeleteCollection = "/shop.ProductCollection/DeleteCollection"
const Path_ProductCollection_GetCollection = "/shop.ProductCollection/GetCollection"
const Path_ProductCollection_ListCollections = "/shop.ProductCollection/ListCollections"
const Path_ProductCollection_UpdateCollection = "/shop.ProductCollection/UpdateCollection"

func (s *ProductCollectionServiceServer) PathPrefix() string {
	return ProductCollectionServicePathPrefix
}

func (s *ProductCollectionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ProductCollectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductCollectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductCollection/CreateCollection":
		msg := &externaltypes.CreateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollection/DeleteCollection":
		msg := &externaltypes.GetCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollection/GetCollection":
		msg := &externaltypes.GetCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollection/ListCollections":
		msg := &externaltypes.ListCollectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListCollections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductCollection/UpdateCollection":
		msg := &externaltypes.UpdateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductService
}

func NewProductServiceServer(builder func() ProductService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductServicePathPrefix = "/shop.Product/"

const Path_Product_CreateProduct = "/shop.Product/CreateProduct"
const Path_Product_DeleteProduct = "/shop.Product/DeleteProduct"
const Path_Product_GetProduct = "/shop.Product/GetProduct"
const Path_Product_ListProducts = "/shop.Product/ListProducts"
const Path_Product_UpdateProduct = "/shop.Product/UpdateProduct"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Product/CreateProduct":
		msg := &externaltypes.CreateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/DeleteProduct":
		msg := &externaltypes.GetProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProduct":
		msg := &externaltypes.GetProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/ListProducts":
		msg := &externaltypes.ListProductsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProduct":
		msg := &externaltypes.UpdateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipnowServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipnowService
}

func NewShipnowServiceServer(builder func() ShipnowService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipnowServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipnowServicePathPrefix = "/shop.Shipnow/"

const Path_Shipnow_CancelShipnowFulfillment = "/shop.Shipnow/CancelShipnowFulfillment"
const Path_Shipnow_CreateShipnowFulfillment = "/shop.Shipnow/CreateShipnowFulfillment"
const Path_Shipnow_GetShipnowFulfillment = "/shop.Shipnow/GetShipnowFulfillment"
const Path_Shipnow_GetShipnowServices = "/shop.Shipnow/GetShipnowServices"

func (s *ShipnowServiceServer) PathPrefix() string {
	return ShipnowServicePathPrefix
}

func (s *ShipnowServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShipnowServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipnowServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipnow/CancelShipnowFulfillment":
		msg := &externaltypes.CancelShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/CreateShipnowFulfillment":
		msg := &externaltypes.CreateShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowServices":
		msg := &externaltypes.GetShipnowServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShippingServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShippingService
}

func NewShippingServiceServer(builder func() ShippingService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShippingServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShippingServicePathPrefix = "/shop.Shipping/"

const Path_Shipping_CancelOrder = "/shop.Shipping/CancelOrder"
const Path_Shipping_CreateAndConfirmOrder = "/shop.Shipping/CreateAndConfirmOrder"
const Path_Shipping_GetFulfillment = "/shop.Shipping/GetFulfillment"
const Path_Shipping_GetOrder = "/shop.Shipping/GetOrder"
const Path_Shipping_GetShippingServices = "/shop.Shipping/GetShippingServices"

func (s *ShippingServiceServer) PathPrefix() string {
	return ShippingServicePathPrefix
}

func (s *ShippingServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShippingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShippingServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipping/CancelOrder":
		msg := &externaltypes.CancelOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipping/CreateAndConfirmOrder":
		msg := &externaltypes.CreateAndConfirmOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateAndConfirmOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipping/GetFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipping/GetOrder":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipping/GetShippingServices":
		msg := &externaltypes.GetShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShippingServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type VariantServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() VariantService
}

func NewVariantServiceServer(builder func() VariantService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &VariantServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const VariantServicePathPrefix = "/shop.Variant/"

const Path_Variant_CreateVariant = "/shop.Variant/CreateVariant"
const Path_Variant_DeleteVariant = "/shop.Variant/DeleteVariant"
const Path_Variant_GetVariant = "/shop.Variant/GetVariant"
const Path_Variant_ListVariants = "/shop.Variant/ListVariants"
const Path_Variant_UpdateVariant = "/shop.Variant/UpdateVariant"

func (s *VariantServiceServer) PathPrefix() string {
	return VariantServicePathPrefix
}

func (s *VariantServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *VariantServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *VariantServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Variant/CreateVariant":
		msg := &externaltypes.CreateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Variant/DeleteVariant":
		msg := &externaltypes.GetVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Variant/GetVariant":
		msg := &externaltypes.GetVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Variant/ListVariants":
		msg := &externaltypes.ListVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ListVariants(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Variant/UpdateVariant":
		msg := &externaltypes.UpdateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type WebhookServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() WebhookService
}

func NewWebhookServiceServer(builder func() WebhookService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &WebhookServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const WebhookServicePathPrefix = "/shop.Webhook/"

const Path_Webhook_CreateWebhook = "/shop.Webhook/CreateWebhook"
const Path_Webhook_DeleteWebhook = "/shop.Webhook/DeleteWebhook"
const Path_Webhook_GetWebhooks = "/shop.Webhook/GetWebhooks"

func (s *WebhookServiceServer) PathPrefix() string {
	return WebhookServicePathPrefix
}

func (s *WebhookServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *WebhookServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *WebhookServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Webhook/CreateWebhook":
		msg := &externaltypes.CreateWebhookRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateWebhook(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Webhook/DeleteWebhook":
		msg := &externaltypes.DeleteWebhookRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteWebhook(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Webhook/GetWebhooks":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWebhooks(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
