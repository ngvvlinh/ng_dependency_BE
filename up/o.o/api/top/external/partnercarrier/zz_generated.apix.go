// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package partnercarrier

import (
	context "context"
	fmt "fmt"
	http "net/http"

	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...*httprpc.Hooks) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() ShipmentConnectionService:
		return NewShipmentConnectionServiceServer(builder, hooks...), true
	case func() ShipmentService:
		return NewShipmentServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type MiscServiceServer struct {
	hooks   httprpc.Hooks
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/carrier.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/carrier.Misc/CurrentAccount":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CurrentAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/carrier.Misc/GetLocationList":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetLocationList(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentConnectionServiceServer struct {
	hooks   httprpc.Hooks
	builder func() ShipmentConnectionService
}

func NewShipmentConnectionServiceServer(builder func() ShipmentConnectionService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &ShipmentConnectionServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const ShipmentConnectionServicePathPrefix = "/carrier.ShipmentConnection/"

func (s *ShipmentConnectionServiceServer) PathPrefix() string {
	return ShipmentConnectionServicePathPrefix
}

func (s *ShipmentConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *ShipmentConnectionServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/carrier.ShipmentConnection/CreateConnection":
		msg := &CreateConnectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateConnection(ctx, msg)
		}
		return msg, fn, nil
	case "/carrier.ShipmentConnection/DeleteConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteConnection(ctx, msg)
		}
		return msg, fn, nil
	case "/carrier.ShipmentConnection/GetConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetConnections(ctx, msg)
		}
		return msg, fn, nil
	case "/carrier.ShipmentConnection/UpdateConnection":
		msg := &UpdateConnectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateConnection(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentServiceServer struct {
	hooks   httprpc.Hooks
	builder func() ShipmentService
}

func NewShipmentServiceServer(builder func() ShipmentService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &ShipmentServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const ShipmentServicePathPrefix = "/carrier.Shipment/"

func (s *ShipmentServiceServer) PathPrefix() string {
	return ShipmentServicePathPrefix
}

func (s *ShipmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *ShipmentServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/carrier.Shipment/UpdateFulfillment":
		msg := &UpdateFulfillmentRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateFulfillment(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
