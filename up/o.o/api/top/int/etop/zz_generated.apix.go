// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package etop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountRelationshipService:
		return NewAccountRelationshipServiceServer(builder, hooks...), true
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() AddressService:
		return NewAddressServiceServer(builder, hooks...), true
	case func() BankService:
		return NewBankServiceServer(builder, hooks...), true
	case func() EcomService:
		return NewEcomServiceServer(builder, hooks...), true
	case func() LocationService:
		return NewLocationServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() TicketService:
		return NewTicketServiceServer(builder, hooks...), true
	case func() UserRelationshipService:
		return NewUserRelationshipServiceServer(builder, hooks...), true
	case func() UserService:
		return NewUserServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountRelationshipServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountRelationshipService
}

func NewAccountRelationshipServiceServer(builder func() AccountRelationshipService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountRelationshipServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountRelationshipServicePathPrefix = "/etop.AccountRelationship/"

const Path_AccountRelationship_CreateInvitation = "/etop.AccountRelationship/CreateInvitation"
const Path_AccountRelationship_DeleteInvitation = "/etop.AccountRelationship/DeleteInvitation"
const Path_AccountRelationship_GetInvitations = "/etop.AccountRelationship/GetInvitations"
const Path_AccountRelationship_GetRelationships = "/etop.AccountRelationship/GetRelationships"
const Path_AccountRelationship_RemoveUser = "/etop.AccountRelationship/RemoveUser"
const Path_AccountRelationship_ResendInvitation = "/etop.AccountRelationship/ResendInvitation"
const Path_AccountRelationship_UpdatePermission = "/etop.AccountRelationship/UpdatePermission"
const Path_AccountRelationship_UpdateRelationship = "/etop.AccountRelationship/UpdateRelationship"

func (s *AccountRelationshipServiceServer) PathPrefix() string {
	return AccountRelationshipServicePathPrefix
}

func (s *AccountRelationshipServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AccountRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountRelationshipServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.AccountRelationship/CreateInvitation":
		msg := &CreateInvitationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateInvitation(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/DeleteInvitation":
		msg := &DeleteInvitationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteInvitation(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/GetInvitations":
		msg := &GetInvitationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInvitations(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/GetRelationships":
		msg := &GetRelationshipsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRelationships(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/RemoveUser":
		msg := &RemoveUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/ResendInvitation":
		msg := &ResendInvitationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ResendInvitation(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/UpdatePermission":
		msg := &UpdateAccountUserPermissionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePermission(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/UpdateRelationship":
		msg := &UpdateRelationshipRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateRelationship(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AccountServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/etop.Account/"

const Path_Account_GetPublicPartnerInfo = "/etop.Account/GetPublicPartnerInfo"
const Path_Account_GetPublicPartners = "/etop.Account/GetPublicPartners"
const Path_Account_UpdateURLSlug = "/etop.Account/UpdateURLSlug"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Account/GetPublicPartnerInfo":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicPartnerInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Account/GetPublicPartners":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicPartners(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Account/UpdateURLSlug":
		msg := &UpdateURLSlugRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateURLSlug(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AddressServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AddressService
}

func NewAddressServiceServer(builder func() AddressService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AddressServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AddressServicePathPrefix = "/etop.Address/"

const Path_Address_CreateAddress = "/etop.Address/CreateAddress"
const Path_Address_GetAddresses = "/etop.Address/GetAddresses"
const Path_Address_RemoveAddress = "/etop.Address/RemoveAddress"
const Path_Address_UpdateAddress = "/etop.Address/UpdateAddress"

func (s *AddressServiceServer) PathPrefix() string {
	return AddressServicePathPrefix
}

func (s *AddressServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AddressServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AddressServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Address/CreateAddress":
		msg := &CreateAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Address/GetAddresses":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAddresses(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Address/RemoveAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Address/UpdateAddress":
		msg := &UpdateAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type BankServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() BankService
}

func NewBankServiceServer(builder func() BankService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &BankServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const BankServicePathPrefix = "/etop.Bank/"

const Path_Bank_GetBankBranches = "/etop.Bank/GetBankBranches"
const Path_Bank_GetBankProvinces = "/etop.Bank/GetBankProvinces"
const Path_Bank_GetBanks = "/etop.Bank/GetBanks"
const Path_Bank_GetBranchesByBankProvince = "/etop.Bank/GetBranchesByBankProvince"
const Path_Bank_GetProvincesByBank = "/etop.Bank/GetProvincesByBank"

func (s *BankServiceServer) PathPrefix() string {
	return BankServicePathPrefix
}

func (s *BankServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *BankServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *BankServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Bank/GetBankBranches":
		msg := &GetBankBranchesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBankBranches(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Bank/GetBankProvinces":
		msg := &GetBankProvincesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBankProvinces(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Bank/GetBanks":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBanks(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Bank/GetBranchesByBankProvince":
		msg := &GetBranchesByBankProvinceResquest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBranchesByBankProvince(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Bank/GetProvincesByBank":
		msg := &GetProvincesByBankResquest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProvincesByBank(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type EcomServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() EcomService
}

func NewEcomServiceServer(builder func() EcomService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &EcomServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const EcomServicePathPrefix = "/etop.Ecom/"

const Path_Ecom_SessionInfo = "/etop.Ecom/SessionInfo"

func (s *EcomServiceServer) PathPrefix() string {
	return EcomServicePathPrefix
}

func (s *EcomServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *EcomServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *EcomServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Ecom/SessionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SessionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LocationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() LocationService
}

func NewLocationServiceServer(builder func() LocationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &LocationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const LocationServicePathPrefix = "/etop.Location/"

const Path_Location_GetDistricts = "/etop.Location/GetDistricts"
const Path_Location_GetDistrictsByProvince = "/etop.Location/GetDistrictsByProvince"
const Path_Location_GetProvinces = "/etop.Location/GetProvinces"
const Path_Location_GetWards = "/etop.Location/GetWards"
const Path_Location_GetWardsByDistrict = "/etop.Location/GetWardsByDistrict"
const Path_Location_ParseLocation = "/etop.Location/ParseLocation"

func (s *LocationServiceServer) PathPrefix() string {
	return LocationServicePathPrefix
}

func (s *LocationServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *LocationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *LocationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Location/GetDistricts":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetDistricts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Location/GetDistrictsByProvince":
		msg := &GetDistrictsByProvinceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetDistrictsByProvince(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Location/GetProvinces":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProvinces(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Location/GetWards":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWards(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Location/GetWardsByDistrict":
		msg := &GetWardsByDistrictRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWardsByDistrict(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.Location/ParseLocation":
		msg := &ParseLocationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ParseLocation(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/etop.Misc/"

const Path_Misc_VersionInfo = "/etop.Misc/VersionInfo"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TicketServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() TicketService
}

func NewTicketServiceServer(builder func() TicketService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &TicketServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const TicketServicePathPrefix = "/etop.Ticket/"

const Path_Ticket_GetTicketLabels = "/etop.Ticket/GetTicketLabels"

func (s *TicketServiceServer) PathPrefix() string {
	return TicketServicePathPrefix
}

func (s *TicketServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *TicketServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *TicketServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Ticket/GetTicketLabels":
		msg := &GetTicketLabelsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketLabels(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type UserRelationshipServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() UserRelationshipService
}

func NewUserRelationshipServiceServer(builder func() UserRelationshipService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &UserRelationshipServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const UserRelationshipServicePathPrefix = "/etop.UserRelationship/"

const Path_UserRelationship_AcceptInvitation = "/etop.UserRelationship/AcceptInvitation"
const Path_UserRelationship_GetInvitationByToken = "/etop.UserRelationship/GetInvitationByToken"
const Path_UserRelationship_GetInvitations = "/etop.UserRelationship/GetInvitations"
const Path_UserRelationship_LeaveAccount = "/etop.UserRelationship/LeaveAccount"
const Path_UserRelationship_RejectInvitation = "/etop.UserRelationship/RejectInvitation"

func (s *UserRelationshipServiceServer) PathPrefix() string {
	return UserRelationshipServicePathPrefix
}

func (s *UserRelationshipServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *UserRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *UserRelationshipServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.UserRelationship/AcceptInvitation":
		msg := &AcceptInvitationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AcceptInvitation(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.UserRelationship/GetInvitationByToken":
		msg := &GetInvitationByTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInvitationByToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.UserRelationship/GetInvitations":
		msg := &GetInvitationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInvitations(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.UserRelationship/LeaveAccount":
		msg := &UserRelationshipLeaveAccountRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.LeaveAccount(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.UserRelationship/RejectInvitation":
		msg := &RejectInvitationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RejectInvitation(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type UserServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() UserService
}

func NewUserServiceServer(builder func() UserService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &UserServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const UserServicePathPrefix = "/etop.User/"

const Path_User_ChangePassword = "/etop.User/ChangePassword"
const Path_User_ChangePasswordUsingToken = "/etop.User/ChangePasswordUsingToken"
const Path_User_ChangeRefAff = "/etop.User/ChangeRefAff"
const Path_User_CheckUserRegistration = "/etop.User/CheckUserRegistration"
const Path_User_DisableNotifyTopic = "/etop.User/DisableNotifyTopic"
const Path_User_EnableNotifyTopic = "/etop.User/EnableNotifyTopic"
const Path_User_GetNotifySetting = "/etop.User/GetNotifySetting"
const Path_User_InitSession = "/etop.User/InitSession"
const Path_User_Login = "/etop.User/Login"
const Path_User_Register = "/etop.User/Register"
const Path_User_RegisterSimplify = "/etop.User/RegisterSimplify"
const Path_User_RegisterUsingToken = "/etop.User/RegisterUsingToken"
const Path_User_RequestRegisterSimplify = "/etop.User/RequestRegisterSimplify"
const Path_User_ResetPassword = "/etop.User/ResetPassword"
const Path_User_SendEmailVerification = "/etop.User/SendEmailVerification"
const Path_User_SendEmailVerificationUsingOTP = "/etop.User/SendEmailVerificationUsingOTP"
const Path_User_SendPhoneVerification = "/etop.User/SendPhoneVerification"
const Path_User_SendSTokenEmail = "/etop.User/SendSTokenEmail"
const Path_User_SessionInfo = "/etop.User/SessionInfo"
const Path_User_SwitchAccount = "/etop.User/SwitchAccount"
const Path_User_UpdatePermission = "/etop.User/UpdatePermission"
const Path_User_UpdateReferenceSale = "/etop.User/UpdateReferenceSale"
const Path_User_UpdateReferenceUser = "/etop.User/UpdateReferenceUser"
const Path_User_UpdateUserEmail = "/etop.User/UpdateUserEmail"
const Path_User_UpdateUserPhone = "/etop.User/UpdateUserPhone"
const Path_User_UpgradeAccessToken = "/etop.User/UpgradeAccessToken"
const Path_User_VerifyEmailUsingOTP = "/etop.User/VerifyEmailUsingOTP"
const Path_User_VerifyEmailUsingToken = "/etop.User/VerifyEmailUsingToken"
const Path_User_VerifyPhoneResetPasswordUsingToken = "/etop.User/VerifyPhoneResetPasswordUsingToken"
const Path_User_VerifyPhoneUsingToken = "/etop.User/VerifyPhoneUsingToken"
const Path_User_WebphoneLogin = "/etop.User/WebphoneLogin"
const Path_User_WebphoneRequestLogin = "/etop.User/WebphoneRequestLogin"

func (s *UserServiceServer) PathPrefix() string {
	return UserServicePathPrefix
}

func (s *UserServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *UserServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *UserServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.User/ChangePassword":
		msg := &ChangePasswordRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ChangePassword(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/ChangePasswordUsingToken":
		msg := &ChangePasswordUsingTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ChangePasswordUsingToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/ChangeRefAff":
		msg := &ChangeUserRefAffRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ChangeRefAff(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/CheckUserRegistration":
		msg := &GetUserByPhoneRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CheckUserRegistration(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/DisableNotifyTopic":
		msg := &UpdateNotifyTopicRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DisableNotifyTopic(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/EnableNotifyTopic":
		msg := &UpdateNotifyTopicRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.EnableNotifyTopic(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/GetNotifySetting":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetNotifySetting(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/InitSession":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.InitSession(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/Login":
		msg := &LoginRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.Login(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/Register":
		msg := &CreateUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.Register(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/RegisterSimplify":
		msg := &RegisterSimplifyRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterSimplify(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/RegisterUsingToken":
		msg := &CreateUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterUsingToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/RequestRegisterSimplify":
		msg := &RequestRegisterSimplifyRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RequestRegisterSimplify(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/ResetPassword":
		msg := &ResetPasswordRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ResetPassword(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SendEmailVerification":
		msg := &SendEmailVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SendEmailVerification(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SendEmailVerificationUsingOTP":
		msg := &SendEmailVerificationUsingOTPRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SendEmailVerificationUsingOTP(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SendPhoneVerification":
		msg := &SendPhoneVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SendPhoneVerification(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SendSTokenEmail":
		msg := &SendSTokenEmailRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SendSTokenEmail(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SessionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SessionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/SwitchAccount":
		msg := &SwitchAccountRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SwitchAccount(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpdatePermission":
		msg := &UpdatePermissionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePermission(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpdateReferenceSale":
		msg := &UpdateReferenceSaleRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateReferenceSale(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpdateReferenceUser":
		msg := &UpdateReferenceUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateReferenceUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpdateUserEmail":
		msg := &UpdateUserEmailRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateUserEmail(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpdateUserPhone":
		msg := &UpdateUserPhoneRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateUserPhone(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/UpgradeAccessToken":
		msg := &UpgradeAccessTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpgradeAccessToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/VerifyEmailUsingOTP":
		msg := &VerifyEmailUsingOTPRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VerifyEmailUsingOTP(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/VerifyEmailUsingToken":
		msg := &VerifyEmailUsingTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VerifyEmailUsingToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/VerifyPhoneResetPasswordUsingToken":
		msg := &VerifyPhoneResetPasswordUsingTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VerifyPhoneResetPasswordUsingToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/VerifyPhoneUsingToken":
		msg := &VerifyPhoneUsingTokenRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VerifyPhoneUsingToken(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/WebphoneLogin":
		msg := &WebphoneLoginRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.WebphoneLogin(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/etop.User/WebphoneRequestLogin":
		msg := &WebphoneRequestLoginRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.WebphoneRequestLogin(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
