// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package shop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	etop "o.o/api/top/int/etop"
	shoptypes "o.o/api/top/int/shop/types"
	inttypes "o.o/api/top/int/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() AccountShipnowService:
		return NewAccountShipnowServiceServer(builder, hooks...), true
	case func() AuthorizeService:
		return NewAuthorizeServiceServer(builder, hooks...), true
	case func() BrandService:
		return NewBrandServiceServer(builder, hooks...), true
	case func() CarrierService:
		return NewCarrierServiceServer(builder, hooks...), true
	case func() CategoryService:
		return NewCategoryServiceServer(builder, hooks...), true
	case func() CollectionService:
		return NewCollectionServiceServer(builder, hooks...), true
	case func() ConnectionService:
		return NewConnectionServiceServer(builder, hooks...), true
	case func() ContactService:
		return NewContactServiceServer(builder, hooks...), true
	case func() CustomerGroupService:
		return NewCustomerGroupServiceServer(builder, hooks...), true
	case func() CustomerService:
		return NewCustomerServiceServer(builder, hooks...), true
	case func() ExportService:
		return NewExportServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() HistoryService:
		return NewHistoryServiceServer(builder, hooks...), true
	case func() InventoryService:
		return NewInventoryServiceServer(builder, hooks...), true
	case func() LedgerService:
		return NewLedgerServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() MoneyTransactionService:
		return NewMoneyTransactionServiceServer(builder, hooks...), true
	case func() NotificationService:
		return NewNotificationServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() PaymentService:
		return NewPaymentServiceServer(builder, hooks...), true
	case func() ProductService:
		return NewProductServiceServer(builder, hooks...), true
	case func() ProductSourceService:
		return NewProductSourceServiceServer(builder, hooks...), true
	case func() PurchaseOrderService:
		return NewPurchaseOrderServiceServer(builder, hooks...), true
	case func() PurchaseRefundService:
		return NewPurchaseRefundServiceServer(builder, hooks...), true
	case func() ReceiptService:
		return NewReceiptServiceServer(builder, hooks...), true
	case func() RefundService:
		return NewRefundServiceServer(builder, hooks...), true
	case func() ShipmentService:
		return NewShipmentServiceServer(builder, hooks...), true
	case func() ShipnowService:
		return NewShipnowServiceServer(builder, hooks...), true
	case func() StocktakeService:
		return NewStocktakeServiceServer(builder, hooks...), true
	case func() SubscriptionService:
		return NewSubscriptionServiceServer(builder, hooks...), true
	case func() SummaryService:
		return NewSummaryServiceServer(builder, hooks...), true
	case func() SupplierService:
		return NewSupplierServiceServer(builder, hooks...), true
	case func() TicketService:
		return NewTicketServiceServer(builder, hooks...), true
	case func() TradingService:
		return NewTradingServiceServer(builder, hooks...), true
	case func() WebServerService:
		return NewWebServerServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/shop.Account/"

const Path_Account_CreateExternalAccountAhamove = "/shop.Account/CreateExternalAccountAhamove"
const Path_Account_DeleteShop = "/shop.Account/DeleteShop"
const Path_Account_GetExternalAccountAhamove = "/shop.Account/GetExternalAccountAhamove"
const Path_Account_RegisterShop = "/shop.Account/RegisterShop"
const Path_Account_RequestVerifyExternalAccountAhamove = "/shop.Account/RequestVerifyExternalAccountAhamove"
const Path_Account_SetDefaultAddress = "/shop.Account/SetDefaultAddress"
const Path_Account_UpdateExternalAccountAhamoveVerification = "/shop.Account/UpdateExternalAccountAhamoveVerification"
const Path_Account_UpdateExternalAccountAhamoveVerificationImages = "/shop.Account/UpdateExternalAccountAhamoveVerificationImages"
const Path_Account_UpdateShop = "/shop.Account/UpdateShop"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Account/CreateExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateExternalAccountAhamove(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/DeleteShop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/GetExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExternalAccountAhamove(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/RegisterShop":
		msg := &RegisterShopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterShop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/RequestVerifyExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RequestVerifyExternalAccountAhamove(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/SetDefaultAddress":
		msg := &etop.SetDefaultAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SetDefaultAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerification":
		msg := &UpdateXAccountAhamoveVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateExternalAccountAhamoveVerification(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerificationImages":
		msg := &UpdateXAccountAhamoveVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateExternalAccountAhamoveVerificationImages(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateShop":
		msg := &UpdateShopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShop(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AccountShipnowServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountShipnowService
}

func NewAccountShipnowServiceServer(builder func() AccountShipnowService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountShipnowServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountShipnowServicePathPrefix = "/shop.AccountShipnow/"

const Path_AccountShipnow_GetAccountShipnow = "/shop.AccountShipnow/GetAccountShipnow"

func (s *AccountShipnowServiceServer) PathPrefix() string {
	return AccountShipnowServicePathPrefix
}

func (s *AccountShipnowServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AccountShipnowServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountShipnowServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.AccountShipnow/GetAccountShipnow":
		msg := &GetAccountShipnowRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAccountShipnow(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AuthorizeServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AuthorizeService
}

func NewAuthorizeServiceServer(builder func() AuthorizeService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AuthorizeServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AuthorizeServicePathPrefix = "/shop.Authorize/"

const Path_Authorize_AuthorizePartner = "/shop.Authorize/AuthorizePartner"
const Path_Authorize_GetAuthorizedPartners = "/shop.Authorize/GetAuthorizedPartners"
const Path_Authorize_GetAvailablePartners = "/shop.Authorize/GetAvailablePartners"

func (s *AuthorizeServiceServer) PathPrefix() string {
	return AuthorizeServicePathPrefix
}

func (s *AuthorizeServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AuthorizeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AuthorizeServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Authorize/AuthorizePartner":
		msg := &AuthorizePartnerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AuthorizePartner(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAuthorizedPartners":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAuthorizedPartners(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAvailablePartners":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAvailablePartners(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type BrandServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() BrandService
}

func NewBrandServiceServer(builder func() BrandService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &BrandServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const BrandServicePathPrefix = "/shop.Brand/"

const Path_Brand_CreateBrand = "/shop.Brand/CreateBrand"
const Path_Brand_DeleteBrand = "/shop.Brand/DeleteBrand"
const Path_Brand_GetBrandByID = "/shop.Brand/GetBrandByID"
const Path_Brand_GetBrands = "/shop.Brand/GetBrands"
const Path_Brand_GetBrandsByIDs = "/shop.Brand/GetBrandsByIDs"
const Path_Brand_UpdateBrandInfo = "/shop.Brand/UpdateBrandInfo"

func (s *BrandServiceServer) PathPrefix() string {
	return BrandServicePathPrefix
}

func (s *BrandServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *BrandServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *BrandServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Brand/CreateBrand":
		msg := &CreateBrandRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateBrand(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/DeleteBrand":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteBrand(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandByID":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrandByID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrands":
		msg := &GetBrandsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrands(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrandsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/UpdateBrandInfo":
		msg := &UpdateBrandRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateBrandInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CarrierServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CarrierService
}

func NewCarrierServiceServer(builder func() CarrierService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CarrierServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CarrierServicePathPrefix = "/shop.Carrier/"

const Path_Carrier_CreateCarrier = "/shop.Carrier/CreateCarrier"
const Path_Carrier_DeleteCarrier = "/shop.Carrier/DeleteCarrier"
const Path_Carrier_GetCarrier = "/shop.Carrier/GetCarrier"
const Path_Carrier_GetCarriers = "/shop.Carrier/GetCarriers"
const Path_Carrier_GetCarriersByIDs = "/shop.Carrier/GetCarriersByIDs"
const Path_Carrier_UpdateCarrier = "/shop.Carrier/UpdateCarrier"

func (s *CarrierServiceServer) PathPrefix() string {
	return CarrierServicePathPrefix
}

func (s *CarrierServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CarrierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CarrierServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Carrier/CreateCarrier":
		msg := &CreateCarrierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCarrier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/DeleteCarrier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCarrier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarrier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarrier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriers":
		msg := &GetCarriersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarriers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarriersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/UpdateCarrier":
		msg := &UpdateCarrierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCarrier(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CategoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CategoryService
}

func NewCategoryServiceServer(builder func() CategoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CategoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CategoryServicePathPrefix = "/shop.Category/"

const Path_Category_CreateCategory = "/shop.Category/CreateCategory"
const Path_Category_DeleteCategory = "/shop.Category/DeleteCategory"
const Path_Category_GetCategories = "/shop.Category/GetCategories"
const Path_Category_GetCategory = "/shop.Category/GetCategory"
const Path_Category_UpdateCategory = "/shop.Category/UpdateCategory"

func (s *CategoryServiceServer) PathPrefix() string {
	return CategoryServicePathPrefix
}

func (s *CategoryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CategoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CategoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Category/CreateCategory":
		msg := &CreateCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/DeleteCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/GetCategories":
		msg := &GetCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCategories(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/GetCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/UpdateCategory":
		msg := &UpdateCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CollectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CollectionService
}

func NewCollectionServiceServer(builder func() CollectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CollectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CollectionServicePathPrefix = "/shop.Collection/"

const Path_Collection_CreateCollection = "/shop.Collection/CreateCollection"
const Path_Collection_GetCollection = "/shop.Collection/GetCollection"
const Path_Collection_GetCollections = "/shop.Collection/GetCollections"
const Path_Collection_GetCollectionsByProductID = "/shop.Collection/GetCollectionsByProductID"
const Path_Collection_UpdateCollection = "/shop.Collection/UpdateCollection"

func (s *CollectionServiceServer) PathPrefix() string {
	return CollectionServicePathPrefix
}

func (s *CollectionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CollectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CollectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Collection/CreateCollection":
		msg := &CreateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollections":
		msg := &GetCollectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollectionsByProductID":
		msg := &GetShopCollectionsByProductIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollectionsByProductID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/UpdateCollection":
		msg := &UpdateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ConnectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ConnectionService
}

func NewConnectionServiceServer(builder func() ConnectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ConnectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ConnectionServicePathPrefix = "/shop.Connection/"

const Path_Connection_DeleteShopConnection = "/shop.Connection/DeleteShopConnection"
const Path_Connection_GetAvailableConnections = "/shop.Connection/GetAvailableConnections"
const Path_Connection_GetConnections = "/shop.Connection/GetConnections"
const Path_Connection_GetShopConnections = "/shop.Connection/GetShopConnections"
const Path_Connection_LoginShopConnection = "/shop.Connection/LoginShopConnection"
const Path_Connection_LoginShopConnectionWithOTP = "/shop.Connection/LoginShopConnectionWithOTP"
const Path_Connection_RegisterShopConnection = "/shop.Connection/RegisterShopConnection"
const Path_Connection_UpdateShopConnection = "/shop.Connection/UpdateShopConnection"

func (s *ConnectionServiceServer) PathPrefix() string {
	return ConnectionServicePathPrefix
}

func (s *ConnectionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ConnectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Connection/DeleteShopConnection":
		msg := &inttypes.DeleteShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShopConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetAvailableConnections":
		msg := &inttypes.GetAvailableConnectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAvailableConnections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetConnections":
		msg := &inttypes.GetConnectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetShopConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopConnections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/LoginShopConnection":
		msg := &inttypes.LoginShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.LoginShopConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/LoginShopConnectionWithOTP":
		msg := &inttypes.LoginShopConnectionWithOTPRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.LoginShopConnectionWithOTP(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/RegisterShopConnection":
		msg := &inttypes.RegisterShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterShopConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/UpdateShopConnection":
		msg := &inttypes.UpdateShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShopConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ContactServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ContactService
}

func NewContactServiceServer(builder func() ContactService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ContactServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ContactServicePathPrefix = "/shop.Contact/"

const Path_Contact_CreateContact = "/shop.Contact/CreateContact"
const Path_Contact_DeleteContact = "/shop.Contact/DeleteContact"
const Path_Contact_GetContact = "/shop.Contact/GetContact"
const Path_Contact_GetContacts = "/shop.Contact/GetContacts"
const Path_Contact_UpdateContact = "/shop.Contact/UpdateContact"

func (s *ContactServiceServer) PathPrefix() string {
	return ContactServicePathPrefix
}

func (s *ContactServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ContactServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ContactServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Contact/CreateContact":
		msg := &CreateContactRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateContact(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Contact/DeleteContact":
		msg := &DeleteContactRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteContact(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Contact/GetContact":
		msg := &GetContactRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetContact(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Contact/GetContacts":
		msg := &GetContactsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetContacts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Contact/UpdateContact":
		msg := &UpdateContactRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateContact(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerGroupService
}

func NewCustomerGroupServiceServer(builder func() CustomerGroupService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerGroupServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerGroupServicePathPrefix = "/shop.CustomerGroup/"

const Path_CustomerGroup_CreateCustomerGroup = "/shop.CustomerGroup/CreateCustomerGroup"
const Path_CustomerGroup_GetCustomerGroup = "/shop.CustomerGroup/GetCustomerGroup"
const Path_CustomerGroup_GetCustomerGroups = "/shop.CustomerGroup/GetCustomerGroups"
const Path_CustomerGroup_UpdateCustomerGroup = "/shop.CustomerGroup/UpdateCustomerGroup"

func (s *CustomerGroupServiceServer) PathPrefix() string {
	return CustomerGroupServicePathPrefix
}

func (s *CustomerGroupServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerGroupServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerGroupServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroup/CreateCustomerGroup":
		msg := &CreateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomerGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroups":
		msg := &GetCustomerGroupsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerGroups(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/UpdateCustomerGroup":
		msg := &UpdateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomerGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerService
}

func NewCustomerServiceServer(builder func() CustomerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerServicePathPrefix = "/shop.Customer/"

const Path_Customer_AddCustomersToGroup = "/shop.Customer/AddCustomersToGroup"
const Path_Customer_BatchSetCustomersStatus = "/shop.Customer/BatchSetCustomersStatus"
const Path_Customer_CreateCustomer = "/shop.Customer/CreateCustomer"
const Path_Customer_CreateCustomerAddress = "/shop.Customer/CreateCustomerAddress"
const Path_Customer_DeleteCustomer = "/shop.Customer/DeleteCustomer"
const Path_Customer_DeleteCustomerAddress = "/shop.Customer/DeleteCustomerAddress"
const Path_Customer_GetCustomer = "/shop.Customer/GetCustomer"
const Path_Customer_GetCustomerAddresses = "/shop.Customer/GetCustomerAddresses"
const Path_Customer_GetCustomerDetails = "/shop.Customer/GetCustomerDetails"
const Path_Customer_GetCustomers = "/shop.Customer/GetCustomers"
const Path_Customer_GetCustomersByIDs = "/shop.Customer/GetCustomersByIDs"
const Path_Customer_RemoveCustomersFromGroup = "/shop.Customer/RemoveCustomersFromGroup"
const Path_Customer_SetDefaultCustomerAddress = "/shop.Customer/SetDefaultCustomerAddress"
const Path_Customer_UpdateCustomer = "/shop.Customer/UpdateCustomer"
const Path_Customer_UpdateCustomerAddress = "/shop.Customer/UpdateCustomerAddress"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Customer/AddCustomersToGroup":
		msg := &AddCustomerToGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AddCustomersToGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/BatchSetCustomersStatus":
		msg := &SetCustomersStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.BatchSetCustomersStatus(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomer":
		msg := &CreateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomerAddress":
		msg := &CreateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomerAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomer":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomerAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomerAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomer":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerAddresses":
		msg := &GetCustomerAddressesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerAddresses(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerDetails":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerDetails(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomers":
		msg := &GetCustomersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/RemoveCustomersFromGroup":
		msg := &RemoveCustomerOutOfGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveCustomersFromGroup(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/SetDefaultCustomerAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SetDefaultCustomerAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomer":
		msg := &UpdateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomer(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomerAddress":
		msg := &UpdateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomerAddress(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ExportServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ExportService
}

func NewExportServiceServer(builder func() ExportService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ExportServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ExportServicePathPrefix = "/shop.Export/"

const Path_Export_GetExports = "/shop.Export/GetExports"
const Path_Export_RequestExport = "/shop.Export/RequestExport"

func (s *ExportServiceServer) PathPrefix() string {
	return ExportServicePathPrefix
}

func (s *ExportServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ExportServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ExportServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Export/GetExports":
		msg := &GetExportsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExports(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Export/RequestExport":
		msg := &RequestExportRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RequestExport(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/shop.Fulfillment/"

const Path_Fulfillment_GetExternalShippingServices = "/shop.Fulfillment/GetExternalShippingServices"
const Path_Fulfillment_GetFulfillment = "/shop.Fulfillment/GetFulfillment"
const Path_Fulfillment_GetFulfillments = "/shop.Fulfillment/GetFulfillments"
const Path_Fulfillment_GetFulfillmentsByIDs = "/shop.Fulfillment/GetFulfillmentsByIDs"
const Path_Fulfillment_GetPublicExternalShippingServices = "/shop.Fulfillment/GetPublicExternalShippingServices"
const Path_Fulfillment_GetPublicFulfillment = "/shop.Fulfillment/GetPublicFulfillment"
const Path_Fulfillment_UpdateFulfillmentsShippingState = "/shop.Fulfillment/UpdateFulfillmentsShippingState"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Fulfillment/GetExternalShippingServices":
		msg := &inttypes.GetExternalShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExternalShippingServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillments":
		msg := &GetFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillmentsByIDs":
		msg := &GetFulfillmentsByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillmentsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicExternalShippingServices":
		msg := &inttypes.GetExternalShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicExternalShippingServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicFulfillment":
		msg := &GetPublicFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/UpdateFulfillmentsShippingState":
		msg := &UpdateFulfillmentsShippingStateRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentsShippingState(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() HistoryService
}

func NewHistoryServiceServer(builder func() HistoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &HistoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const HistoryServicePathPrefix = "/shop.History/"

const Path_History_GetFulfillmentHistory = "/shop.History/GetFulfillmentHistory"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.History/GetFulfillmentHistory":
		msg := &GetFulfillmentHistoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillmentHistory(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InventoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() InventoryService
}

func NewInventoryServiceServer(builder func() InventoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &InventoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const InventoryServicePathPrefix = "/shop.Inventory/"

const Path_Inventory_AdjustInventoryQuantity = "/shop.Inventory/AdjustInventoryQuantity"
const Path_Inventory_CancelInventoryVoucher = "/shop.Inventory/CancelInventoryVoucher"
const Path_Inventory_ConfirmInventoryVoucher = "/shop.Inventory/ConfirmInventoryVoucher"
const Path_Inventory_CreateInventoryVoucher = "/shop.Inventory/CreateInventoryVoucher"
const Path_Inventory_GetInventoryVariant = "/shop.Inventory/GetInventoryVariant"
const Path_Inventory_GetInventoryVariants = "/shop.Inventory/GetInventoryVariants"
const Path_Inventory_GetInventoryVariantsByVariantIDs = "/shop.Inventory/GetInventoryVariantsByVariantIDs"
const Path_Inventory_GetInventoryVoucher = "/shop.Inventory/GetInventoryVoucher"
const Path_Inventory_GetInventoryVouchers = "/shop.Inventory/GetInventoryVouchers"
const Path_Inventory_GetInventoryVouchersByIDs = "/shop.Inventory/GetInventoryVouchersByIDs"
const Path_Inventory_GetInventoryVouchersByReference = "/shop.Inventory/GetInventoryVouchersByReference"
const Path_Inventory_UpdateInventoryVariantCostPrice = "/shop.Inventory/UpdateInventoryVariantCostPrice"
const Path_Inventory_UpdateInventoryVoucher = "/shop.Inventory/UpdateInventoryVoucher"

func (s *InventoryServiceServer) PathPrefix() string {
	return InventoryServicePathPrefix
}

func (s *InventoryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *InventoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *InventoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Inventory/AdjustInventoryQuantity":
		msg := &AdjustInventoryQuantityRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AdjustInventoryQuantity(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/CancelInventoryVoucher":
		msg := &CancelInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelInventoryVoucher(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/ConfirmInventoryVoucher":
		msg := &ConfirmInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmInventoryVoucher(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/CreateInventoryVoucher":
		msg := &CreateInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateInventoryVoucher(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariant":
		msg := &GetInventoryVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariants":
		msg := &GetInventoryVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariants(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariantsByVariantIDs":
		msg := &GetInventoryVariantsByVariantIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariantsByVariantIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVoucher":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVoucher(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchers":
		msg := &GetInventoryVouchersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByIDs":
		msg := &GetInventoryVouchersByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByReference":
		msg := &GetInventoryVouchersByReferenceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchersByReference(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVariantCostPrice":
		msg := &UpdateInventoryVariantCostPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateInventoryVariantCostPrice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVoucher":
		msg := &UpdateInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateInventoryVoucher(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LedgerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() LedgerService
}

func NewLedgerServiceServer(builder func() LedgerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &LedgerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const LedgerServicePathPrefix = "/shop.Ledger/"

const Path_Ledger_CreateLedger = "/shop.Ledger/CreateLedger"
const Path_Ledger_DeleteLedger = "/shop.Ledger/DeleteLedger"
const Path_Ledger_GetLedger = "/shop.Ledger/GetLedger"
const Path_Ledger_GetLedgers = "/shop.Ledger/GetLedgers"
const Path_Ledger_UpdateLedger = "/shop.Ledger/UpdateLedger"

func (s *LedgerServiceServer) PathPrefix() string {
	return LedgerServicePathPrefix
}

func (s *LedgerServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *LedgerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *LedgerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Ledger/CreateLedger":
		msg := &CreateLedgerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateLedger(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/DeleteLedger":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteLedger(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedger":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetLedger(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedgers":
		msg := &GetLedgersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetLedgers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/UpdateLedger":
		msg := &UpdateLedgerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateLedger(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/shop.Misc/"

const Path_Misc_VersionInfo = "/shop.Misc/VersionInfo"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MoneyTransactionService
}

func NewMoneyTransactionServiceServer(builder func() MoneyTransactionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MoneyTransactionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MoneyTransactionServicePathPrefix = "/shop.MoneyTransaction/"

const Path_MoneyTransaction_GetMoneyTransaction = "/shop.MoneyTransaction/GetMoneyTransaction"
const Path_MoneyTransaction_GetMoneyTransactions = "/shop.MoneyTransaction/GetMoneyTransactions"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.MoneyTransaction/GetMoneyTransaction":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransaction(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.MoneyTransaction/GetMoneyTransactions":
		msg := &GetMoneyTransactionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactions(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() NotificationService
}

func NewNotificationServiceServer(builder func() NotificationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &NotificationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const NotificationServicePathPrefix = "/shop.Notification/"

const Path_Notification_CreateDevice = "/shop.Notification/CreateDevice"
const Path_Notification_DeleteDevice = "/shop.Notification/DeleteDevice"
const Path_Notification_GetNotification = "/shop.Notification/GetNotification"
const Path_Notification_GetNotifications = "/shop.Notification/GetNotifications"
const Path_Notification_UpdateNotifications = "/shop.Notification/UpdateNotifications"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Notification/CreateDevice":
		msg := &etop.CreateDeviceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateDevice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/DeleteDevice":
		msg := &etop.DeleteDeviceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteDevice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotification":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetNotification(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotifications":
		msg := &etop.GetNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetNotifications(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/UpdateNotifications":
		msg := &etop.UpdateNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateNotifications(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/shop.Order/"

const Path_Order_CancelOrder = "/shop.Order/CancelOrder"
const Path_Order_CompleteOrder = "/shop.Order/CompleteOrder"
const Path_Order_ConfirmOrder = "/shop.Order/ConfirmOrder"
const Path_Order_ConfirmOrderAndCreateFulfillments = "/shop.Order/ConfirmOrderAndCreateFulfillments"
const Path_Order_CreateOrder = "/shop.Order/CreateOrder"
const Path_Order_GetOrder = "/shop.Order/GetOrder"
const Path_Order_GetOrders = "/shop.Order/GetOrders"
const Path_Order_GetOrdersByIDs = "/shop.Order/GetOrdersByIDs"
const Path_Order_GetOrdersByReceiptID = "/shop.Order/GetOrdersByReceiptID"
const Path_Order_UpdateOrder = "/shop.Order/UpdateOrder"
const Path_Order_UpdateOrderPaymentStatus = "/shop.Order/UpdateOrderPaymentStatus"
const Path_Order_UpdateOrderShippingInfo = "/shop.Order/UpdateOrderShippingInfo"
const Path_Order_UpdateOrdersStatus = "/shop.Order/UpdateOrdersStatus"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Order/CancelOrder":
		msg := &CancelOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/CompleteOrder":
		msg := &OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CompleteOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrder":
		msg := &ConfirmOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrderAndCreateFulfillments":
		msg := &OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmOrderAndCreateFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/CreateOrder":
		msg := &inttypes.CreateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrders(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByIDs":
		msg := &etop.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByReceiptID":
		msg := &GetOrdersByReceiptIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByReceiptID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrder":
		msg := &inttypes.UpdateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderPaymentStatus":
		msg := &UpdateOrderPaymentStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrderPaymentStatus(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderShippingInfo":
		msg := &UpdateOrderShippingInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrderShippingInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrdersStatus":
		msg := &UpdateOrdersStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrdersStatus(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PaymentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PaymentService
}

func NewPaymentServiceServer(builder func() PaymentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PaymentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PaymentServicePathPrefix = "/shop.Payment/"

const Path_Payment_PaymentCheckReturnData = "/shop.Payment/PaymentCheckReturnData"
const Path_Payment_PaymentTradingOrder = "/shop.Payment/PaymentTradingOrder"

func (s *PaymentServiceServer) PathPrefix() string {
	return PaymentServicePathPrefix
}

func (s *PaymentServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *PaymentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PaymentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Payment/PaymentCheckReturnData":
		msg := &PaymentCheckReturnDataRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.PaymentCheckReturnData(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Payment/PaymentTradingOrder":
		msg := &PaymentTradingOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.PaymentTradingOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductService
}

func NewProductServiceServer(builder func() ProductService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductServicePathPrefix = "/shop.Product/"

const Path_Product_AddProductCollection = "/shop.Product/AddProductCollection"
const Path_Product_CreateProduct = "/shop.Product/CreateProduct"
const Path_Product_CreateVariant = "/shop.Product/CreateVariant"
const Path_Product_GetProduct = "/shop.Product/GetProduct"
const Path_Product_GetProducts = "/shop.Product/GetProducts"
const Path_Product_GetProductsByIDs = "/shop.Product/GetProductsByIDs"
const Path_Product_GetVariant = "/shop.Product/GetVariant"
const Path_Product_GetVariantsByIDs = "/shop.Product/GetVariantsByIDs"
const Path_Product_GetVariantsBySupplierID = "/shop.Product/GetVariantsBySupplierID"
const Path_Product_RemoveProductCategory = "/shop.Product/RemoveProductCategory"
const Path_Product_RemoveProductCollection = "/shop.Product/RemoveProductCollection"
const Path_Product_RemoveProducts = "/shop.Product/RemoveProducts"
const Path_Product_RemoveVariants = "/shop.Product/RemoveVariants"
const Path_Product_UpdateProduct = "/shop.Product/UpdateProduct"
const Path_Product_UpdateProductCategory = "/shop.Product/UpdateProductCategory"
const Path_Product_UpdateProductImages = "/shop.Product/UpdateProductImages"
const Path_Product_UpdateProductMetaFields = "/shop.Product/UpdateProductMetaFields"
const Path_Product_UpdateProductsStatus = "/shop.Product/UpdateProductsStatus"
const Path_Product_UpdateProductsTags = "/shop.Product/UpdateProductsTags"
const Path_Product_UpdateVariant = "/shop.Product/UpdateVariant"
const Path_Product_UpdateVariantAttributes = "/shop.Product/UpdateVariantAttributes"
const Path_Product_UpdateVariantImages = "/shop.Product/UpdateVariantImages"
const Path_Product_UpdateVariantsStatus = "/shop.Product/UpdateVariantsStatus"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Product/AddProductCollection":
		msg := &AddShopProductCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AddProductCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/CreateProduct":
		msg := &CreateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/CreateVariant":
		msg := &CreateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProducts":
		msg := &GetVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProductsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariant":
		msg := &GetVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariantsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsBySupplierID":
		msg := &GetVariantsBySupplierIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariantsBySupplierID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCollection":
		msg := &RemoveShopProductCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductCollection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProducts":
		msg := &RemoveVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveVariants":
		msg := &RemoveVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveVariants(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProduct":
		msg := &UpdateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductCategory":
		msg := &UpdateProductCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductImages":
		msg := &UpdateVariantImagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductImages(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductMetaFields":
		msg := &UpdateProductMetaFieldsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductMetaFields(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsStatus":
		msg := &UpdateProductStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsStatus(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsTags":
		msg := &UpdateProductsTagsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsTags(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariant":
		msg := &UpdateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantAttributes":
		msg := &UpdateVariantAttributesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantAttributes(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantImages":
		msg := &UpdateVariantImagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantImages(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantsStatus":
		msg := &UpdateProductStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantsStatus(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductSourceServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductSourceService
}

func NewProductSourceServiceServer(builder func() ProductSourceService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductSourceServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductSourceServicePathPrefix = "/shop.ProductSource/"

const Path_ProductSource_CreateProductSource = "/shop.ProductSource/CreateProductSource"
const Path_ProductSource_CreateProductSourceCategory = "/shop.ProductSource/CreateProductSourceCategory"
const Path_ProductSource_CreateVariant = "/shop.ProductSource/CreateVariant"
const Path_ProductSource_GetProductSourceCategories = "/shop.ProductSource/GetProductSourceCategories"
const Path_ProductSource_GetProductSourceCategory = "/shop.ProductSource/GetProductSourceCategory"
const Path_ProductSource_GetShopProductSources = "/shop.ProductSource/GetShopProductSources"
const Path_ProductSource_RemoveProductSourceCategory = "/shop.ProductSource/RemoveProductSourceCategory"
const Path_ProductSource_UpdateProductSourceCategory = "/shop.ProductSource/UpdateProductSourceCategory"
const Path_ProductSource_UpdateProductsPSCategory = "/shop.ProductSource/UpdateProductsPSCategory"

func (s *ProductSourceServiceServer) PathPrefix() string {
	return ProductSourceServicePathPrefix
}

func (s *ProductSourceServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ProductSourceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductSourceServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductSource/CreateProductSource":
		msg := &CreateProductSourceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProductSource(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateProductSourceCategory":
		msg := &CreatePSCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProductSourceCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateVariant":
		msg := &DeprecatedCreateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateVariant(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategories":
		msg := &GetProductSourceCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductSourceCategories(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductSourceCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetShopProductSources":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopProductSources(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/RemoveProductSourceCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductSourceCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductSourceCategory":
		msg := &UpdateProductSourceCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductSourceCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductsPSCategory":
		msg := &UpdateProductsPSCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsPSCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PurchaseOrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PurchaseOrderService
}

func NewPurchaseOrderServiceServer(builder func() PurchaseOrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PurchaseOrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PurchaseOrderServicePathPrefix = "/shop.PurchaseOrder/"

const Path_PurchaseOrder_CancelPurchaseOrder = "/shop.PurchaseOrder/CancelPurchaseOrder"
const Path_PurchaseOrder_ConfirmPurchaseOrder = "/shop.PurchaseOrder/ConfirmPurchaseOrder"
const Path_PurchaseOrder_CreatePurchaseOrder = "/shop.PurchaseOrder/CreatePurchaseOrder"
const Path_PurchaseOrder_DeletePurchaseOrder = "/shop.PurchaseOrder/DeletePurchaseOrder"
const Path_PurchaseOrder_GetPurchaseOrder = "/shop.PurchaseOrder/GetPurchaseOrder"
const Path_PurchaseOrder_GetPurchaseOrders = "/shop.PurchaseOrder/GetPurchaseOrders"
const Path_PurchaseOrder_GetPurchaseOrdersByIDs = "/shop.PurchaseOrder/GetPurchaseOrdersByIDs"
const Path_PurchaseOrder_GetPurchaseOrdersByReceiptID = "/shop.PurchaseOrder/GetPurchaseOrdersByReceiptID"
const Path_PurchaseOrder_UpdatePurchaseOrder = "/shop.PurchaseOrder/UpdatePurchaseOrder"

func (s *PurchaseOrderServiceServer) PathPrefix() string {
	return PurchaseOrderServicePathPrefix
}

func (s *PurchaseOrderServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *PurchaseOrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PurchaseOrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.PurchaseOrder/CancelPurchaseOrder":
		msg := &CancelPurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelPurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/ConfirmPurchaseOrder":
		msg := &ConfirmPurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmPurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/CreatePurchaseOrder":
		msg := &CreatePurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/DeletePurchaseOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeletePurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrders":
		msg := &GetPurchaseOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrders(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrdersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByReceiptID":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrdersByReceiptID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/UpdatePurchaseOrder":
		msg := &UpdatePurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePurchaseOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PurchaseRefundServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PurchaseRefundService
}

func NewPurchaseRefundServiceServer(builder func() PurchaseRefundService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PurchaseRefundServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PurchaseRefundServicePathPrefix = "/shop.PurchaseRefund/"

const Path_PurchaseRefund_CancelPurchaseRefund = "/shop.PurchaseRefund/CancelPurchaseRefund"
const Path_PurchaseRefund_ConfirmPurchaseRefund = "/shop.PurchaseRefund/ConfirmPurchaseRefund"
const Path_PurchaseRefund_CreatePurchaseRefund = "/shop.PurchaseRefund/CreatePurchaseRefund"
const Path_PurchaseRefund_GetPurchaseRefund = "/shop.PurchaseRefund/GetPurchaseRefund"
const Path_PurchaseRefund_GetPurchaseRefunds = "/shop.PurchaseRefund/GetPurchaseRefunds"
const Path_PurchaseRefund_GetPurchaseRefundsByIDs = "/shop.PurchaseRefund/GetPurchaseRefundsByIDs"
const Path_PurchaseRefund_UpdatePurchaseRefund = "/shop.PurchaseRefund/UpdatePurchaseRefund"

func (s *PurchaseRefundServiceServer) PathPrefix() string {
	return PurchaseRefundServicePathPrefix
}

func (s *PurchaseRefundServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *PurchaseRefundServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PurchaseRefundServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.PurchaseRefund/CancelPurchaseRefund":
		msg := &CancelPurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelPurchaseRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/ConfirmPurchaseRefund":
		msg := &ConfirmPurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmPurchaseRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/CreatePurchaseRefund":
		msg := &CreatePurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePurchaseRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefund":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefunds":
		msg := &GetPurchaseRefundsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefunds(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefundsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefundsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/UpdatePurchaseRefund":
		msg := &UpdatePurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePurchaseRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ReceiptServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ReceiptService
}

func NewReceiptServiceServer(builder func() ReceiptService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ReceiptServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ReceiptServicePathPrefix = "/shop.Receipt/"

const Path_Receipt_CancelReceipt = "/shop.Receipt/CancelReceipt"
const Path_Receipt_ConfirmReceipt = "/shop.Receipt/ConfirmReceipt"
const Path_Receipt_CreateReceipt = "/shop.Receipt/CreateReceipt"
const Path_Receipt_GetReceipt = "/shop.Receipt/GetReceipt"
const Path_Receipt_GetReceipts = "/shop.Receipt/GetReceipts"
const Path_Receipt_GetReceiptsByLedgerType = "/shop.Receipt/GetReceiptsByLedgerType"
const Path_Receipt_UpdateReceipt = "/shop.Receipt/UpdateReceipt"

func (s *ReceiptServiceServer) PathPrefix() string {
	return ReceiptServicePathPrefix
}

func (s *ReceiptServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ReceiptServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ReceiptServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Receipt/CancelReceipt":
		msg := &CancelReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelReceipt(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/ConfirmReceipt":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmReceipt(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/CreateReceipt":
		msg := &CreateReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateReceipt(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipt":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceipt(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipts":
		msg := &GetReceiptsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceipts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceiptsByLedgerType":
		msg := &GetReceiptsByLedgerTypeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceiptsByLedgerType(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/UpdateReceipt":
		msg := &UpdateReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateReceipt(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type RefundServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() RefundService
}

func NewRefundServiceServer(builder func() RefundService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &RefundServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const RefundServicePathPrefix = "/shop.Refund/"

const Path_Refund_CancelRefund = "/shop.Refund/CancelRefund"
const Path_Refund_ConfirmRefund = "/shop.Refund/ConfirmRefund"
const Path_Refund_CreateRefund = "/shop.Refund/CreateRefund"
const Path_Refund_GetRefund = "/shop.Refund/GetRefund"
const Path_Refund_GetRefunds = "/shop.Refund/GetRefunds"
const Path_Refund_GetRefundsByIDs = "/shop.Refund/GetRefundsByIDs"
const Path_Refund_UpdateRefund = "/shop.Refund/UpdateRefund"

func (s *RefundServiceServer) PathPrefix() string {
	return RefundServicePathPrefix
}

func (s *RefundServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *RefundServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *RefundServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Refund/CancelRefund":
		msg := &CancelRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/ConfirmRefund":
		msg := &ConfirmRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/CreateRefund":
		msg := &CreateRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefund":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefunds":
		msg := &GetRefundsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefunds(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefundsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefundsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/UpdateRefund":
		msg := &UpdateRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateRefund(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipmentService
}

func NewShipmentServiceServer(builder func() ShipmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipmentServicePathPrefix = "/shop.Shipment/"

const Path_Shipment_CancelFulfillment = "/shop.Shipment/CancelFulfillment"
const Path_Shipment_CreateFulfillments = "/shop.Shipment/CreateFulfillments"
const Path_Shipment_CreateFulfillmentsFromImport = "/shop.Shipment/CreateFulfillmentsFromImport"
const Path_Shipment_GetShippingServices = "/shop.Shipment/GetShippingServices"
const Path_Shipment_UpdateFulfillmentCOD = "/shop.Shipment/UpdateFulfillmentCOD"
const Path_Shipment_UpdateFulfillmentInfo = "/shop.Shipment/UpdateFulfillmentInfo"

func (s *ShipmentServiceServer) PathPrefix() string {
	return ShipmentServicePathPrefix
}

func (s *ShipmentServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShipmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipment/CancelFulfillment":
		msg := &CancelFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/CreateFulfillments":
		msg := &CreateFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/CreateFulfillmentsFromImport":
		msg := &CreateFulfillmentsFromImportRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateFulfillmentsFromImport(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/GetShippingServices":
		msg := &inttypes.GetShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShippingServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/UpdateFulfillmentCOD":
		msg := &UpdateFulfillmentCODRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentCOD(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/UpdateFulfillmentInfo":
		msg := &UpdateFulfillmentInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipnowServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipnowService
}

func NewShipnowServiceServer(builder func() ShipnowService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipnowServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipnowServicePathPrefix = "/shop.Shipnow/"

const Path_Shipnow_CancelShipnowFulfillment = "/shop.Shipnow/CancelShipnowFulfillment"
const Path_Shipnow_ConfirmShipnowFulfillment = "/shop.Shipnow/ConfirmShipnowFulfillment"
const Path_Shipnow_CreateShipnowFulfillmentV2 = "/shop.Shipnow/CreateShipnowFulfillmentV2"
const Path_Shipnow_GetShipnowFulfillment = "/shop.Shipnow/GetShipnowFulfillment"
const Path_Shipnow_GetShipnowFulfillments = "/shop.Shipnow/GetShipnowFulfillments"
const Path_Shipnow_GetShipnowServices = "/shop.Shipnow/GetShipnowServices"
const Path_Shipnow_UpdateShipnowFulfillment = "/shop.Shipnow/UpdateShipnowFulfillment"

func (s *ShipnowServiceServer) PathPrefix() string {
	return ShipnowServicePathPrefix
}

func (s *ShipnowServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShipnowServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipnowServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipnow/CancelShipnowFulfillment":
		msg := &inttypes.CancelShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/ConfirmShipnowFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/CreateShipnowFulfillmentV2":
		msg := &inttypes.CreateShipnowFulfillmentV2Request{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipnowFulfillmentV2(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowFulfillments":
		msg := &inttypes.GetShipnowFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowServices":
		msg := &inttypes.GetShipnowServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/UpdateShipnowFulfillment":
		msg := &inttypes.UpdateShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipnowFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type StocktakeServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() StocktakeService
}

func NewStocktakeServiceServer(builder func() StocktakeService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &StocktakeServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const StocktakeServicePathPrefix = "/shop.Stocktake/"

const Path_Stocktake_CancelStocktake = "/shop.Stocktake/CancelStocktake"
const Path_Stocktake_ConfirmStocktake = "/shop.Stocktake/ConfirmStocktake"
const Path_Stocktake_CreateStocktake = "/shop.Stocktake/CreateStocktake"
const Path_Stocktake_GetStocktake = "/shop.Stocktake/GetStocktake"
const Path_Stocktake_GetStocktakes = "/shop.Stocktake/GetStocktakes"
const Path_Stocktake_GetStocktakesByIDs = "/shop.Stocktake/GetStocktakesByIDs"
const Path_Stocktake_UpdateStocktake = "/shop.Stocktake/UpdateStocktake"

func (s *StocktakeServiceServer) PathPrefix() string {
	return StocktakeServicePathPrefix
}

func (s *StocktakeServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *StocktakeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *StocktakeServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Stocktake/CancelStocktake":
		msg := &CancelStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelStocktake(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/ConfirmStocktake":
		msg := &ConfirmStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmStocktake(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/CreateStocktake":
		msg := &CreateStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateStocktake(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktake":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktake(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakes":
		msg := &GetStocktakesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktakes(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakesByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktakesByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/UpdateStocktake":
		msg := &UpdateStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateStocktake(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SubscriptionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SubscriptionService
}

func NewSubscriptionServiceServer(builder func() SubscriptionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SubscriptionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SubscriptionServicePathPrefix = "/shop.Subscription/"

const Path_Subscription_GetSubscription = "/shop.Subscription/GetSubscription"
const Path_Subscription_GetSubscriptions = "/shop.Subscription/GetSubscriptions"

func (s *SubscriptionServiceServer) PathPrefix() string {
	return SubscriptionServicePathPrefix
}

func (s *SubscriptionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *SubscriptionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SubscriptionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Subscription/GetSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Subscription/GetSubscriptions":
		msg := &inttypes.GetSubscriptionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptions(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SummaryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SummaryService
}

func NewSummaryServiceServer(builder func() SummaryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SummaryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SummaryServicePathPrefix = "/shop.Summary/"

const Path_Summary_CalcBalanceUser = "/shop.Summary/CalcBalanceUser"
const Path_Summary_SummarizeFulfillments = "/shop.Summary/SummarizeFulfillments"
const Path_Summary_SummarizePOS = "/shop.Summary/SummarizePOS"
const Path_Summary_SummarizeTopShip = "/shop.Summary/SummarizeTopShip"

func (s *SummaryServiceServer) PathPrefix() string {
	return SummaryServicePathPrefix
}

func (s *SummaryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *SummaryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SummaryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Summary/CalcBalanceUser":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CalcBalanceUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizeFulfillments":
		msg := &SummarizeFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizeFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizePOS":
		msg := &SummarizePOSRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizePOS(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizeTopShip":
		msg := &SummarizeTopShipRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizeTopShip(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SupplierServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SupplierService
}

func NewSupplierServiceServer(builder func() SupplierService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SupplierServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SupplierServicePathPrefix = "/shop.Supplier/"

const Path_Supplier_CreateSupplier = "/shop.Supplier/CreateSupplier"
const Path_Supplier_DeleteSupplier = "/shop.Supplier/DeleteSupplier"
const Path_Supplier_GetSupplier = "/shop.Supplier/GetSupplier"
const Path_Supplier_GetSuppliers = "/shop.Supplier/GetSuppliers"
const Path_Supplier_GetSuppliersByIDs = "/shop.Supplier/GetSuppliersByIDs"
const Path_Supplier_GetSuppliersByVariantID = "/shop.Supplier/GetSuppliersByVariantID"
const Path_Supplier_UpdateSupplier = "/shop.Supplier/UpdateSupplier"

func (s *SupplierServiceServer) PathPrefix() string {
	return SupplierServicePathPrefix
}

func (s *SupplierServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *SupplierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SupplierServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Supplier/CreateSupplier":
		msg := &CreateSupplierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSupplier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/DeleteSupplier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSupplier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSupplier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSupplier(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliers":
		msg := &GetSuppliersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByVariantID":
		msg := &GetSuppliersByVariantIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliersByVariantID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/UpdateSupplier":
		msg := &UpdateSupplierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSupplier(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TicketServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() TicketService
}

func NewTicketServiceServer(builder func() TicketService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &TicketServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const TicketServicePathPrefix = "/shop.Ticket/"

const Path_Ticket_CreateTicket = "/shop.Ticket/CreateTicket"
const Path_Ticket_CreateTicketComment = "/shop.Ticket/CreateTicketComment"
const Path_Ticket_DeleteTicketComment = "/shop.Ticket/DeleteTicketComment"
const Path_Ticket_GetTicket = "/shop.Ticket/GetTicket"
const Path_Ticket_GetTicketComments = "/shop.Ticket/GetTicketComments"
const Path_Ticket_GetTickets = "/shop.Ticket/GetTickets"
const Path_Ticket_GetTicketsByRefTicketID = "/shop.Ticket/GetTicketsByRefTicketID"
const Path_Ticket_UpdateTicketComment = "/shop.Ticket/UpdateTicketComment"

func (s *TicketServiceServer) PathPrefix() string {
	return TicketServicePathPrefix
}

func (s *TicketServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *TicketServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *TicketServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Ticket/CreateTicket":
		msg := &CreateTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/CreateTicketComment":
		msg := &CreateTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/DeleteTicketComment":
		msg := &DeleteTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/GetTicket":
		msg := &GetTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/GetTicketComments":
		msg := &GetTicketCommentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketComments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/GetTickets":
		msg := &GetTicketsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTickets(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/GetTicketsByRefTicketID":
		msg := &shoptypes.GetTicketsByRefTicketIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketsByRefTicketID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ticket/UpdateTicketComment":
		msg := &UpdateTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TradingServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() TradingService
}

func NewTradingServiceServer(builder func() TradingService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &TradingServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const TradingServicePathPrefix = "/shop.Trading/"

const Path_Trading_TradingCreateOrder = "/shop.Trading/TradingCreateOrder"
const Path_Trading_TradingGetOrder = "/shop.Trading/TradingGetOrder"
const Path_Trading_TradingGetOrders = "/shop.Trading/TradingGetOrders"
const Path_Trading_TradingGetProduct = "/shop.Trading/TradingGetProduct"
const Path_Trading_TradingGetProducts = "/shop.Trading/TradingGetProducts"

func (s *TradingServiceServer) PathPrefix() string {
	return TradingServicePathPrefix
}

func (s *TradingServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *TradingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *TradingServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Trading/TradingCreateOrder":
		msg := &inttypes.TradingCreateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingCreateOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetOrders(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProducts":
		msg := &common.CommonListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type WebServerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() WebServerService
}

func NewWebServerServiceServer(builder func() WebServerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &WebServerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const WebServerServicePathPrefix = "/shop.WebServer/"

const Path_WebServer_CreateOrUpdateWsCategory = "/shop.WebServer/CreateOrUpdateWsCategory"
const Path_WebServer_CreateOrUpdateWsProduct = "/shop.WebServer/CreateOrUpdateWsProduct"
const Path_WebServer_CreateWsPage = "/shop.WebServer/CreateWsPage"
const Path_WebServer_CreateWsWebsite = "/shop.WebServer/CreateWsWebsite"
const Path_WebServer_DeleteWsPage = "/shop.WebServer/DeleteWsPage"
const Path_WebServer_GetWsCategories = "/shop.WebServer/GetWsCategories"
const Path_WebServer_GetWsCategoriesByIDs = "/shop.WebServer/GetWsCategoriesByIDs"
const Path_WebServer_GetWsCategory = "/shop.WebServer/GetWsCategory"
const Path_WebServer_GetWsPage = "/shop.WebServer/GetWsPage"
const Path_WebServer_GetWsPages = "/shop.WebServer/GetWsPages"
const Path_WebServer_GetWsPagesByIDs = "/shop.WebServer/GetWsPagesByIDs"
const Path_WebServer_GetWsProduct = "/shop.WebServer/GetWsProduct"
const Path_WebServer_GetWsProducts = "/shop.WebServer/GetWsProducts"
const Path_WebServer_GetWsProductsByIDs = "/shop.WebServer/GetWsProductsByIDs"
const Path_WebServer_GetWsWebsite = "/shop.WebServer/GetWsWebsite"
const Path_WebServer_GetWsWebsites = "/shop.WebServer/GetWsWebsites"
const Path_WebServer_GetWsWebsitesByIDs = "/shop.WebServer/GetWsWebsitesByIDs"
const Path_WebServer_UpdateWsPage = "/shop.WebServer/UpdateWsPage"
const Path_WebServer_UpdateWsWebsite = "/shop.WebServer/UpdateWsWebsite"

func (s *WebServerServiceServer) PathPrefix() string {
	return WebServerServicePathPrefix
}

func (s *WebServerServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *WebServerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *WebServerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.WebServer/CreateOrUpdateWsCategory":
		msg := &CreateOrUpdateWsCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrUpdateWsCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateOrUpdateWsProduct":
		msg := &CreateOrUpdateWsProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrUpdateWsProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateWsPage":
		msg := &CreateWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateWsPage(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateWsWebsite":
		msg := &CreateWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateWsWebsite(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/DeleteWsPage":
		msg := &DeteleWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteWsPage(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategories":
		msg := &GetWsCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategories(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategoriesByIDs":
		msg := &GetWsCategoriesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategoriesByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategory":
		msg := &GetWsCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategory(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPage":
		msg := &GetWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPage(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPages":
		msg := &GetWsPagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPages(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPagesByIDs":
		msg := &GetWsPagesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPagesByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProduct":
		msg := &GetWsProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProducts":
		msg := &GetWsProductsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProductsByIDs":
		msg := &GetWsProductsByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProductsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsite":
		msg := &GetWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsite(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsites":
		msg := &GetWsWebsitesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsites(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsitesByIDs":
		msg := &GetWsWebsitesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsitesByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/UpdateWsPage":
		msg := &UpdateWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateWsPage(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/UpdateWsWebsite":
		msg := &UpdateWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateWsWebsite(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
