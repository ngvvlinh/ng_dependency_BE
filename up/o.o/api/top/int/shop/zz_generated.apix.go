// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package shop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	etop "o.o/api/top/int/etop"
	inttypes "o.o/api/top/int/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() AuthorizeService:
		return NewAuthorizeServiceServer(builder, hooks...), true
	case func() BrandService:
		return NewBrandServiceServer(builder, hooks...), true
	case func() CarrierService:
		return NewCarrierServiceServer(builder, hooks...), true
	case func() CategoryService:
		return NewCategoryServiceServer(builder, hooks...), true
	case func() CollectionService:
		return NewCollectionServiceServer(builder, hooks...), true
	case func() ConnectionService:
		return NewConnectionServiceServer(builder, hooks...), true
	case func() CustomerGroupService:
		return NewCustomerGroupServiceServer(builder, hooks...), true
	case func() CustomerService:
		return NewCustomerServiceServer(builder, hooks...), true
	case func() ExportService:
		return NewExportServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() HistoryService:
		return NewHistoryServiceServer(builder, hooks...), true
	case func() InventoryService:
		return NewInventoryServiceServer(builder, hooks...), true
	case func() LedgerService:
		return NewLedgerServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() MoneyTransactionService:
		return NewMoneyTransactionServiceServer(builder, hooks...), true
	case func() NotificationService:
		return NewNotificationServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() PaymentService:
		return NewPaymentServiceServer(builder, hooks...), true
	case func() ProductService:
		return NewProductServiceServer(builder, hooks...), true
	case func() ProductSourceService:
		return NewProductSourceServiceServer(builder, hooks...), true
	case func() PurchaseOrderService:
		return NewPurchaseOrderServiceServer(builder, hooks...), true
	case func() PurchaseRefundService:
		return NewPurchaseRefundServiceServer(builder, hooks...), true
	case func() ReceiptService:
		return NewReceiptServiceServer(builder, hooks...), true
	case func() RefundService:
		return NewRefundServiceServer(builder, hooks...), true
	case func() ShipmentService:
		return NewShipmentServiceServer(builder, hooks...), true
	case func() ShipnowService:
		return NewShipnowServiceServer(builder, hooks...), true
	case func() StocktakeService:
		return NewStocktakeServiceServer(builder, hooks...), true
	case func() SubscriptionService:
		return NewSubscriptionServiceServer(builder, hooks...), true
	case func() SummaryService:
		return NewSummaryServiceServer(builder, hooks...), true
	case func() SupplierService:
		return NewSupplierServiceServer(builder, hooks...), true
	case func() TradingService:
		return NewTradingServiceServer(builder, hooks...), true
	case func() WebServerService:
		return NewWebServerServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/shop.Account/"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Account/CreateExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateExternalAccountAhamove(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/DeleteShop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/GetBalanceShop":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBalanceShop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/GetExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExternalAccountAhamove(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/RegisterShop":
		msg := &RegisterShopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterShop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/RequestVerifyExternalAccountAhamove":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RequestVerifyExternalAccountAhamove(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/SetDefaultAddress":
		msg := &etop.SetDefaultAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SetDefaultAddress(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerification":
		msg := &UpdateXAccountAhamoveVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateExternalAccountAhamoveVerification(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerificationImages":
		msg := &UpdateXAccountAhamoveVerificationRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateExternalAccountAhamoveVerificationImages(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Account/UpdateShop":
		msg := &UpdateShopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShop(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AuthorizeServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AuthorizeService
}

func NewAuthorizeServiceServer(builder func() AuthorizeService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AuthorizeServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AuthorizeServicePathPrefix = "/shop.Authorize/"

func (s *AuthorizeServiceServer) PathPrefix() string {
	return AuthorizeServicePathPrefix
}

func (s *AuthorizeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AuthorizeServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Authorize/AuthorizePartner":
		msg := &AuthorizePartnerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AuthorizePartner(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAuthorizedPartners":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAuthorizedPartners(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAvailablePartners":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAvailablePartners(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type BrandServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() BrandService
}

func NewBrandServiceServer(builder func() BrandService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &BrandServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const BrandServicePathPrefix = "/shop.Brand/"

func (s *BrandServiceServer) PathPrefix() string {
	return BrandServicePathPrefix
}

func (s *BrandServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *BrandServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Brand/CreateBrand":
		msg := &CreateBrandRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateBrand(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/DeleteBrand":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteBrand(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandByID":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrandByID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrands":
		msg := &GetBrandsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrands(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBrandsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Brand/UpdateBrandInfo":
		msg := &UpdateBrandRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateBrandInfo(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CarrierServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CarrierService
}

func NewCarrierServiceServer(builder func() CarrierService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CarrierServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CarrierServicePathPrefix = "/shop.Carrier/"

func (s *CarrierServiceServer) PathPrefix() string {
	return CarrierServicePathPrefix
}

func (s *CarrierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CarrierServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Carrier/CreateCarrier":
		msg := &CreateCarrierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCarrier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/DeleteCarrier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCarrier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarrier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarrier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriers":
		msg := &GetCarriersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarriers(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCarriersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Carrier/UpdateCarrier":
		msg := &UpdateCarrierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCarrier(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CategoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CategoryService
}

func NewCategoryServiceServer(builder func() CategoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CategoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CategoryServicePathPrefix = "/shop.Category/"

func (s *CategoryServiceServer) PathPrefix() string {
	return CategoryServicePathPrefix
}

func (s *CategoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CategoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Category/CreateCategory":
		msg := &CreateCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/DeleteCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/GetCategories":
		msg := &GetCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCategories(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/GetCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Category/UpdateCategory":
		msg := &UpdateCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CollectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CollectionService
}

func NewCollectionServiceServer(builder func() CollectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CollectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CollectionServicePathPrefix = "/shop.Collection/"

func (s *CollectionServiceServer) PathPrefix() string {
	return CollectionServicePathPrefix
}

func (s *CollectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CollectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Collection/CreateCollection":
		msg := &CreateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCollection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollections":
		msg := &GetCollectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollectionsByProductID":
		msg := &GetShopCollectionsByProductIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCollectionsByProductID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Collection/UpdateCollection":
		msg := &UpdateCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCollection(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ConnectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ConnectionService
}

func NewConnectionServiceServer(builder func() ConnectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ConnectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ConnectionServicePathPrefix = "/shop.Connection/"

func (s *ConnectionServiceServer) PathPrefix() string {
	return ConnectionServicePathPrefix
}

func (s *ConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ConnectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Connection/DeleteShopConnection":
		msg := &inttypes.DeleteShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShopConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetAvailableConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAvailableConnections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/GetShopConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopConnections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/LoginShopConnection":
		msg := &inttypes.LoginShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.LoginShopConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/RegisterShopConnection":
		msg := &inttypes.RegisterShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RegisterShopConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Connection/UpdateShopConnection":
		msg := &inttypes.UpdateShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShopConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerGroupService
}

func NewCustomerGroupServiceServer(builder func() CustomerGroupService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerGroupServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerGroupServicePathPrefix = "/shop.CustomerGroup/"

func (s *CustomerGroupServiceServer) PathPrefix() string {
	return CustomerGroupServicePathPrefix
}

func (s *CustomerGroupServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerGroupServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroup/CreateCustomerGroup":
		msg := &CreateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomerGroup(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerGroup(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroups":
		msg := &GetCustomerGroupsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerGroups(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/UpdateCustomerGroup":
		msg := &UpdateCustomerGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomerGroup(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CustomerService
}

func NewCustomerServiceServer(builder func() CustomerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CustomerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CustomerServicePathPrefix = "/shop.Customer/"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Customer/AddCustomersToGroup":
		msg := &AddCustomerToGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AddCustomersToGroup(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/BatchSetCustomersStatus":
		msg := &SetCustomersStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.BatchSetCustomersStatus(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomer":
		msg := &CreateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomer(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomerAddress":
		msg := &CreateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomerAddress(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomer":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomer(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomerAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomerAddress(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomer":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomer(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerAddresses":
		msg := &GetCustomerAddressesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerAddresses(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerDetails":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomerDetails(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomers":
		msg := &GetCustomersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomers(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/RemoveCustomersFromGroup":
		msg := &RemoveCustomerOutOfGroupRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveCustomersFromGroup(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/SetDefaultCustomerAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SetDefaultCustomerAddress(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomer":
		msg := &UpdateCustomerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomer(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomerAddress":
		msg := &UpdateCustomerAddressRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomerAddress(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ExportServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ExportService
}

func NewExportServiceServer(builder func() ExportService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ExportServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ExportServicePathPrefix = "/shop.Export/"

func (s *ExportServiceServer) PathPrefix() string {
	return ExportServicePathPrefix
}

func (s *ExportServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ExportServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Export/GetExports":
		msg := &GetExportsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExports(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Export/RequestExport":
		msg := &RequestExportRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RequestExport(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/shop.Fulfillment/"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Fulfillment/GetExternalShippingServices":
		msg := &inttypes.GetExternalShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetExternalShippingServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillments":
		msg := &GetFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillmentsByIDs":
		msg := &GetFulfillmentsByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillmentsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicExternalShippingServices":
		msg := &inttypes.GetExternalShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicExternalShippingServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicFulfillment":
		msg := &GetPublicFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPublicFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Fulfillment/UpdateFulfillmentsShippingState":
		msg := &UpdateFulfillmentsShippingStateRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentsShippingState(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() HistoryService
}

func NewHistoryServiceServer(builder func() HistoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &HistoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const HistoryServicePathPrefix = "/shop.History/"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.History/GetFulfillmentHistory":
		msg := &GetFulfillmentHistoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillmentHistory(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InventoryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() InventoryService
}

func NewInventoryServiceServer(builder func() InventoryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &InventoryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const InventoryServicePathPrefix = "/shop.Inventory/"

func (s *InventoryServiceServer) PathPrefix() string {
	return InventoryServicePathPrefix
}

func (s *InventoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *InventoryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Inventory/AdjustInventoryQuantity":
		msg := &AdjustInventoryQuantityRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AdjustInventoryQuantity(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/CancelInventoryVoucher":
		msg := &CancelInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelInventoryVoucher(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/ConfirmInventoryVoucher":
		msg := &ConfirmInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmInventoryVoucher(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/CreateInventoryVoucher":
		msg := &CreateInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateInventoryVoucher(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariant":
		msg := &GetInventoryVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariant(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariants":
		msg := &GetInventoryVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariants(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariantsByVariantIDs":
		msg := &GetInventoryVariantsByVariantIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVariantsByVariantIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVoucher":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVoucher(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchers":
		msg := &GetInventoryVouchersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchers(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByIDs":
		msg := &GetInventoryVouchersByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByReference":
		msg := &GetInventoryVouchersByReferenceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInventoryVouchersByReference(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVariantCostPrice":
		msg := &UpdateInventoryVariantCostPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateInventoryVariantCostPrice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVoucher":
		msg := &UpdateInventoryVoucherRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateInventoryVoucher(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LedgerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() LedgerService
}

func NewLedgerServiceServer(builder func() LedgerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &LedgerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const LedgerServicePathPrefix = "/shop.Ledger/"

func (s *LedgerServiceServer) PathPrefix() string {
	return LedgerServicePathPrefix
}

func (s *LedgerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *LedgerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Ledger/CreateLedger":
		msg := &CreateLedgerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateLedger(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/DeleteLedger":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteLedger(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedger":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetLedger(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedgers":
		msg := &GetLedgersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetLedgers(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Ledger/UpdateLedger":
		msg := &UpdateLedgerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateLedger(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/shop.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MoneyTransactionService
}

func NewMoneyTransactionServiceServer(builder func() MoneyTransactionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MoneyTransactionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MoneyTransactionServicePathPrefix = "/shop.MoneyTransaction/"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.MoneyTransaction/GetMoneyTransaction":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransaction(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.MoneyTransaction/GetMoneyTransactions":
		msg := &GetMoneyTransactionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactions(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() NotificationService
}

func NewNotificationServiceServer(builder func() NotificationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &NotificationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const NotificationServicePathPrefix = "/shop.Notification/"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Notification/CreateDevice":
		msg := &etop.CreateDeviceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateDevice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/DeleteDevice":
		msg := &etop.DeleteDeviceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteDevice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotification":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetNotification(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotifications":
		msg := &etop.GetNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetNotifications(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Notification/UpdateNotifications":
		msg := &etop.UpdateNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateNotifications(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/shop.Order/"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Order/CancelOrder":
		msg := &CancelOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/CompleteOrder":
		msg := &OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CompleteOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrder":
		msg := &ConfirmOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrderAndCreateFulfillments":
		msg := &OrderIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmOrderAndCreateFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/CreateOrder":
		msg := &inttypes.CreateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrders(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByIDs":
		msg := &etop.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByReceiptID":
		msg := &GetOrdersByReceiptIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByReceiptID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrder":
		msg := &inttypes.UpdateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderPaymentStatus":
		msg := &UpdateOrderPaymentStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrderPaymentStatus(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderShippingInfo":
		msg := &UpdateOrderShippingInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrderShippingInfo(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrdersStatus":
		msg := &UpdateOrdersStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateOrdersStatus(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PaymentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PaymentService
}

func NewPaymentServiceServer(builder func() PaymentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PaymentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PaymentServicePathPrefix = "/shop.Payment/"

func (s *PaymentServiceServer) PathPrefix() string {
	return PaymentServicePathPrefix
}

func (s *PaymentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PaymentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Payment/PaymentCheckReturnData":
		msg := &PaymentCheckReturnDataRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.PaymentCheckReturnData(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Payment/PaymentTradingOrder":
		msg := &PaymentTradingOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.PaymentTradingOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductService
}

func NewProductServiceServer(builder func() ProductService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductServicePathPrefix = "/shop.Product/"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Product/AddProductCollection":
		msg := &AddShopProductCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AddProductCollection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/CreateProduct":
		msg := &CreateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/CreateVariant":
		msg := &CreateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateVariant(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProducts":
		msg := &GetVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProducts(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetProductsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariant":
		msg := &GetVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariant(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariantsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsBySupplierID":
		msg := &GetVariantsBySupplierIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetVariantsBySupplierID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCollection":
		msg := &RemoveShopProductCollectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductCollection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProducts":
		msg := &RemoveVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProducts(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/RemoveVariants":
		msg := &RemoveVariantsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveVariants(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProduct":
		msg := &UpdateProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductCategory":
		msg := &UpdateProductCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductImages":
		msg := &UpdateVariantImagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductImages(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductMetaFields":
		msg := &UpdateProductMetaFieldsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductMetaFields(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsStatus":
		msg := &UpdateProductStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsStatus(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsTags":
		msg := &UpdateProductsTagsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsTags(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariant":
		msg := &UpdateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariant(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantAttributes":
		msg := &UpdateVariantAttributesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantAttributes(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantImages":
		msg := &UpdateVariantImagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantImages(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantsStatus":
		msg := &UpdateProductStatusRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateVariantsStatus(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductSourceServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ProductSourceService
}

func NewProductSourceServiceServer(builder func() ProductSourceService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ProductSourceServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ProductSourceServicePathPrefix = "/shop.ProductSource/"

func (s *ProductSourceServiceServer) PathPrefix() string {
	return ProductSourceServicePathPrefix
}

func (s *ProductSourceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ProductSourceServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductSource/CreateProductSource":
		msg := &CreateProductSourceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProductSource(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateProductSourceCategory":
		msg := &CreatePSCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateProductSourceCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateVariant":
		msg := &DeprecatedCreateVariantRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateVariant(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategories":
		msg := &GetProductSourceCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductSourceCategories(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetProductSourceCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetShopProductSources":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopProductSources(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/RemoveProductSourceCategory":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveProductSourceCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductSourceCategory":
		msg := &UpdateProductSourceCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductSourceCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductsPSCategory":
		msg := &UpdateProductsPSCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateProductsPSCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PurchaseOrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PurchaseOrderService
}

func NewPurchaseOrderServiceServer(builder func() PurchaseOrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PurchaseOrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PurchaseOrderServicePathPrefix = "/shop.PurchaseOrder/"

func (s *PurchaseOrderServiceServer) PathPrefix() string {
	return PurchaseOrderServicePathPrefix
}

func (s *PurchaseOrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PurchaseOrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.PurchaseOrder/CancelPurchaseOrder":
		msg := &CancelPurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelPurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/ConfirmPurchaseOrder":
		msg := &ConfirmPurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmPurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/CreatePurchaseOrder":
		msg := &CreatePurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/DeletePurchaseOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeletePurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrders":
		msg := &GetPurchaseOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrders(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrdersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByReceiptID":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseOrdersByReceiptID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/UpdatePurchaseOrder":
		msg := &UpdatePurchaseOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePurchaseOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PurchaseRefundServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() PurchaseRefundService
}

func NewPurchaseRefundServiceServer(builder func() PurchaseRefundService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &PurchaseRefundServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const PurchaseRefundServicePathPrefix = "/shop.PurchaseRefund/"

func (s *PurchaseRefundServiceServer) PathPrefix() string {
	return PurchaseRefundServicePathPrefix
}

func (s *PurchaseRefundServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *PurchaseRefundServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.PurchaseRefund/CancelPurchaseRefund":
		msg := &CancelPurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelPurchaseRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/ConfirmPurchaseRefund":
		msg := &ConfirmPurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmPurchaseRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/CreatePurchaseRefund":
		msg := &CreatePurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePurchaseRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefund":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefunds":
		msg := &GetPurchaseRefundsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefunds(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/GetPurchaseRefundsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetPurchaseRefundsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.PurchaseRefund/UpdatePurchaseRefund":
		msg := &UpdatePurchaseRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdatePurchaseRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ReceiptServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ReceiptService
}

func NewReceiptServiceServer(builder func() ReceiptService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ReceiptServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ReceiptServicePathPrefix = "/shop.Receipt/"

func (s *ReceiptServiceServer) PathPrefix() string {
	return ReceiptServicePathPrefix
}

func (s *ReceiptServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ReceiptServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Receipt/CancelReceipt":
		msg := &CancelReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelReceipt(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/ConfirmReceipt":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmReceipt(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/CreateReceipt":
		msg := &CreateReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateReceipt(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipt":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceipt(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipts":
		msg := &GetReceiptsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceipts(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceiptsByLedgerType":
		msg := &GetReceiptsByLedgerTypeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetReceiptsByLedgerType(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Receipt/UpdateReceipt":
		msg := &UpdateReceiptRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateReceipt(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type RefundServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() RefundService
}

func NewRefundServiceServer(builder func() RefundService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &RefundServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const RefundServicePathPrefix = "/shop.Refund/"

func (s *RefundServiceServer) PathPrefix() string {
	return RefundServicePathPrefix
}

func (s *RefundServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *RefundServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Refund/CancelRefund":
		msg := &CancelRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/ConfirmRefund":
		msg := &ConfirmRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/CreateRefund":
		msg := &CreateRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefund":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefunds":
		msg := &GetRefundsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefunds(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/GetRefundsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetRefundsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Refund/UpdateRefund":
		msg := &UpdateRefundRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateRefund(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipmentService
}

func NewShipmentServiceServer(builder func() ShipmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipmentServicePathPrefix = "/shop.Shipment/"

func (s *ShipmentServiceServer) PathPrefix() string {
	return ShipmentServicePathPrefix
}

func (s *ShipmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipment/CancelFulfillment":
		msg := &CancelFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/CreateFulfillments":
		msg := &CreateFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipment/GetShippingServices":
		msg := &inttypes.GetShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShippingServices(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipnowServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipnowService
}

func NewShipnowServiceServer(builder func() ShipnowService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipnowServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipnowServicePathPrefix = "/shop.Shipnow/"

func (s *ShipnowServiceServer) PathPrefix() string {
	return ShipnowServicePathPrefix
}

func (s *ShipnowServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipnowServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipnow/CancelShipnowFulfillment":
		msg := &inttypes.CancelShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelShipnowFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/ConfirmShipnowFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmShipnowFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/CreateShipnowFulfillment":
		msg := &inttypes.CreateShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipnowFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/CreateShipnowFulfillmentV2":
		msg := &inttypes.CreateShipnowFulfillmentV2Request{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipnowFulfillmentV2(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowFulfillments":
		msg := &inttypes.GetShipnowFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/GetShipnowServices":
		msg := &inttypes.GetShipnowServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipnowServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Shipnow/UpdateShipnowFulfillment":
		msg := &inttypes.UpdateShipnowFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipnowFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type StocktakeServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() StocktakeService
}

func NewStocktakeServiceServer(builder func() StocktakeService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &StocktakeServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const StocktakeServicePathPrefix = "/shop.Stocktake/"

func (s *StocktakeServiceServer) PathPrefix() string {
	return StocktakeServicePathPrefix
}

func (s *StocktakeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *StocktakeServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Stocktake/CancelStocktake":
		msg := &CancelStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelStocktake(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/ConfirmStocktake":
		msg := &ConfirmStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmStocktake(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/CreateStocktake":
		msg := &CreateStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateStocktake(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktake":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktake(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakes":
		msg := &GetStocktakesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktakes(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakesByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetStocktakesByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Stocktake/UpdateStocktake":
		msg := &UpdateStocktakeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateStocktake(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SubscriptionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SubscriptionService
}

func NewSubscriptionServiceServer(builder func() SubscriptionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SubscriptionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SubscriptionServicePathPrefix = "/shop.Subscription/"

func (s *SubscriptionServiceServer) PathPrefix() string {
	return SubscriptionServicePathPrefix
}

func (s *SubscriptionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SubscriptionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Subscription/GetSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Subscription/GetSubscriptions":
		msg := &inttypes.GetSubscriptionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptions(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SummaryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SummaryService
}

func NewSummaryServiceServer(builder func() SummaryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SummaryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SummaryServicePathPrefix = "/shop.Summary/"

func (s *SummaryServiceServer) PathPrefix() string {
	return SummaryServicePathPrefix
}

func (s *SummaryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SummaryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Summary/CalcBalanceShop":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CalcBalanceShop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizeFulfillments":
		msg := &SummarizeFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizeFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizePOS":
		msg := &SummarizePOSRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizePOS(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizeTopShip":
		msg := &SummarizeTopShipRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SummarizeTopShip(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SupplierServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SupplierService
}

func NewSupplierServiceServer(builder func() SupplierService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SupplierServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SupplierServicePathPrefix = "/shop.Supplier/"

func (s *SupplierServiceServer) PathPrefix() string {
	return SupplierServicePathPrefix
}

func (s *SupplierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SupplierServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Supplier/CreateSupplier":
		msg := &CreateSupplierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSupplier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/DeleteSupplier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSupplier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSupplier":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSupplier(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliers":
		msg := &GetSuppliersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliers(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByVariantID":
		msg := &GetSuppliersByVariantIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSuppliersByVariantID(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Supplier/UpdateSupplier":
		msg := &UpdateSupplierRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSupplier(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TradingServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() TradingService
}

func NewTradingServiceServer(builder func() TradingService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &TradingServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const TradingServicePathPrefix = "/shop.Trading/"

func (s *TradingServiceServer) PathPrefix() string {
	return TradingServicePathPrefix
}

func (s *TradingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *TradingServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Trading/TradingCreateOrder":
		msg := &inttypes.TradingCreateOrderRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingCreateOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetOrders(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProducts":
		msg := &common.CommonListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.TradingGetProducts(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type WebServerServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() WebServerService
}

func NewWebServerServiceServer(builder func() WebServerService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &WebServerServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const WebServerServicePathPrefix = "/shop.WebServer/"

func (s *WebServerServiceServer) PathPrefix() string {
	return WebServerServicePathPrefix
}

func (s *WebServerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *WebServerServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.WebServer/CreateOrUpdateWsCategory":
		msg := &CreateOrUpdateWsCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrUpdateWsCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateOrUpdateWsProduct":
		msg := &CreateOrUpdateWsProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateOrUpdateWsProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateWsPage":
		msg := &CreateWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateWsPage(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/CreateWsWebsite":
		msg := &CreateWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateWsWebsite(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/DeleteWsPage":
		msg := &DeteleWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteWsPage(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategories":
		msg := &GetWsCategoriesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategories(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategoriesByIDs":
		msg := &GetWsCategoriesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategoriesByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsCategory":
		msg := &GetWsCategoryRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsCategory(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPage":
		msg := &GetWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPage(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPages":
		msg := &GetWsPagesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPages(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsPagesByIDs":
		msg := &GetWsPagesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsPagesByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProduct":
		msg := &GetWsProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProducts":
		msg := &GetWsProductsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProducts(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsProductsByIDs":
		msg := &GetWsProductsByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsProductsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsite":
		msg := &GetWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsite(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsites":
		msg := &GetWsWebsitesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsites(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/GetWsWebsitesByIDs":
		msg := &GetWsWebsitesByIDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetWsWebsitesByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/UpdateWsPage":
		msg := &UpdateWsPageRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateWsPage(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/shop.WebServer/UpdateWsWebsite":
		msg := &UpdateWsWebsiteRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateWsWebsite(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
