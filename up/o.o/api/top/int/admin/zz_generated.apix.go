// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package admin

import (
	context "context"
	fmt "fmt"
	http "net/http"

	inttypes "o.o/api/top/int/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() ConnectionService:
		return NewConnectionServiceServer(builder, hooks...), true
	case func() CreditService:
		return NewCreditServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() LocationService:
		return NewLocationServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() MoneyTransactionService:
		return NewMoneyTransactionServiceServer(builder, hooks...), true
	case func() NotificationService:
		return NewNotificationServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() ShipmentPriceService:
		return NewShipmentPriceServiceServer(builder, hooks...), true
	case func() ShopService:
		return NewShopServiceServer(builder, hooks...), true
	case func() SubscriptionService:
		return NewSubscriptionServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/admin.Account/"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Account/CreatePartner":
		msg := &CreatePartnerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePartner(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/GenerateAPIKey":
		msg := &GenerateAPIKeyRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GenerateAPIKey(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ConnectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ConnectionService
}

func NewConnectionServiceServer(builder func() ConnectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ConnectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ConnectionServicePathPrefix = "/admin.Connection/"

func (s *ConnectionServiceServer) PathPrefix() string {
	return ConnectionServicePathPrefix
}

func (s *ConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ConnectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Connection/ConfirmConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/CreateBuiltinConnection":
		msg := &inttypes.CreateBuiltinConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateBuiltinConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/DisableConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DisableConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetBuiltinShopConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBuiltinShopConnections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnectionServices":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnectionServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnections":
		msg := &inttypes.GetConnectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnections(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/UpdateBuiltinShopConnection":
		msg := &inttypes.UpdateShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateBuiltinShopConnection(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CreditServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CreditService
}

func NewCreditServiceServer(builder func() CreditService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CreditServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CreditServicePathPrefix = "/admin.Credit/"

func (s *CreditServiceServer) PathPrefix() string {
	return CreditServicePathPrefix
}

func (s *CreditServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CreditServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Credit/ConfirmCredit":
		msg := &ConfirmCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmCredit(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/CreateCredit":
		msg := &CreateCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCredit(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/DeleteCredit":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCredit(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredit":
		msg := &GetCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCredit(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredits":
		msg := &GetCreditsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCredits(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/UpdateCredit":
		msg := &UpdateCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCredit(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/admin.Fulfillment/"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Fulfillment/GetFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/GetFulfillments":
		msg := &GetFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillments(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillment":
		msg := &UpdateFulfillmentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillment(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingFee":
		msg := &UpdateFulfillmentShippingFeeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentShippingFee(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingState":
		msg := &UpdateFulfillmentShippingStateRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentShippingState(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LocationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() LocationService
}

func NewLocationServiceServer(builder func() LocationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &LocationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const LocationServicePathPrefix = "/admin.Location/"

func (s *LocationServiceServer) PathPrefix() string {
	return LocationServicePathPrefix
}

func (s *LocationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *LocationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Location/CreateCustomRegion":
		msg := &CreateCustomRegionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomRegion(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/DeleteCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomRegion(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomRegion(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegions":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomRegions(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/UpdateCustomRegion":
		msg := &CustomRegion{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomRegion(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/admin.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Misc/AdminLoginAsAccount":
		msg := &LoginAsAccountRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AdminLoginAsAccount(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MoneyTransactionService
}

func NewMoneyTransactionServiceServer(builder func() MoneyTransactionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MoneyTransactionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MoneyTransactionServicePathPrefix = "/admin.MoneyTransaction/"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.MoneyTransaction/ConfirmMoneyTransaction":
		msg := &ConfirmMoneyTransactionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransaction(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop":
		msg := &ConfirmMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransactionShippingEtop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransactionShippingExternals(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/CreateMoneyTransactionShippingEtop":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateMoneyTransactionShippingEtop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteMoneyTransactionShippingEtop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteMoneyTransactionShippingExternal(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransaction":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransaction(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingEtop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtops":
		msg := &GetMoneyTransactionShippingEtopsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingEtops(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingExternal(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternals":
		msg := &GetMoneyTransactionShippingExternalsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingExternals(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactions":
		msg := &GetMoneyTransactionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactions(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines":
		msg := &RemoveMoneyTransactionShippingExternalLinesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveMoneyTransactionShippingExternalLines(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransaction":
		msg := &UpdateMoneyTransactionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransaction(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop":
		msg := &UpdateMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransactionShippingEtop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal":
		msg := &UpdateMoneyTransactionShippingExternalRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransactionShippingExternal(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() NotificationService
}

func NewNotificationServiceServer(builder func() NotificationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &NotificationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const NotificationServicePathPrefix = "/admin.Notification/"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Notification/CreateNotifications":
		msg := &CreateNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateNotifications(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/admin.Order/"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Order/GetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Order/GetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrders(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Order/GetOrdersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentPriceServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipmentPriceService
}

func NewShipmentPriceServiceServer(builder func() ShipmentPriceService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipmentPriceServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipmentPriceServicePathPrefix = "/admin.ShipmentPrice/"

func (s *ShipmentPriceServiceServer) PathPrefix() string {
	return ShipmentPriceServicePathPrefix
}

func (s *ShipmentPriceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipmentPriceServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.ShipmentPrice/ActivateShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ActivateShipmentPriceList(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPrice":
		msg := &CreateShipmentPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentPrice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPriceList":
		msg := &CreateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentPriceList(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentService":
		msg := &CreateShipmentServiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentService(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentPrice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentPriceList(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentService(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPrice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceList(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceLists":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceLists(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrices":
		msg := &GetShipmentPricesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPrices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentService(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentServices":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShippingServices":
		msg := &GetShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShippingServices(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPrice":
		msg := &UpdateShipmentPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPrice(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPriceList":
		msg := &UpdateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPriceList(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPricesPriorityPoint":
		msg := &UpdateShipmentPricesPriorityPointRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPricesPriorityPoint(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentService":
		msg := &UpdateShipmentServiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentService(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesAvailableLocations":
		msg := &UpdateShipmentServicesAvailableLocationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentServicesAvailableLocations(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesBlacklistLocations":
		msg := &UpdateShipmentServicesBlacklistLocationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentServicesBlacklistLocations(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShopServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShopService
}

func NewShopServiceServer(builder func() ShopService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShopServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShopServicePathPrefix = "/admin.Shop/"

func (s *ShopServiceServer) PathPrefix() string {
	return ShopServicePathPrefix
}

func (s *ShopServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShopServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Shop/GetShop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShop(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Shop/GetShops":
		msg := &GetShopsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShops(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Shop/GetShopsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopsByIDs(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SubscriptionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SubscriptionService
}

func NewSubscriptionServiceServer(builder func() SubscriptionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SubscriptionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SubscriptionServicePathPrefix = "/admin.Subscription/"

func (s *SubscriptionServiceServer) PathPrefix() string {
	return SubscriptionServicePathPrefix
}

func (s *SubscriptionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks.BuildHooks())
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.BeforeRequest(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SubscriptionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Subscription/ActivateSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ActivateSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CancelSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscription":
		msg := &inttypes.CreateSubscriptionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscriptionBill":
		msg := &inttypes.CreateSubscriptionBillRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscriptionBill(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscriptionPlan":
		msg := &inttypes.CreateSubrPlanRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscriptionPlan(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscriptionProduct":
		msg := &inttypes.CreateSubrProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscriptionProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscriptionBill":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscriptionBill(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscriptionPlan":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscriptionPlan(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscriptionProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscriptionProduct(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscription(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptionBills":
		msg := &inttypes.GetSubscriptionBillsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptionBills(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptionPlans":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptionPlans(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptionProducts":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptionProducts(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptions":
		msg := &inttypes.GetSubscriptionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptions(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/ManualPaymentSubscriptionBill":
		msg := &inttypes.ManualPaymentSubscriptionBillRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ManualPaymentSubscriptionBill(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/UpdateSubscriptionInfo":
		msg := &inttypes.UpdateSubscriptionInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSubscriptionInfo(ctx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/UpdateSubscriptionPlan":
		msg := &inttypes.UpdateSubrPlanRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.BeforeServing(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSubscriptionPlan(ctx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
