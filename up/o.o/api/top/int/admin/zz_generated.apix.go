// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package admin

import (
	context "context"
	fmt "fmt"
	http "net/http"

	inttypes "o.o/api/top/int/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func RegisterServers() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...*httprpc.Hooks) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() ConnectionService:
		return NewConnectionServiceServer(builder, hooks...), true
	case func() CreditService:
		return NewCreditServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() LocationService:
		return NewLocationServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() MoneyTransactionService:
		return NewMoneyTransactionServiceServer(builder, hooks...), true
	case func() NotificationService:
		return NewNotificationServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() ShipmentPriceService:
		return NewShipmentPriceServiceServer(builder, hooks...), true
	case func() ShopService:
		return NewShopServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountServiceServer struct {
	hooks   httprpc.Hooks
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/admin.Account/"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Account/CreatePartner":
		msg := &CreatePartnerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreatePartner(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Account/GenerateAPIKey":
		msg := &GenerateAPIKeyRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GenerateAPIKey(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ConnectionServiceServer struct {
	hooks   httprpc.Hooks
	builder func() ConnectionService
}

func NewConnectionServiceServer(builder func() ConnectionService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &ConnectionServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const ConnectionServicePathPrefix = "/admin.Connection/"

func (s *ConnectionServiceServer) PathPrefix() string {
	return ConnectionServicePathPrefix
}

func (s *ConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *ConnectionServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Connection/ConfirmConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ConfirmConnection(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/CreateBuiltinConnection":
		msg := &inttypes.CreateBuiltinConnectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateBuiltinConnection(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/DisableConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DisableConnection(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/GetBuiltinShopConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetBuiltinShopConnections(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnectionServices":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetConnectionServices(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnections":
		msg := &inttypes.GetConnectionsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetConnections(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Connection/UpdateBuiltinShopConnection":
		msg := &inttypes.UpdateShopConnectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateBuiltinShopConnection(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CreditServiceServer struct {
	hooks   httprpc.Hooks
	builder func() CreditService
}

func NewCreditServiceServer(builder func() CreditService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &CreditServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const CreditServicePathPrefix = "/admin.Credit/"

func (s *CreditServiceServer) PathPrefix() string {
	return CreditServicePathPrefix
}

func (s *CreditServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *CreditServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Credit/ConfirmCredit":
		msg := &ConfirmCreditRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ConfirmCredit(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Credit/CreateCredit":
		msg := &CreateCreditRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateCredit(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Credit/DeleteCredit":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteCredit(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredit":
		msg := &GetCreditRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetCredit(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredits":
		msg := &GetCreditsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetCredits(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Credit/UpdateCredit":
		msg := &UpdateCreditRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateCredit(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.Hooks
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/admin.Fulfillment/"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Fulfillment/GetFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Fulfillment/GetFulfillments":
		msg := &GetFulfillmentsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetFulfillments(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillment":
		msg := &UpdateFulfillmentRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingFee":
		msg := &UpdateFulfillmentShippingFeeRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateFulfillmentShippingFee(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingState":
		msg := &UpdateFulfillmentShippingStateRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateFulfillmentShippingState(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LocationServiceServer struct {
	hooks   httprpc.Hooks
	builder func() LocationService
}

func NewLocationServiceServer(builder func() LocationService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &LocationServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const LocationServicePathPrefix = "/admin.Location/"

func (s *LocationServiceServer) PathPrefix() string {
	return LocationServicePathPrefix
}

func (s *LocationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *LocationServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Location/CreateCustomRegion":
		msg := &CreateCustomRegionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateCustomRegion(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Location/DeleteCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteCustomRegion(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetCustomRegion(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegions":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetCustomRegions(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Location/UpdateCustomRegion":
		msg := &CustomRegion{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateCustomRegion(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.Hooks
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/admin.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Misc/AdminLoginAsAccount":
		msg := &LoginAsAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.AdminLoginAsAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	hooks   httprpc.Hooks
	builder func() MoneyTransactionService
}

func NewMoneyTransactionServiceServer(builder func() MoneyTransactionService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &MoneyTransactionServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const MoneyTransactionServicePathPrefix = "/admin.MoneyTransaction/"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.MoneyTransaction/ConfirmMoneyTransaction":
		msg := &ConfirmMoneyTransactionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ConfirmMoneyTransaction(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop":
		msg := &ConfirmMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ConfirmMoneyTransactionShippingEtop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ConfirmMoneyTransactionShippingExternals(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/CreateMoneyTransactionShippingEtop":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateMoneyTransactionShippingEtop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteMoneyTransactionShippingEtop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteMoneyTransactionShippingExternal(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransaction":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransaction(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransactionShippingEtop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtops":
		msg := &GetMoneyTransactionShippingEtopsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransactionShippingEtops(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransactionShippingExternal(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternals":
		msg := &GetMoneyTransactionShippingExternalsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransactionShippingExternals(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactions":
		msg := &GetMoneyTransactionsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetMoneyTransactions(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines":
		msg := &RemoveMoneyTransactionShippingExternalLinesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.RemoveMoneyTransactionShippingExternalLines(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransaction":
		msg := &UpdateMoneyTransactionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateMoneyTransaction(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop":
		msg := &UpdateMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateMoneyTransactionShippingEtop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal":
		msg := &UpdateMoneyTransactionShippingExternalRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateMoneyTransactionShippingExternal(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	hooks   httprpc.Hooks
	builder func() NotificationService
}

func NewNotificationServiceServer(builder func() NotificationService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &NotificationServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const NotificationServicePathPrefix = "/admin.Notification/"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Notification/CreateNotifications":
		msg := &CreateNotificationsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateNotifications(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.Hooks
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/admin.Order/"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Order/GetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Order/GetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetOrders(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Order/GetOrdersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetOrdersByIDs(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentPriceServiceServer struct {
	hooks   httprpc.Hooks
	builder func() ShipmentPriceService
}

func NewShipmentPriceServiceServer(builder func() ShipmentPriceService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &ShipmentPriceServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const ShipmentPriceServicePathPrefix = "/admin.ShipmentPrice/"

func (s *ShipmentPriceServiceServer) PathPrefix() string {
	return ShipmentPriceServicePathPrefix
}

func (s *ShipmentPriceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *ShipmentPriceServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.ShipmentPrice/ActivateShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.ActivateShipmentPriceList(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPrice":
		msg := &CreateShipmentPriceRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateShipmentPrice(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPriceList":
		msg := &CreateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateShipmentPriceList(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentService":
		msg := &CreateShipmentServiceRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.CreateShipmentService(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteShipmentPrice(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteShipmentPriceList(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.DeleteShipmentService(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentPrice(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentPriceList(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceLists":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentPriceLists(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrices":
		msg := &GetShipmentPricesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentPrices(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentService(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentServices":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShipmentServices(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShippingServices":
		msg := &GetShippingServicesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShippingServices(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPrice":
		msg := &UpdateShipmentPriceRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentPrice(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPriceList":
		msg := &UpdateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentPriceList(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPricesPriorityPoint":
		msg := &UpdateShipmentPricesPriorityPointRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentPricesPriorityPoint(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentService":
		msg := &UpdateShipmentServiceRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentService(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesAvailableLocations":
		msg := &UpdateShipmentServicesAvailableLocationsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentServicesAvailableLocations(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesBlacklistLocations":
		msg := &UpdateShipmentServicesBlacklistLocationsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.UpdateShipmentServicesBlacklistLocations(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShopServiceServer struct {
	hooks   httprpc.Hooks
	builder func() ShopService
}

func NewShopServiceServer(builder func() ShopService, hooks ...*httprpc.Hooks) httprpc.Server {
	return &ShopServiceServer{
		hooks:   httprpc.WrapHooks(httprpc.ChainHooks(hooks...)),
		builder: builder,
	}
}

const ShopServicePathPrefix = "/admin.Shop/"

func (s *ShopServiceServer) PathPrefix() string {
	return ShopServicePathPrefix
}

func (s *ShopServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx, info := req.Context(), httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := s.hooks.BeforeRequest(ctx, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, s.hooks, info, err)
		return
	}
	serve(ctx, resp, req, s.hooks, info, reqMsg, exec)
}

func (s *ShopServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Shop/GetShop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShop(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Shop/GetShops":
		msg := &GetShopsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShops(ctx, msg)
		}
		return msg, fn, nil
	case "/admin.Shop/GetShopsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			inner := s.builder()
			ctx, err := s.hooks.BeforeServing(ctx, httprpc.HookInfo{Route: path, Request: msg}, inner)
			if err != nil {
				return nil, err
			}
			return inner.GetShopsByIDs(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
