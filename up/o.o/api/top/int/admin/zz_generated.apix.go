// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package admin

import (
	context "context"
	fmt "fmt"
	http "net/http"

	etelecomtypes "o.o/api/top/int/etelecom/types"
	shoptypes "o.o/api/top/int/shop/types"
	inttypes "o.o/api/top/int/types"
	common "o.o/api/top/types/common"
	capi "o.o/capi"
	httprpc "o.o/capi/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() AccountService:
		return NewAccountServiceServer(builder, hooks...), true
	case func() ConnectionService:
		return NewConnectionServiceServer(builder, hooks...), true
	case func() CreditService:
		return NewCreditServiceServer(builder, hooks...), true
	case func() EtelecomService:
		return NewEtelecomServiceServer(builder, hooks...), true
	case func() FulfillmentService:
		return NewFulfillmentServiceServer(builder, hooks...), true
	case func() InvoiceService:
		return NewInvoiceServiceServer(builder, hooks...), true
	case func() LocationService:
		return NewLocationServiceServer(builder, hooks...), true
	case func() MiscService:
		return NewMiscServiceServer(builder, hooks...), true
	case func() MoneyTransactionService:
		return NewMoneyTransactionServiceServer(builder, hooks...), true
	case func() NotificationService:
		return NewNotificationServiceServer(builder, hooks...), true
	case func() OrderService:
		return NewOrderServiceServer(builder, hooks...), true
	case func() ShipmentPriceService:
		return NewShipmentPriceServiceServer(builder, hooks...), true
	case func() ShopService:
		return NewShopServiceServer(builder, hooks...), true
	case func() SubscriptionService:
		return NewSubscriptionServiceServer(builder, hooks...), true
	case func() TicketService:
		return NewTicketServiceServer(builder, hooks...), true
	case func() UserService:
		return NewUserServiceServer(builder, hooks...), true
	default:
		return nil, false
	}
}

type AccountServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() AccountService
}

func NewAccountServiceServer(builder func() AccountService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &AccountServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const AccountServicePathPrefix = "/admin.Account/"

const Path_Account_CreateAdminUser = "/admin.Account/CreateAdminUser"
const Path_Account_CreatePartner = "/admin.Account/CreatePartner"
const Path_Account_DeleteAdminUser = "/admin.Account/DeleteAdminUser"
const Path_Account_GenerateAPIKey = "/admin.Account/GenerateAPIKey"
const Path_Account_GetAdminUsers = "/admin.Account/GetAdminUsers"
const Path_Account_UpdateAdminUser = "/admin.Account/UpdateAdminUser"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Account/CreateAdminUser":
		msg := &CreateAdminUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateAdminUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/CreatePartner":
		msg := &CreatePartnerRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreatePartner(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/DeleteAdminUser":
		msg := &DeleteAdminUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteAdminUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/GenerateAPIKey":
		msg := &GenerateAPIKeyRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GenerateAPIKey(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/GetAdminUsers":
		msg := &GetAdminUsersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetAdminUsers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Account/UpdateAdminUser":
		msg := &UpdateAdminUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateAdminUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ConnectionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ConnectionService
}

func NewConnectionServiceServer(builder func() ConnectionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ConnectionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ConnectionServicePathPrefix = "/admin.Connection/"

const Path_Connection_ConfirmConnection = "/admin.Connection/ConfirmConnection"
const Path_Connection_CreateBuiltinConnection = "/admin.Connection/CreateBuiltinConnection"
const Path_Connection_DisableConnection = "/admin.Connection/DisableConnection"
const Path_Connection_GetBuiltinShopConnections = "/admin.Connection/GetBuiltinShopConnections"
const Path_Connection_GetConnectionServices = "/admin.Connection/GetConnectionServices"
const Path_Connection_GetConnections = "/admin.Connection/GetConnections"
const Path_Connection_UpdateShopConnection = "/admin.Connection/UpdateShopConnection"

func (s *ConnectionServiceServer) PathPrefix() string {
	return ConnectionServicePathPrefix
}

func (s *ConnectionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ConnectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ConnectionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Connection/ConfirmConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/CreateBuiltinConnection":
		msg := &inttypes.CreateBuiltinConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateBuiltinConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/DisableConnection":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DisableConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetBuiltinShopConnections":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetBuiltinShopConnections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnectionServices":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnectionServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/GetConnections":
		msg := &inttypes.GetConnectionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetConnections(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Connection/UpdateShopConnection":
		msg := &inttypes.UpdateShopConnectionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShopConnection(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CreditServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() CreditService
}

func NewCreditServiceServer(builder func() CreditService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &CreditServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const CreditServicePathPrefix = "/admin.Credit/"

const Path_Credit_ConfirmCredit = "/admin.Credit/ConfirmCredit"
const Path_Credit_CreateCredit = "/admin.Credit/CreateCredit"
const Path_Credit_DeleteCredit = "/admin.Credit/DeleteCredit"
const Path_Credit_GetCredit = "/admin.Credit/GetCredit"
const Path_Credit_GetCredits = "/admin.Credit/GetCredits"

func (s *CreditServiceServer) PathPrefix() string {
	return CreditServicePathPrefix
}

func (s *CreditServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *CreditServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *CreditServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Credit/ConfirmCredit":
		msg := &ConfirmCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmCredit(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/CreateCredit":
		msg := &CreateCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCredit(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/DeleteCredit":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCredit(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredit":
		msg := &GetCreditRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCredit(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Credit/GetCredits":
		msg := &GetCreditsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCredits(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type EtelecomServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() EtelecomService
}

func NewEtelecomServiceServer(builder func() EtelecomService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &EtelecomServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const EtelecomServicePathPrefix = "/admin.Etelecom/"

const Path_Etelecom_CreateHotline = "/admin.Etelecom/CreateHotline"
const Path_Etelecom_UpdateHotline = "/admin.Etelecom/UpdateHotline"

func (s *EtelecomServiceServer) PathPrefix() string {
	return EtelecomServicePathPrefix
}

func (s *EtelecomServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *EtelecomServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *EtelecomServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Etelecom/CreateHotline":
		msg := &etelecomtypes.CreateHotlineRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateHotline(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Etelecom/UpdateHotline":
		msg := &etelecomtypes.UpdateHotlineRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateHotline(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() FulfillmentService
}

func NewFulfillmentServiceServer(builder func() FulfillmentService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &FulfillmentServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const FulfillmentServicePathPrefix = "/admin.Fulfillment/"

const Path_Fulfillment_AddShippingFee = "/admin.Fulfillment/AddShippingFee"
const Path_Fulfillment_GetFulfillment = "/admin.Fulfillment/GetFulfillment"
const Path_Fulfillment_GetFulfillments = "/admin.Fulfillment/GetFulfillments"
const Path_Fulfillment_UpdateFulfillmentCODAmount = "/admin.Fulfillment/UpdateFulfillmentCODAmount"
const Path_Fulfillment_UpdateFulfillmentInfo = "/admin.Fulfillment/UpdateFulfillmentInfo"
const Path_Fulfillment_UpdateFulfillmentShippingFees = "/admin.Fulfillment/UpdateFulfillmentShippingFees"
const Path_Fulfillment_UpdateFulfillmentShippingState = "/admin.Fulfillment/UpdateFulfillmentShippingState"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Fulfillment/AddShippingFee":
		msg := &AddShippingFeeRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AddShippingFee(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/GetFulfillment":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/GetFulfillments":
		msg := &GetFulfillmentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFulfillments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentCODAmount":
		msg := &UpdateFulfillmentCODAmountRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentCODAmount(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentInfo":
		msg := &UpdateFulfillmentInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingFees":
		msg := &UpdateFulfillmentShippingFeesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentShippingFees(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Fulfillment/UpdateFulfillmentShippingState":
		msg := &UpdateFulfillmentShippingStateRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFulfillmentShippingState(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InvoiceServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() InvoiceService
}

func NewInvoiceServiceServer(builder func() InvoiceService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &InvoiceServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const InvoiceServicePathPrefix = "/admin.Invoice/"

const Path_Invoice_CreateInvoice = "/admin.Invoice/CreateInvoice"
const Path_Invoice_DeleteInvoice = "/admin.Invoice/DeleteInvoice"
const Path_Invoice_GetInvoices = "/admin.Invoice/GetInvoices"
const Path_Invoice_ManualPaymentInvoice = "/admin.Invoice/ManualPaymentInvoice"

func (s *InvoiceServiceServer) PathPrefix() string {
	return InvoiceServicePathPrefix
}

func (s *InvoiceServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *InvoiceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *InvoiceServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Invoice/CreateInvoice":
		msg := &inttypes.CreateInvoiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateInvoice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Invoice/DeleteInvoice":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteInvoice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Invoice/GetInvoices":
		msg := &inttypes.GetInvoicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetInvoices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Invoice/ManualPaymentInvoice":
		msg := &inttypes.ManualPaymentInvoiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ManualPaymentInvoice(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LocationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() LocationService
}

func NewLocationServiceServer(builder func() LocationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &LocationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const LocationServicePathPrefix = "/admin.Location/"

const Path_Location_CreateCustomRegion = "/admin.Location/CreateCustomRegion"
const Path_Location_DeleteCustomRegion = "/admin.Location/DeleteCustomRegion"
const Path_Location_GetCustomRegion = "/admin.Location/GetCustomRegion"
const Path_Location_GetCustomRegions = "/admin.Location/GetCustomRegions"
const Path_Location_UpdateCustomRegion = "/admin.Location/UpdateCustomRegion"

func (s *LocationServiceServer) PathPrefix() string {
	return LocationServicePathPrefix
}

func (s *LocationServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *LocationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *LocationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Location/CreateCustomRegion":
		msg := &CreateCustomRegionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateCustomRegion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/DeleteCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteCustomRegion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomRegion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/GetCustomRegions":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetCustomRegions(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Location/UpdateCustomRegion":
		msg := &CustomRegion{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateCustomRegion(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MiscService
}

func NewMiscServiceServer(builder func() MiscService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MiscServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MiscServicePathPrefix = "/admin.Misc/"

const Path_Misc_AdminLoginAsAccount = "/admin.Misc/AdminLoginAsAccount"
const Path_Misc_VersionInfo = "/admin.Misc/VersionInfo"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Misc/AdminLoginAsAccount":
		msg := &LoginAsAccountRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AdminLoginAsAccount(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.VersionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() MoneyTransactionService
}

func NewMoneyTransactionServiceServer(builder func() MoneyTransactionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &MoneyTransactionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const MoneyTransactionServicePathPrefix = "/admin.MoneyTransaction/"

const Path_MoneyTransaction_ConfirmMoneyTransaction = "/admin.MoneyTransaction/ConfirmMoneyTransaction"
const Path_MoneyTransaction_ConfirmMoneyTransactionShippingEtop = "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
const Path_MoneyTransaction_ConfirmMoneyTransactionShippingExternals = "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
const Path_MoneyTransaction_CreateMoneyTransaction = "/admin.MoneyTransaction/CreateMoneyTransaction"
const Path_MoneyTransaction_CreateMoneyTransactionShippingEtop = "/admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
const Path_MoneyTransaction_DeleteMoneyTransactionShippingEtop = "/admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
const Path_MoneyTransaction_DeleteMoneyTransactionShippingExternal = "/admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
const Path_MoneyTransaction_GetMoneyTransaction = "/admin.MoneyTransaction/GetMoneyTransaction"
const Path_MoneyTransaction_GetMoneyTransactionShippingEtop = "/admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
const Path_MoneyTransaction_GetMoneyTransactionShippingEtops = "/admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
const Path_MoneyTransaction_GetMoneyTransactionShippingExternal = "/admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
const Path_MoneyTransaction_GetMoneyTransactionShippingExternals = "/admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
const Path_MoneyTransaction_GetMoneyTransactions = "/admin.MoneyTransaction/GetMoneyTransactions"
const Path_MoneyTransaction_RemoveMoneyTransactionShippingExternalLines = "/admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
const Path_MoneyTransaction_SplitMoneyTransactionShippingExternal = "/admin.MoneyTransaction/SplitMoneyTransactionShippingExternal"
const Path_MoneyTransaction_UpdateMoneyTransaction = "/admin.MoneyTransaction/UpdateMoneyTransaction"
const Path_MoneyTransaction_UpdateMoneyTransactionShippingEtop = "/admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
const Path_MoneyTransaction_UpdateMoneyTransactionShippingExternal = "/admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.MoneyTransaction/ConfirmMoneyTransaction":
		msg := &ConfirmMoneyTransactionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransaction(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop":
		msg := &ConfirmMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransactionShippingEtop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmMoneyTransactionShippingExternals(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/CreateMoneyTransaction":
		msg := &CreateMoneyTransactionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateMoneyTransaction(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/CreateMoneyTransactionShippingEtop":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateMoneyTransactionShippingEtop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteMoneyTransactionShippingEtop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteMoneyTransactionShippingExternal(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransaction":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransaction(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingEtop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingEtops":
		msg := &GetMoneyTransactionShippingEtopsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingEtops(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternal":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingExternal(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactionShippingExternals":
		msg := &GetMoneyTransactionShippingExternalsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactionShippingExternals(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/GetMoneyTransactions":
		msg := &GetMoneyTransactionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetMoneyTransactions(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines":
		msg := &RemoveMoneyTransactionShippingExternalLinesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.RemoveMoneyTransactionShippingExternalLines(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/SplitMoneyTransactionShippingExternal":
		msg := &SplitMoneyTxShippingExternalRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SplitMoneyTransactionShippingExternal(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransaction":
		msg := &UpdateMoneyTransactionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransaction(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop":
		msg := &UpdateMoneyTransactionShippingEtopRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransactionShippingEtop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal":
		msg := &UpdateMoneyTransactionShippingExternalRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateMoneyTransactionShippingExternal(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() NotificationService
}

func NewNotificationServiceServer(builder func() NotificationService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &NotificationServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const NotificationServicePathPrefix = "/admin.Notification/"

const Path_Notification_CreateNotifications = "/admin.Notification/CreateNotifications"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Notification/CreateNotifications":
		msg := &CreateNotificationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateNotifications(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() OrderService
}

func NewOrderServiceServer(builder func() OrderService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &OrderServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const OrderServicePathPrefix = "/admin.Order/"

const Path_Order_GetOrder = "/admin.Order/GetOrder"
const Path_Order_GetOrders = "/admin.Order/GetOrders"
const Path_Order_GetOrdersByIDs = "/admin.Order/GetOrdersByIDs"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Order/GetOrder":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrder(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Order/GetOrders":
		msg := &GetOrdersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrders(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Order/GetOrdersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetOrdersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipmentPriceServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShipmentPriceService
}

func NewShipmentPriceServiceServer(builder func() ShipmentPriceService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShipmentPriceServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShipmentPriceServicePathPrefix = "/admin.ShipmentPrice/"

const Path_ShipmentPrice_CreateShipmentPrice = "/admin.ShipmentPrice/CreateShipmentPrice"
const Path_ShipmentPrice_CreateShipmentPriceList = "/admin.ShipmentPrice/CreateShipmentPriceList"
const Path_ShipmentPrice_CreateShipmentPriceListPromotion = "/admin.ShipmentPrice/CreateShipmentPriceListPromotion"
const Path_ShipmentPrice_CreateShipmentService = "/admin.ShipmentPrice/CreateShipmentService"
const Path_ShipmentPrice_CreateShopShipmentPriceList = "/admin.ShipmentPrice/CreateShopShipmentPriceList"
const Path_ShipmentPrice_DeleteShipmentPrice = "/admin.ShipmentPrice/DeleteShipmentPrice"
const Path_ShipmentPrice_DeleteShipmentPriceList = "/admin.ShipmentPrice/DeleteShipmentPriceList"
const Path_ShipmentPrice_DeleteShipmentPriceListPromotion = "/admin.ShipmentPrice/DeleteShipmentPriceListPromotion"
const Path_ShipmentPrice_DeleteShipmentService = "/admin.ShipmentPrice/DeleteShipmentService"
const Path_ShipmentPrice_DeleteShopShipmentPriceList = "/admin.ShipmentPrice/DeleteShopShipmentPriceList"
const Path_ShipmentPrice_GetShipmentPrice = "/admin.ShipmentPrice/GetShipmentPrice"
const Path_ShipmentPrice_GetShipmentPriceList = "/admin.ShipmentPrice/GetShipmentPriceList"
const Path_ShipmentPrice_GetShipmentPriceListPromotion = "/admin.ShipmentPrice/GetShipmentPriceListPromotion"
const Path_ShipmentPrice_GetShipmentPriceListPromotions = "/admin.ShipmentPrice/GetShipmentPriceListPromotions"
const Path_ShipmentPrice_GetShipmentPriceLists = "/admin.ShipmentPrice/GetShipmentPriceLists"
const Path_ShipmentPrice_GetShipmentPrices = "/admin.ShipmentPrice/GetShipmentPrices"
const Path_ShipmentPrice_GetShipmentService = "/admin.ShipmentPrice/GetShipmentService"
const Path_ShipmentPrice_GetShipmentServices = "/admin.ShipmentPrice/GetShipmentServices"
const Path_ShipmentPrice_GetShippingServices = "/admin.ShipmentPrice/GetShippingServices"
const Path_ShipmentPrice_GetShopShipmentPriceList = "/admin.ShipmentPrice/GetShopShipmentPriceList"
const Path_ShipmentPrice_GetShopShipmentPriceLists = "/admin.ShipmentPrice/GetShopShipmentPriceLists"
const Path_ShipmentPrice_SetDefaultShipmentPriceList = "/admin.ShipmentPrice/SetDefaultShipmentPriceList"
const Path_ShipmentPrice_UpdateShipmentPrice = "/admin.ShipmentPrice/UpdateShipmentPrice"
const Path_ShipmentPrice_UpdateShipmentPriceList = "/admin.ShipmentPrice/UpdateShipmentPriceList"
const Path_ShipmentPrice_UpdateShipmentPriceListPromotion = "/admin.ShipmentPrice/UpdateShipmentPriceListPromotion"
const Path_ShipmentPrice_UpdateShipmentPricesPriorityPoint = "/admin.ShipmentPrice/UpdateShipmentPricesPriorityPoint"
const Path_ShipmentPrice_UpdateShipmentService = "/admin.ShipmentPrice/UpdateShipmentService"
const Path_ShipmentPrice_UpdateShipmentServicesAvailableLocations = "/admin.ShipmentPrice/UpdateShipmentServicesAvailableLocations"
const Path_ShipmentPrice_UpdateShipmentServicesBlacklistLocations = "/admin.ShipmentPrice/UpdateShipmentServicesBlacklistLocations"
const Path_ShipmentPrice_UpdateShopShipmentPriceList = "/admin.ShipmentPrice/UpdateShopShipmentPriceList"

func (s *ShipmentPriceServiceServer) PathPrefix() string {
	return ShipmentPriceServicePathPrefix
}

func (s *ShipmentPriceServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShipmentPriceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShipmentPriceServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.ShipmentPrice/CreateShipmentPrice":
		msg := &CreateShipmentPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentPrice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPriceList":
		msg := &CreateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentPriceListPromotion":
		msg := &CreateShipmentPriceListPromotionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentPriceListPromotion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShipmentService":
		msg := &CreateShipmentServiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShipmentService(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/CreateShopShipmentPriceList":
		msg := &CreateShopShipmentPriceList{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateShopShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentPrice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentPriceListPromotion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentPriceListPromotion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShipmentService(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/DeleteShopShipmentPriceList":
		msg := &GetShopShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteShopShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrice":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPrice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceList":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceListPromotion":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceListPromotion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceListPromotions":
		msg := &GetShipmentPriceListPromotionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceListPromotions(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPriceLists":
		msg := &GetShipmentPriceListsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPriceLists(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentPrices":
		msg := &GetShipmentPricesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentPrices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentService":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentService(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShipmentServices":
		msg := &GetShipmentServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShipmentServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShippingServices":
		msg := &GetShippingServicesRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShippingServices(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShopShipmentPriceList":
		msg := &GetShopShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/GetShopShipmentPriceLists":
		msg := &GetShopShipmentPriceListsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopShipmentPriceLists(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/SetDefaultShipmentPriceList":
		msg := &ActiveShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.SetDefaultShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPrice":
		msg := &UpdateShipmentPriceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPrice(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPriceList":
		msg := &UpdateShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPriceListPromotion":
		msg := &UpdateShipmentPriceListPromotionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPriceListPromotion(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentPricesPriorityPoint":
		msg := &UpdateShipmentPricesPriorityPointRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentPricesPriorityPoint(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentService":
		msg := &UpdateShipmentServiceRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentService(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesAvailableLocations":
		msg := &UpdateShipmentServicesAvailableLocationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentServicesAvailableLocations(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShipmentServicesBlacklistLocations":
		msg := &UpdateShipmentServicesBlacklistLocationsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShipmentServicesBlacklistLocations(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.ShipmentPrice/UpdateShopShipmentPriceList":
		msg := &UpdateShopShipmentPriceListRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShopShipmentPriceList(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShopServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() ShopService
}

func NewShopServiceServer(builder func() ShopService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &ShopServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const ShopServicePathPrefix = "/admin.Shop/"

const Path_Shop_GetShop = "/admin.Shop/GetShop"
const Path_Shop_GetShops = "/admin.Shop/GetShops"
const Path_Shop_GetShopsByIDs = "/admin.Shop/GetShopsByIDs"
const Path_Shop_UpdateShopInfo = "/admin.Shop/UpdateShopInfo"

func (s *ShopServiceServer) PathPrefix() string {
	return ShopServicePathPrefix
}

func (s *ShopServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *ShopServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *ShopServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Shop/GetShop":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShop(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Shop/GetShops":
		msg := &GetShopsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShops(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Shop/GetShopsByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetShopsByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Shop/UpdateShopInfo":
		msg := &UpdateShopInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateShopInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SubscriptionServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() SubscriptionService
}

func NewSubscriptionServiceServer(builder func() SubscriptionService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &SubscriptionServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const SubscriptionServicePathPrefix = "/admin.Subscription/"

const Path_Subscription_ActivateSubscription = "/admin.Subscription/ActivateSubscription"
const Path_Subscription_CancelSubscription = "/admin.Subscription/CancelSubscription"
const Path_Subscription_CreateSubscription = "/admin.Subscription/CreateSubscription"
const Path_Subscription_CreateSubscriptionPlan = "/admin.Subscription/CreateSubscriptionPlan"
const Path_Subscription_CreateSubscriptionProduct = "/admin.Subscription/CreateSubscriptionProduct"
const Path_Subscription_DeleteSubscription = "/admin.Subscription/DeleteSubscription"
const Path_Subscription_DeleteSubscriptionPlan = "/admin.Subscription/DeleteSubscriptionPlan"
const Path_Subscription_DeleteSubscriptionProduct = "/admin.Subscription/DeleteSubscriptionProduct"
const Path_Subscription_GetSubscription = "/admin.Subscription/GetSubscription"
const Path_Subscription_GetSubscriptionPlans = "/admin.Subscription/GetSubscriptionPlans"
const Path_Subscription_GetSubscriptionProducts = "/admin.Subscription/GetSubscriptionProducts"
const Path_Subscription_GetSubscriptions = "/admin.Subscription/GetSubscriptions"
const Path_Subscription_UpdateSubscriptionInfo = "/admin.Subscription/UpdateSubscriptionInfo"
const Path_Subscription_UpdateSubscriptionPlan = "/admin.Subscription/UpdateSubscriptionPlan"

func (s *SubscriptionServiceServer) PathPrefix() string {
	return SubscriptionServicePathPrefix
}

func (s *SubscriptionServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *SubscriptionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *SubscriptionServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Subscription/ActivateSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ActivateSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CancelSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CancelSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscription":
		msg := &inttypes.CreateSubscriptionRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscriptionPlan":
		msg := &inttypes.CreateSubrPlanRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscriptionPlan(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/CreateSubscriptionProduct":
		msg := &inttypes.CreateSubrProductRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateSubscriptionProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscriptionPlan":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscriptionPlan(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/DeleteSubscriptionProduct":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteSubscriptionProduct(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscription":
		msg := &inttypes.SubscriptionIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscription(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptionPlans":
		msg := &inttypes.GetSubrPlansRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptionPlans(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptionProducts":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptionProducts(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/GetSubscriptions":
		msg := &inttypes.GetSubscriptionsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetSubscriptions(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/UpdateSubscriptionInfo":
		msg := &inttypes.UpdateSubscriptionInfoRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSubscriptionInfo(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Subscription/UpdateSubscriptionPlan":
		msg := &inttypes.UpdateSubrPlanRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateSubscriptionPlan(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TicketServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() TicketService
}

func NewTicketServiceServer(builder func() TicketService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &TicketServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const TicketServicePathPrefix = "/admin.Ticket/"

const Path_Ticket_AssignTicket = "/admin.Ticket/AssignTicket"
const Path_Ticket_CloseTicket = "/admin.Ticket/CloseTicket"
const Path_Ticket_ConfirmTicket = "/admin.Ticket/ConfirmTicket"
const Path_Ticket_CreateTicket = "/admin.Ticket/CreateTicket"
const Path_Ticket_CreateTicketComment = "/admin.Ticket/CreateTicketComment"
const Path_Ticket_CreateTicketLabel = "/admin.Ticket/CreateTicketLabel"
const Path_Ticket_DeleteTicketComment = "/admin.Ticket/DeleteTicketComment"
const Path_Ticket_DeleteTicketLabel = "/admin.Ticket/DeleteTicketLabel"
const Path_Ticket_GetTicket = "/admin.Ticket/GetTicket"
const Path_Ticket_GetTicketComments = "/admin.Ticket/GetTicketComments"
const Path_Ticket_GetTicketLabels = "/admin.Ticket/GetTicketLabels"
const Path_Ticket_GetTickets = "/admin.Ticket/GetTickets"
const Path_Ticket_GetTicketsByRefTicketID = "/admin.Ticket/GetTicketsByRefTicketID"
const Path_Ticket_ReopenTicket = "/admin.Ticket/ReopenTicket"
const Path_Ticket_UnassignTicket = "/admin.Ticket/UnassignTicket"
const Path_Ticket_UpdateTicketComment = "/admin.Ticket/UpdateTicketComment"
const Path_Ticket_UpdateTicketLabel = "/admin.Ticket/UpdateTicketLabel"
const Path_Ticket_UpdateTicketRefTicketID = "/admin.Ticket/UpdateTicketRefTicketID"

func (s *TicketServiceServer) PathPrefix() string {
	return TicketServicePathPrefix
}

func (s *TicketServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *TicketServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *TicketServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.Ticket/AssignTicket":
		msg := &AssignTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.AssignTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/CloseTicket":
		msg := &CloseTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CloseTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/ConfirmTicket":
		msg := &ConfirmTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ConfirmTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/CreateTicket":
		msg := &CreateTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/CreateTicketComment":
		msg := &CreateTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/CreateTicketLabel":
		msg := &CreateTicketLabelRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateTicketLabel(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/DeleteTicketComment":
		msg := &DeleteTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/DeleteTicketLabel":
		msg := &DeleteTicketLabelRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.DeleteTicketLabel(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/GetTicket":
		msg := &GetTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/GetTicketComments":
		msg := &GetTicketCommentsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketComments(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/GetTicketLabels":
		msg := &GetTicketLabelsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketLabels(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/GetTickets":
		msg := &GetTicketsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTickets(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/GetTicketsByRefTicketID":
		msg := &shoptypes.GetTicketsByRefTicketIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetTicketsByRefTicketID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/ReopenTicket":
		msg := &ReopenTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.ReopenTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/UnassignTicket":
		msg := &AssignTicketRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UnassignTicket(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/UpdateTicketComment":
		msg := &UpdateTicketCommentRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateTicketComment(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/UpdateTicketLabel":
		msg := &UpdateTicketLabelRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateTicketLabel(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.Ticket/UpdateTicketRefTicketID":
		msg := &UpdateTicketRefTicketIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateTicketRefTicketID(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type UserServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() UserService
}

func NewUserServiceServer(builder func() UserService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &UserServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const UserServicePathPrefix = "/admin.User/"

const Path_User_BlockUser = "/admin.User/BlockUser"
const Path_User_GetUser = "/admin.User/GetUser"
const Path_User_GetUsers = "/admin.User/GetUsers"
const Path_User_GetUsersByIDs = "/admin.User/GetUsersByIDs"
const Path_User_UnblockUser = "/admin.User/UnblockUser"
const Path_User_UpdateUserRef = "/admin.User/UpdateUserRef"

func (s *UserServiceServer) PathPrefix() string {
	return UserServicePathPrefix
}

func (s *UserServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *UserServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *UserServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/admin.User/BlockUser":
		msg := &BlockUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.BlockUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.User/GetUser":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.User/GetUsers":
		msg := &GetUsersRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetUsers(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.User/GetUsersByIDs":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetUsersByIDs(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.User/UnblockUser":
		msg := &UnblockUserRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UnblockUser(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/admin.User/UpdateUserRef":
		msg := &UpdateUserRefRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp capi.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateUserRef(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
