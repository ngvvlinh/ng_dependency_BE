// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package etop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	common "etop.vn/api/top/types/common"
	capi "etop.vn/capi"
	httprpc "etop.vn/capi/httprpc"
)

type Server interface {
	http.Handler
	PathPrefix() string
}

type AccountRelationshipServiceServer struct {
	inner AccountRelationshipService
}

func NewAccountRelationshipServiceServer(svc AccountRelationshipService) Server {
	return &AccountRelationshipServiceServer{
		inner: svc,
	}
}

const AccountRelationshipServicePathPrefix = "/etop.AccountRelationship/"

func (s *AccountRelationshipServiceServer) PathPrefix() string {
	return AccountRelationshipServicePathPrefix
}

func (s *AccountRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *AccountRelationshipServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.AccountRelationship/CreateInvitation":
		msg := &CreateInvitationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateInvitation(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/DeleteInvitation":
		msg := &DeleteInvitationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteInvitation(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/GetInvitations":
		msg := &GetInvitationsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetInvitations(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/GetRelationships":
		msg := &GetRelationshipsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetRelationships(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/RemoveUser":
		msg := &RemoveUserRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.RemoveUser(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/UpdatePermission":
		msg := &UpdateAccountUserPermissionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdatePermission(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.AccountRelationship/UpdateRelationship":
		msg := &UpdateRelationshipRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateRelationship(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AccountServiceServer struct {
	inner AccountService
}

func NewAccountServiceServer(svc AccountService) Server {
	return &AccountServiceServer{
		inner: svc,
	}
}

const AccountServicePathPrefix = "/etop.Account/"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Account/GetPublicPartnerInfo":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetPublicPartnerInfo(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Account/GetPublicPartners":
		msg := &common.IDsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetPublicPartners(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Account/UpdateURLSlug":
		msg := &UpdateURLSlugRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateURLSlug(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AddressServiceServer struct {
	inner AddressService
}

func NewAddressServiceServer(svc AddressService) Server {
	return &AddressServiceServer{
		inner: svc,
	}
}

const AddressServicePathPrefix = "/etop.Address/"

func (s *AddressServiceServer) PathPrefix() string {
	return AddressServicePathPrefix
}

func (s *AddressServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *AddressServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Address/CreateAddress":
		msg := &CreateAddressRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Address/GetAddresses":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetAddresses(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Address/RemoveAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.RemoveAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Address/UpdateAddress":
		msg := &UpdateAddressRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateAddress(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type BankServiceServer struct {
	inner BankService
}

func NewBankServiceServer(svc BankService) Server {
	return &BankServiceServer{
		inner: svc,
	}
}

const BankServicePathPrefix = "/etop.Bank/"

func (s *BankServiceServer) PathPrefix() string {
	return BankServicePathPrefix
}

func (s *BankServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *BankServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Bank/GetBanks":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetBanks(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Bank/GetBranchesByBankProvince":
		msg := &GetBranchesByBankProvinceResquest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetBranchesByBankProvince(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Bank/GetProvincesByBank":
		msg := &GetProvincesByBankResquest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetProvincesByBank(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LocationServiceServer struct {
	inner LocationService
}

func NewLocationServiceServer(svc LocationService) Server {
	return &LocationServiceServer{
		inner: svc,
	}
}

const LocationServicePathPrefix = "/etop.Location/"

func (s *LocationServiceServer) PathPrefix() string {
	return LocationServicePathPrefix
}

func (s *LocationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *LocationServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Location/GetDistricts":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetDistricts(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Location/GetDistrictsByProvince":
		msg := &GetDistrictsByProvinceRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetDistrictsByProvince(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Location/GetProvinces":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetProvinces(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Location/GetWards":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetWards(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Location/GetWardsByDistrict":
		msg := &GetWardsByDistrictRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetWardsByDistrict(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Location/ParseLocation":
		msg := &ParseLocationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ParseLocation(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	inner MiscService
}

func NewMiscServiceServer(svc MiscService) Server {
	return &MiscServiceServer{
		inner: svc,
	}
}

const MiscServicePathPrefix = "/etop.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type RelationshipServiceServer struct {
	inner RelationshipService
}

func NewRelationshipServiceServer(svc RelationshipService) Server {
	return &RelationshipServiceServer{
		inner: svc,
	}
}

const RelationshipServicePathPrefix = "/etop.Relationship/"

func (s *RelationshipServiceServer) PathPrefix() string {
	return RelationshipServicePathPrefix
}

func (s *RelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *RelationshipServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Relationship/AnswerInvitation":
		msg := &AnswerInvitationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.AnswerInvitation(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Relationship/GetUsersInCurrentAccounts":
		msg := &GetUsersInCurrentAccountsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetUsersInCurrentAccounts(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Relationship/InviteUserToAccount":
		msg := &InviteUserToAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.InviteUserToAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Relationship/LeaveAccount":
		msg := &LeaveAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.LeaveAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Relationship/RemoveUserFromCurrentAccount":
		msg := &RemoveUserFromCurrentAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.RemoveUserFromCurrentAccount(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type UserRelationshipServiceServer struct {
	inner UserRelationshipService
}

func NewUserRelationshipServiceServer(svc UserRelationshipService) Server {
	return &UserRelationshipServiceServer{
		inner: svc,
	}
}

const UserRelationshipServicePathPrefix = "/etop.UserRelationship/"

func (s *UserRelationshipServiceServer) PathPrefix() string {
	return UserRelationshipServicePathPrefix
}

func (s *UserRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *UserRelationshipServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.UserRelationship/AcceptInvitation":
		msg := &AcceptInvitationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.AcceptInvitation(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.UserRelationship/GetInvitationByToken":
		msg := &GetInvitationByTokenRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetInvitationByToken(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.UserRelationship/GetInvitations":
		msg := &GetInvitationsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetInvitations(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.UserRelationship/LeaveAccount":
		msg := &UserRelationshipLeaveAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.LeaveAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.UserRelationship/RejectInvitation":
		msg := &RejectInvitationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.RejectInvitation(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type UserServiceServer struct {
	inner UserService
}

func NewUserServiceServer(svc UserService) Server {
	return &UserServiceServer{
		inner: svc,
	}
}

const UserServicePathPrefix = "/etop.User/"

func (s *UserServiceServer) PathPrefix() string {
	return UserServicePathPrefix
}

func (s *UserServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *UserServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.User/ChangePassword":
		msg := &ChangePasswordRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ChangePassword(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/ChangePasswordUsingToken":
		msg := &ChangePasswordUsingTokenRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ChangePasswordUsingToken(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/CheckUserRegistration":
		msg := &GetUserByPhoneRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CheckUserRegistration(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/InitSession":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.InitSession(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/Login":
		msg := &LoginRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.Login(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/Register":
		msg := &CreateUserRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.Register(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/RegisterUsingToken":
		msg := &CreateUserRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.RegisterUsingToken(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/ResetPassword":
		msg := &ResetPasswordRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ResetPassword(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/SendEmailVerification":
		msg := &SendEmailVerificationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.SendEmailVerification(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/SendPhoneVerification":
		msg := &SendPhoneVerificationRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.SendPhoneVerification(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/SendSTokenEmail":
		msg := &SendSTokenEmailRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.SendSTokenEmail(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/SessionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.SessionInfo(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/SwitchAccount":
		msg := &SwitchAccountRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.SwitchAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/UpdatePermission":
		msg := &UpdatePermissionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdatePermission(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/UpdateReferenceSale":
		msg := &UpdateReferenceSaleRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateReferenceSale(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/UpdateReferenceUser":
		msg := &UpdateReferenceUserRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateReferenceUser(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/UpgradeAccessToken":
		msg := &UpgradeAccessTokenRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpgradeAccessToken(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/VerifyEmailUsingToken":
		msg := &VerifyEmailUsingTokenRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.VerifyEmailUsingToken(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.User/VerifyPhoneUsingToken":
		msg := &VerifyPhoneUsingTokenRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.VerifyPhoneUsingToken(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
