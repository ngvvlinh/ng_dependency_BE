// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package shop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	externaltypes "etop.vn/api/top/external/types"
	common "etop.vn/api/top/types/common"
	capi "etop.vn/capi"
	httprpc "etop.vn/capi/httprpc"
)

type Server interface {
	http.Handler
	PathPrefix() string
}

type CustomerAddressServiceServer struct {
	inner CustomerAddressService
}

func NewCustomerAddressServiceServer(svc CustomerAddressService) Server {
	return &CustomerAddressServiceServer{
		inner: svc,
	}
}

const CustomerAddressServicePathPrefix = "/shop.CustomerAddress/"

func (s *CustomerAddressServiceServer) PathPrefix() string {
	return CustomerAddressServicePathPrefix
}

func (s *CustomerAddressServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerAddressServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerAddress/CreateAddress":
		msg := &externaltypes.CreateCustomerAddressRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/DeleteAddress":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/GetAddress":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/ListAddresses":
		msg := &externaltypes.ListCustomerAddressesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListAddresses(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerAddress/UpdateAddress":
		msg := &externaltypes.UpdateCustomerAddressRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateAddress(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupRelationshipServiceServer struct {
	inner CustomerGroupRelationshipService
}

func NewCustomerGroupRelationshipServiceServer(svc CustomerGroupRelationshipService) Server {
	return &CustomerGroupRelationshipServiceServer{
		inner: svc,
	}
}

const CustomerGroupRelationshipServicePathPrefix = "/shop.CustomerGroupRelationship/"

func (s *CustomerGroupRelationshipServiceServer) PathPrefix() string {
	return CustomerGroupRelationshipServicePathPrefix
}

func (s *CustomerGroupRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerGroupRelationshipServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroupRelationship/CreateRelationship":
		msg := &externaltypes.AddCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateRelationship(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroupRelationship/DeleteRelationship":
		msg := &externaltypes.RemoveCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteRelationship(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroupRelationship/ListRelationships":
		msg := &externaltypes.ListCustomerGroupRelationshipsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListRelationships(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupServiceServer struct {
	inner CustomerGroupService
}

func NewCustomerGroupServiceServer(svc CustomerGroupService) Server {
	return &CustomerGroupServiceServer{
		inner: svc,
	}
}

const CustomerGroupServicePathPrefix = "/shop.CustomerGroup/"

func (s *CustomerGroupServiceServer) PathPrefix() string {
	return CustomerGroupServicePathPrefix
}

func (s *CustomerGroupServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerGroupServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroup/CreateGroup":
		msg := &externaltypes.CreateCustomerGroupRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/DeleteGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetGroup":
		msg := &common.IDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/ListGroups":
		msg := &externaltypes.ListCustomerGroupsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListGroups(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/UpdateGroup":
		msg := &externaltypes.UpdateCustomerGroupRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateGroup(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerServiceServer struct {
	inner CustomerService
}

func NewCustomerServiceServer(svc CustomerService) Server {
	return &CustomerServiceServer{
		inner: svc,
	}
}

const CustomerServicePathPrefix = "/shop.Customer/"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Customer/CreateCustomer":
		msg := &externaltypes.CreateCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomer":
		msg := &externaltypes.DeleteCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomer":
		msg := &externaltypes.GetCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/ListCustomers":
		msg := &externaltypes.ListCustomersRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListCustomers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomer":
		msg := &externaltypes.UpdateCustomerRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateCustomer(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	inner FulfillmentService
}

func NewFulfillmentServiceServer(svc FulfillmentService) Server {
	return &FulfillmentServiceServer{
		inner: svc,
	}
}

const FulfillmentServicePathPrefix = "/shop.Fulfillment/"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Fulfillment/GetFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/ListFulfillments":
		msg := &externaltypes.ListFulfillmentsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListFulfillments(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	inner HistoryService
}

func NewHistoryServiceServer(svc HistoryService) Server {
	return &HistoryServiceServer{
		inner: svc,
	}
}

const HistoryServicePathPrefix = "/shop.History/"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.History/GetChanges":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetChanges(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InventoryServiceServer struct {
	inner InventoryService
}

func NewInventoryServiceServer(svc InventoryService) Server {
	return &InventoryServiceServer{
		inner: svc,
	}
}

const InventoryServicePathPrefix = "/shop.Inventory/"

func (s *InventoryServiceServer) PathPrefix() string {
	return InventoryServicePathPrefix
}

func (s *InventoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *InventoryServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Inventory/ListInventoryLevels":
		msg := &externaltypes.ListInventoryLevelsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListInventoryLevels(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	inner MiscService
}

func NewMiscServiceServer(svc MiscService) Server {
	return &MiscServiceServer{
		inner: svc,
	}
}

const MiscServicePathPrefix = "/shop.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Misc/CurrentAccount":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CurrentAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Misc/GetLocationList":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetLocationList(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	inner OrderService
}

func NewOrderServiceServer(svc OrderService) Server {
	return &OrderServiceServer{
		inner: svc,
	}
}

const OrderServicePathPrefix = "/shop.Order/"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Order/CancelOrder":
		msg := &externaltypes.CancelOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CancelOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrder":
		msg := &externaltypes.ConfirmOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ConfirmOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/CreateOrder":
		msg := &externaltypes.CreateOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/GetOrder":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/ListOrders":
		msg := &externaltypes.ListOrdersRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListOrders(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductCollectionRelationshipServiceServer struct {
	inner ProductCollectionRelationshipService
}

func NewProductCollectionRelationshipServiceServer(svc ProductCollectionRelationshipService) Server {
	return &ProductCollectionRelationshipServiceServer{
		inner: svc,
	}
}

const ProductCollectionRelationshipServicePathPrefix = "/shop.ProductCollectionRelationship/"

func (s *ProductCollectionRelationshipServiceServer) PathPrefix() string {
	return ProductCollectionRelationshipServicePathPrefix
}

func (s *ProductCollectionRelationshipServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductCollectionRelationshipServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductCollectionRelationship/CreateRelationship":
		msg := &externaltypes.CreateProductCollectionRelationshipRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateRelationship(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollectionRelationship/DeleteRelationship":
		msg := &externaltypes.RemoveProductCollectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteRelationship(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollectionRelationship/ListRelationships":
		msg := &externaltypes.ListProductCollectionRelationshipsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListRelationships(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductCollectionServiceServer struct {
	inner ProductCollectionService
}

func NewProductCollectionServiceServer(svc ProductCollectionService) Server {
	return &ProductCollectionServiceServer{
		inner: svc,
	}
}

const ProductCollectionServicePathPrefix = "/shop.ProductCollection/"

func (s *ProductCollectionServiceServer) PathPrefix() string {
	return ProductCollectionServicePathPrefix
}

func (s *ProductCollectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductCollectionServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductCollection/CreateCollection":
		msg := &externaltypes.CreateCollectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollection/DeleteCollection":
		msg := &externaltypes.GetCollectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollection/GetCollection":
		msg := &externaltypes.GetCollectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollection/ListCollections":
		msg := &externaltypes.ListCollectionsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListCollections(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductCollection/UpdateCollection":
		msg := &externaltypes.UpdateCollectionRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateCollection(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	inner ProductService
}

func NewProductServiceServer(svc ProductService) Server {
	return &ProductServiceServer{
		inner: svc,
	}
}

const ProductServicePathPrefix = "/shop.Product/"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Product/CreateProduct":
		msg := &externaltypes.CreateProductRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/DeleteProduct":
		msg := &externaltypes.GetProductRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetProduct":
		msg := &externaltypes.GetProductRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/ListProducts":
		msg := &externaltypes.ListProductsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListProducts(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProduct":
		msg := &externaltypes.UpdateProductRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateProduct(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShippingServiceServer struct {
	inner ShippingService
}

func NewShippingServiceServer(svc ShippingService) Server {
	return &ShippingServiceServer{
		inner: svc,
	}
}

const ShippingServicePathPrefix = "/shop.Shipping/"

func (s *ShippingServiceServer) PathPrefix() string {
	return ShippingServicePathPrefix
}

func (s *ShippingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ShippingServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Shipping/CancelOrder":
		msg := &externaltypes.CancelOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CancelOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Shipping/CreateAndConfirmOrder":
		msg := &externaltypes.CreateAndConfirmOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateAndConfirmOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Shipping/GetFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Shipping/GetOrder":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Shipping/GetShippingServices":
		msg := &externaltypes.GetShippingServicesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetShippingServices(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type VariantServiceServer struct {
	inner VariantService
}

func NewVariantServiceServer(svc VariantService) Server {
	return &VariantServiceServer{
		inner: svc,
	}
}

const VariantServicePathPrefix = "/shop.Variant/"

func (s *VariantServiceServer) PathPrefix() string {
	return VariantServicePathPrefix
}

func (s *VariantServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *VariantServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Variant/CreateVariant":
		msg := &externaltypes.CreateVariantRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Variant/DeleteVariant":
		msg := &externaltypes.GetVariantRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Variant/GetVariant":
		msg := &externaltypes.GetVariantRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Variant/ListVariants":
		msg := &externaltypes.ListVariantsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.ListVariants(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Variant/UpdateVariant":
		msg := &externaltypes.UpdateVariantRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.UpdateVariant(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type WebhookServiceServer struct {
	inner WebhookService
}

func NewWebhookServiceServer(svc WebhookService) Server {
	return &WebhookServiceServer{
		inner: svc,
	}
}

const WebhookServicePathPrefix = "/shop.Webhook/"

func (s *WebhookServiceServer) PathPrefix() string {
	return WebhookServicePathPrefix
}

func (s *WebhookServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *WebhookServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Webhook/CreateWebhook":
		msg := &externaltypes.CreateWebhookRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateWebhook(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Webhook/DeleteWebhook":
		msg := &externaltypes.DeleteWebhookRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteWebhook(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Webhook/GetWebhooks":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetWebhooks(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
