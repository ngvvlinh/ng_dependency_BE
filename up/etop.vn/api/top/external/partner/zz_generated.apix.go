// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package partner_proto

import (
	context "context"
	fmt "fmt"
	http "net/http"

	externaltypes "etop.vn/api/top/external/types"
	common "etop.vn/api/top/types/common"
	capi "etop.vn/capi"
	httprpc "etop.vn/capi/httprpc"
)

type Server interface {
	http.Handler
	PathPrefix() string
}

type CustomerServiceServer struct {
	inner CustomerService
}

func NewCustomerServiceServer(svc CustomerService) Server {
	return &CustomerServiceServer{
		inner: svc,
	}
}

const CustomerServicePathPrefix = "/partner.Customer/"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Customer/GetCustomers":
		msg := &externaltypes.GetCustomersRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetCustomers(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	inner HistoryService
}

func NewHistoryServiceServer(svc HistoryService) Server {
	return &HistoryServiceServer{
		inner: svc,
	}
}

const HistoryServicePathPrefix = "/partner.History/"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.History/GetChanges":
		msg := &externaltypes.GetChangesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetChanges(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	inner MiscService
}

func NewMiscServiceServer(svc MiscService) Server {
	return &MiscServiceServer{
		inner: svc,
	}
}

const MiscServicePathPrefix = "/partner.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Misc/CurrentAccount":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CurrentAccount(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Misc/GetLocationList":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetLocationList(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Misc/VersionInfo":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	inner ProductService
}

func NewProductServiceServer(svc ProductService) Server {
	return &ProductServiceServer{
		inner: svc,
	}
}

const ProductServicePathPrefix = "/partner.Product/"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Product/GetProducts":
		msg := &externaltypes.GetProductsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetProducts(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShippingServiceServer struct {
	inner ShippingService
}

func NewShippingServiceServer(svc ShippingService) Server {
	return &ShippingServiceServer{
		inner: svc,
	}
}

const ShippingServicePathPrefix = "/partner.Shipping/"

func (s *ShippingServiceServer) PathPrefix() string {
	return ShippingServicePathPrefix
}

func (s *ShippingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ShippingServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Shipping/CancelOrder":
		msg := &externaltypes.CancelOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CancelOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Shipping/CreateAndConfirmOrder":
		msg := &externaltypes.CreateOrderRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateAndConfirmOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Shipping/GetFulfillment":
		msg := &externaltypes.FulfillmentIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Shipping/GetOrder":
		msg := &externaltypes.OrderIDRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Shipping/GetShippingServices":
		msg := &externaltypes.GetShippingServicesRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetShippingServices(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShopServiceServer struct {
	inner ShopService
}

func NewShopServiceServer(svc ShopService) Server {
	return &ShopServiceServer{
		inner: svc,
	}
}

const ShopServicePathPrefix = "/partner.Shop/"

func (s *ShopServiceServer) PathPrefix() string {
	return ShopServicePathPrefix
}

func (s *ShopServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ShopServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Shop/AuthorizeShop":
		msg := &AuthorizeShopRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.AuthorizeShop(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Shop/CurrentShop":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CurrentShop(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type VariantServiceServer struct {
	inner VariantService
}

func NewVariantServiceServer(svc VariantService) Server {
	return &VariantServiceServer{
		inner: svc,
	}
}

const VariantServicePathPrefix = "/partner.Variant/"

func (s *VariantServiceServer) PathPrefix() string {
	return VariantServicePathPrefix
}

func (s *VariantServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *VariantServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Variant/GetVariants":
		msg := &externaltypes.GetVariantsRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetVariants(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type WebhookServiceServer struct {
	inner WebhookService
}

func NewWebhookServiceServer(svc WebhookService) Server {
	return &WebhookServiceServer{
		inner: svc,
	}
}

const WebhookServicePathPrefix = "/partner.Webhook/"

func (s *WebhookServiceServer) PathPrefix() string {
	return WebhookServicePathPrefix
}

func (s *WebhookServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *WebhookServiceServer) parseRoute(path string) (reqMsg capi.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/partner.Webhook/CreateWebhook":
		msg := &externaltypes.CreateWebhookRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.CreateWebhook(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Webhook/DeleteWebhook":
		msg := &externaltypes.DeleteWebhookRequest{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.DeleteWebhook(ctx, msg)
		}
		return msg, fn, nil
	case "/partner.Webhook/GetWebhooks":
		msg := &common.Empty{}
		fn := func(ctx context.Context) (capi.Message, error) {
			return s.inner.GetWebhooks(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
