// Code generated by goderive DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	"time"

	model "etop.vn/backend/com/main/address/model"
	"etop.vn/backend/pkg/common/sql/cmsql"
	sq "etop.vn/backend/pkg/common/sql/sq"
	core "etop.vn/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

// Type ExternalAccountAhamove represents table external_account_ahamove
func sqlgenExternalAccountAhamove(_ *ExternalAccountAhamove) bool { return true }

type ExternalAccountAhamoves []*ExternalAccountAhamove

const __sqlExternalAccountAhamove_Table = "external_account_ahamove"
const __sqlExternalAccountAhamove_ListCols = "\"id\",\"owner_id\",\"phone\",\"name\",\"external_id\",\"external_verified\",\"external_created_at\",\"external_token\",\"created_at\",\"updated_at\",\"last_send_verified_at\",\"external_ticket_id\",\"id_card_front_img\",\"id_card_back_img\",\"portrait_img\",\"website_url\",\"fanpage_url\",\"company_imgs\",\"business_license_imgs\",\"external_data_verified\",\"uploaded_at\""
const __sqlExternalAccountAhamove_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"phone\" = EXCLUDED.\"phone\",\"name\" = EXCLUDED.\"name\",\"external_id\" = EXCLUDED.\"external_id\",\"external_verified\" = EXCLUDED.\"external_verified\",\"external_created_at\" = EXCLUDED.\"external_created_at\",\"external_token\" = EXCLUDED.\"external_token\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"last_send_verified_at\" = EXCLUDED.\"last_send_verified_at\",\"external_ticket_id\" = EXCLUDED.\"external_ticket_id\",\"id_card_front_img\" = EXCLUDED.\"id_card_front_img\",\"id_card_back_img\" = EXCLUDED.\"id_card_back_img\",\"portrait_img\" = EXCLUDED.\"portrait_img\",\"website_url\" = EXCLUDED.\"website_url\",\"fanpage_url\" = EXCLUDED.\"fanpage_url\",\"company_imgs\" = EXCLUDED.\"company_imgs\",\"business_license_imgs\" = EXCLUDED.\"business_license_imgs\",\"external_data_verified\" = EXCLUDED.\"external_data_verified\",\"uploaded_at\" = EXCLUDED.\"uploaded_at\""
const __sqlExternalAccountAhamove_Insert = "INSERT INTO \"external_account_ahamove\" (" + __sqlExternalAccountAhamove_ListCols + ") VALUES"
const __sqlExternalAccountAhamove_Select = "SELECT " + __sqlExternalAccountAhamove_ListCols + " FROM \"external_account_ahamove\""
const __sqlExternalAccountAhamove_Select_history = "SELECT " + __sqlExternalAccountAhamove_ListCols + " FROM history.\"external_account_ahamove\""
const __sqlExternalAccountAhamove_UpdateAll = "UPDATE \"external_account_ahamove\" SET (" + __sqlExternalAccountAhamove_ListCols + ")"
const __sqlExternalAccountAhamove_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT external_account_ahamove_pkey DO UPDATE SET"

func (m *ExternalAccountAhamove) SQLTableName() string  { return "external_account_ahamove" }
func (m *ExternalAccountAhamoves) SQLTableName() string { return "external_account_ahamove" }
func (m *ExternalAccountAhamove) SQLListCols() string   { return __sqlExternalAccountAhamove_ListCols }

func (m *ExternalAccountAhamove) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlExternalAccountAhamove_ListCols + " FROM \"external_account_ahamove\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ExternalAccountAhamove)(nil))
}

func (m *ExternalAccountAhamove) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Phone),
		core.String(m.Name),
		core.String(m.ExternalID),
		core.Bool(m.ExternalVerified),
		core.Time(m.ExternalCreatedAt),
		core.String(m.ExternalToken),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.LastSendVerifiedAt),
		core.String(m.ExternalTicketID),
		core.String(m.IDCardFrontImg),
		core.String(m.IDCardBackImg),
		core.String(m.PortraitImg),
		core.String(m.WebsiteURL),
		core.String(m.FanpageURL),
		core.Array{m.CompanyImgs, opts},
		core.Array{m.BusinessLicenseImgs, opts},
		core.JSON{m.ExternalDataVerified},
		core.Time(m.UploadedAt),
	}
}

func (m *ExternalAccountAhamove) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Phone),
		(*core.String)(&m.Name),
		(*core.String)(&m.ExternalID),
		(*core.Bool)(&m.ExternalVerified),
		(*core.Time)(&m.ExternalCreatedAt),
		(*core.String)(&m.ExternalToken),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.LastSendVerifiedAt),
		(*core.String)(&m.ExternalTicketID),
		(*core.String)(&m.IDCardFrontImg),
		(*core.String)(&m.IDCardBackImg),
		(*core.String)(&m.PortraitImg),
		(*core.String)(&m.WebsiteURL),
		(*core.String)(&m.FanpageURL),
		core.Array{&m.CompanyImgs, opts},
		core.Array{&m.BusinessLicenseImgs, opts},
		core.JSON{&m.ExternalDataVerified},
		(*core.Time)(&m.UploadedAt),
	}
}

func (m *ExternalAccountAhamove) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ExternalAccountAhamoves) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ExternalAccountAhamoves, 0, 128)
	for rows.Next() {
		m := new(ExternalAccountAhamove)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ExternalAccountAhamove) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Select)
	return nil
}

func (_ *ExternalAccountAhamoves) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Select)
	return nil
}

func (m *ExternalAccountAhamove) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(21)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ExternalAccountAhamoves) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(21)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ExternalAccountAhamove) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlExternalAccountAhamove_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlExternalAccountAhamove_ListColsOnConflict)
	return nil
}

func (ms ExternalAccountAhamoves) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlExternalAccountAhamove_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlExternalAccountAhamove_ListColsOnConflict)
	return nil
}

func (m *ExternalAccountAhamove) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("external_account_ahamove")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.ExternalID != "" {
		flag = true
		w.WriteName("external_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalID)
	}
	if m.ExternalVerified {
		flag = true
		w.WriteName("external_verified")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalVerified)
	}
	if !m.ExternalCreatedAt.IsZero() {
		flag = true
		w.WriteName("external_created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalCreatedAt)
	}
	if m.ExternalToken != "" {
		flag = true
		w.WriteName("external_token")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalToken)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.LastSendVerifiedAt.IsZero() {
		flag = true
		w.WriteName("last_send_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.LastSendVerifiedAt)
	}
	if m.ExternalTicketID != "" {
		flag = true
		w.WriteName("external_ticket_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalTicketID)
	}
	if m.IDCardFrontImg != "" {
		flag = true
		w.WriteName("id_card_front_img")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IDCardFrontImg)
	}
	if m.IDCardBackImg != "" {
		flag = true
		w.WriteName("id_card_back_img")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IDCardBackImg)
	}
	if m.PortraitImg != "" {
		flag = true
		w.WriteName("portrait_img")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PortraitImg)
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.FanpageURL != "" {
		flag = true
		w.WriteName("fanpage_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FanpageURL)
	}
	if m.CompanyImgs != nil {
		flag = true
		w.WriteName("company_imgs")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.CompanyImgs, opts})
	}
	if m.BusinessLicenseImgs != nil {
		flag = true
		w.WriteName("business_license_imgs")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.BusinessLicenseImgs, opts})
	}
	if m.ExternalDataVerified != nil {
		flag = true
		w.WriteName("external_data_verified")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ExternalDataVerified})
	}
	if !m.UploadedAt.IsZero() {
		flag = true
		w.WriteName("uploaded_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UploadedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ExternalAccountAhamove) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(21)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ExternalAccountAhamoveHistory map[string]interface{}
type ExternalAccountAhamoveHistories []map[string]interface{}

func (m *ExternalAccountAhamoveHistory) SQLTableName() string {
	return "history.\"external_account_ahamove\""
}
func (m ExternalAccountAhamoveHistories) SQLTableName() string {
	return "history.\"external_account_ahamove\""
}

func (m *ExternalAccountAhamoveHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Select_history)
	return nil
}

func (m ExternalAccountAhamoveHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExternalAccountAhamove_Select_history)
	return nil
}

func (m ExternalAccountAhamoveHistory) ID() core.Interface      { return core.Interface{m["id"]} }
func (m ExternalAccountAhamoveHistory) OwnerID() core.Interface { return core.Interface{m["owner_id"]} }
func (m ExternalAccountAhamoveHistory) Phone() core.Interface   { return core.Interface{m["phone"]} }
func (m ExternalAccountAhamoveHistory) Name() core.Interface    { return core.Interface{m["name"]} }
func (m ExternalAccountAhamoveHistory) ExternalID() core.Interface {
	return core.Interface{m["external_id"]}
}
func (m ExternalAccountAhamoveHistory) ExternalVerified() core.Interface {
	return core.Interface{m["external_verified"]}
}
func (m ExternalAccountAhamoveHistory) ExternalCreatedAt() core.Interface {
	return core.Interface{m["external_created_at"]}
}
func (m ExternalAccountAhamoveHistory) ExternalToken() core.Interface {
	return core.Interface{m["external_token"]}
}
func (m ExternalAccountAhamoveHistory) CreatedAt() core.Interface {
	return core.Interface{m["created_at"]}
}
func (m ExternalAccountAhamoveHistory) UpdatedAt() core.Interface {
	return core.Interface{m["updated_at"]}
}
func (m ExternalAccountAhamoveHistory) LastSendVerifiedAt() core.Interface {
	return core.Interface{m["last_send_verified_at"]}
}
func (m ExternalAccountAhamoveHistory) ExternalTicketID() core.Interface {
	return core.Interface{m["external_ticket_id"]}
}
func (m ExternalAccountAhamoveHistory) IDCardFrontImg() core.Interface {
	return core.Interface{m["id_card_front_img"]}
}
func (m ExternalAccountAhamoveHistory) IDCardBackImg() core.Interface {
	return core.Interface{m["id_card_back_img"]}
}
func (m ExternalAccountAhamoveHistory) PortraitImg() core.Interface {
	return core.Interface{m["portrait_img"]}
}
func (m ExternalAccountAhamoveHistory) WebsiteURL() core.Interface {
	return core.Interface{m["website_url"]}
}
func (m ExternalAccountAhamoveHistory) FanpageURL() core.Interface {
	return core.Interface{m["fanpage_url"]}
}
func (m ExternalAccountAhamoveHistory) CompanyImgs() core.Interface {
	return core.Interface{m["company_imgs"]}
}
func (m ExternalAccountAhamoveHistory) BusinessLicenseImgs() core.Interface {
	return core.Interface{m["business_license_imgs"]}
}
func (m ExternalAccountAhamoveHistory) ExternalDataVerified() core.Interface {
	return core.Interface{m["external_data_verified"]}
}
func (m ExternalAccountAhamoveHistory) UploadedAt() core.Interface {
	return core.Interface{m["uploaded_at"]}
}

func (m *ExternalAccountAhamoveHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 21)
	args := make([]interface{}, 21)
	for i := 0; i < 21; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ExternalAccountAhamoveHistory, 21)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["phone"] = data[2]
	res["name"] = data[3]
	res["external_id"] = data[4]
	res["external_verified"] = data[5]
	res["external_created_at"] = data[6]
	res["external_token"] = data[7]
	res["created_at"] = data[8]
	res["updated_at"] = data[9]
	res["last_send_verified_at"] = data[10]
	res["external_ticket_id"] = data[11]
	res["id_card_front_img"] = data[12]
	res["id_card_back_img"] = data[13]
	res["portrait_img"] = data[14]
	res["website_url"] = data[15]
	res["fanpage_url"] = data[16]
	res["company_imgs"] = data[17]
	res["business_license_imgs"] = data[18]
	res["external_data_verified"] = data[19]
	res["uploaded_at"] = data[20]
	*m = res
	return nil
}

func (ms *ExternalAccountAhamoveHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 21)
	args := make([]interface{}, 21)
	for i := 0; i < 21; i++ {
		args[i] = &data[i]
	}
	res := make(ExternalAccountAhamoveHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ExternalAccountAhamoveHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["phone"] = data[2]
		m["name"] = data[3]
		m["external_id"] = data[4]
		m["external_verified"] = data[5]
		m["external_created_at"] = data[6]
		m["external_token"] = data[7]
		m["created_at"] = data[8]
		m["updated_at"] = data[9]
		m["last_send_verified_at"] = data[10]
		m["external_ticket_id"] = data[11]
		m["id_card_front_img"] = data[12]
		m["id_card_back_img"] = data[13]
		m["portrait_img"] = data[14]
		m["website_url"] = data[15]
		m["fanpage_url"] = data[16]
		m["company_imgs"] = data[17]
		m["business_license_imgs"] = data[18]
		m["external_data_verified"] = data[19]
		m["uploaded_at"] = data[20]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Affiliate represents table affiliate
func sqlgenSale(_ *Affiliate) bool { return true }

type Affiliates []*Affiliate

const __sqlAffiliate_Table = "affiliate"
const __sqlAffiliate_ListCols = "\"id\",\"owner_id\",\"name\",\"phone\",\"email\",\"is_test\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"bank_account\""
const __sqlAffiliate_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"name\" = EXCLUDED.\"name\",\"phone\" = EXCLUDED.\"phone\",\"email\" = EXCLUDED.\"email\",\"is_test\" = EXCLUDED.\"is_test\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"bank_account\" = EXCLUDED.\"bank_account\""
const __sqlAffiliate_Insert = "INSERT INTO \"affiliate\" (" + __sqlAffiliate_ListCols + ") VALUES"
const __sqlAffiliate_Select = "SELECT " + __sqlAffiliate_ListCols + " FROM \"affiliate\""
const __sqlAffiliate_Select_history = "SELECT " + __sqlAffiliate_ListCols + " FROM history.\"affiliate\""
const __sqlAffiliate_UpdateAll = "UPDATE \"affiliate\" SET (" + __sqlAffiliate_ListCols + ")"
const __sqlAffiliate_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT affiliate_pkey DO UPDATE SET"

func (m *Affiliate) SQLTableName() string  { return "affiliate" }
func (m *Affiliates) SQLTableName() string { return "affiliate" }
func (m *Affiliate) SQLListCols() string   { return __sqlAffiliate_ListCols }

func (m *Affiliate) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAffiliate_ListCols + " FROM \"affiliate\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Affiliate)(nil))
}

func (m *Affiliate) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Name),
		core.String(m.Phone),
		core.String(m.Email),
		core.Int(m.IsTest),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.JSON{m.BankAccount},
	}
}

func (m *Affiliate) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Name),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Email),
		(*core.Int)(&m.IsTest),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.JSON{&m.BankAccount},
	}
}

func (m *Affiliate) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Affiliates) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Affiliates, 0, 128)
	for rows.Next() {
		m := new(Affiliate)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Affiliate) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select)
	return nil
}

func (_ *Affiliates) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select)
	return nil
}

func (m *Affiliate) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Affiliates) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(11)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Affiliate) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAffiliate_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAffiliate_ListColsOnConflict)
	return nil
}

func (ms Affiliates) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAffiliate_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAffiliate_ListColsOnConflict)
	return nil
}

func (m *Affiliate) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("affiliate")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.BankAccount != nil {
		flag = true
		w.WriteName("bank_account")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.BankAccount})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Affiliate) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AffiliateHistory map[string]interface{}
type AffiliateHistories []map[string]interface{}

func (m *AffiliateHistory) SQLTableName() string  { return "history.\"affiliate\"" }
func (m AffiliateHistories) SQLTableName() string { return "history.\"affiliate\"" }

func (m *AffiliateHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select_history)
	return nil
}

func (m AffiliateHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select_history)
	return nil
}

func (m AffiliateHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m AffiliateHistory) OwnerID() core.Interface     { return core.Interface{m["owner_id"]} }
func (m AffiliateHistory) Name() core.Interface        { return core.Interface{m["name"]} }
func (m AffiliateHistory) Phone() core.Interface       { return core.Interface{m["phone"]} }
func (m AffiliateHistory) Email() core.Interface       { return core.Interface{m["email"]} }
func (m AffiliateHistory) IsTest() core.Interface      { return core.Interface{m["is_test"]} }
func (m AffiliateHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m AffiliateHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AffiliateHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AffiliateHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m AffiliateHistory) BankAccount() core.Interface { return core.Interface{m["bank_account"]} }

func (m *AffiliateHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AffiliateHistory, 11)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["name"] = data[2]
	res["phone"] = data[3]
	res["email"] = data[4]
	res["is_test"] = data[5]
	res["status"] = data[6]
	res["created_at"] = data[7]
	res["updated_at"] = data[8]
	res["deleted_at"] = data[9]
	res["bank_account"] = data[10]
	*m = res
	return nil
}

func (ms *AffiliateHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	res := make(AffiliateHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AffiliateHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["name"] = data[2]
		m["phone"] = data[3]
		m["email"] = data[4]
		m["is_test"] = data[5]
		m["status"] = data[6]
		m["created_at"] = data[7]
		m["updated_at"] = data[8]
		m["deleted_at"] = data[9]
		m["bank_account"] = data[10]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Account represents table account
func sqlgenAccount(_ *Account) bool { return true }

type Accounts []*Account

const __sqlAccount_Table = "account"
const __sqlAccount_ListCols = "\"id\",\"owner_id\",\"name\",\"type\",\"image_url\",\"url_slug\""
const __sqlAccount_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"name\" = EXCLUDED.\"name\",\"type\" = EXCLUDED.\"type\",\"image_url\" = EXCLUDED.\"image_url\",\"url_slug\" = EXCLUDED.\"url_slug\""
const __sqlAccount_Insert = "INSERT INTO \"account\" (" + __sqlAccount_ListCols + ") VALUES"
const __sqlAccount_Select = "SELECT " + __sqlAccount_ListCols + " FROM \"account\""
const __sqlAccount_Select_history = "SELECT " + __sqlAccount_ListCols + " FROM history.\"account\""
const __sqlAccount_UpdateAll = "UPDATE \"account\" SET (" + __sqlAccount_ListCols + ")"
const __sqlAccount_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_pkey DO UPDATE SET"

func (m *Account) SQLTableName() string  { return "account" }
func (m *Accounts) SQLTableName() string { return "account" }
func (m *Account) SQLListCols() string   { return __sqlAccount_ListCols }

func (m *Account) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccount_ListCols + " FROM \"account\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Account)(nil))
}

func (m *Account) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Name),
		m.Type,
		core.String(m.ImageURL),
		core.String(m.URLSlug),
	}
}

func (m *Account) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Name),
		&m.Type,
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.URLSlug),
	}
}

func (m *Account) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Accounts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Accounts, 0, 128)
	for rows.Next() {
		m := new(Account)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Account) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (_ *Accounts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (m *Account) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Accounts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(6)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Account) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccount_ListColsOnConflict)
	return nil
}

func (ms Accounts) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccount_ListColsOnConflict)
	return nil
}

func (m *Account) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Type != 0 {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.URLSlug != "" {
		flag = true
		w.WriteName("url_slug")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.URLSlug)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Account) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountHistory map[string]interface{}
type AccountHistories []map[string]interface{}

func (m *AccountHistory) SQLTableName() string  { return "history.\"account\"" }
func (m AccountHistories) SQLTableName() string { return "history.\"account\"" }

func (m *AccountHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m AccountHistory) OwnerID() core.Interface  { return core.Interface{m["owner_id"]} }
func (m AccountHistory) Name() core.Interface     { return core.Interface{m["name"]} }
func (m AccountHistory) Type() core.Interface     { return core.Interface{m["type"]} }
func (m AccountHistory) ImageURL() core.Interface { return core.Interface{m["image_url"]} }
func (m AccountHistory) URLSlug() core.Interface  { return core.Interface{m["url_slug"]} }

func (m *AccountHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountHistory, 6)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["name"] = data[2]
	res["type"] = data[3]
	res["image_url"] = data[4]
	res["url_slug"] = data[5]
	*m = res
	return nil
}

func (ms *AccountHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	res := make(AccountHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["name"] = data[2]
		m["type"] = data[3]
		m["image_url"] = data[4]
		m["url_slug"] = data[5]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Shop represents table shop
func sqlgenShop(_ *Shop) bool { return true }

type Shops []*Shop

const __sqlShop_Table = "shop"
const __sqlShop_ListCols = "\"id\",\"name\",\"owner_id\",\"is_test\",\"address_id\",\"ship_to_address_id\",\"ship_from_address_id\",\"phone\",\"bank_account\",\"website_url\",\"image_url\",\"email\",\"code\",\"auto_create_ffm\",\"order_source_id\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"recognized_hosts\",\"ghn_note_code\",\"try_on\",\"company_info\",\"money_transaction_rrule\",\"survey_info\",\"shipping_service_select_strategy\",\"inventory_overstock\""
const __sqlShop_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"name\" = EXCLUDED.\"name\",\"owner_id\" = EXCLUDED.\"owner_id\",\"is_test\" = EXCLUDED.\"is_test\",\"address_id\" = EXCLUDED.\"address_id\",\"ship_to_address_id\" = EXCLUDED.\"ship_to_address_id\",\"ship_from_address_id\" = EXCLUDED.\"ship_from_address_id\",\"phone\" = EXCLUDED.\"phone\",\"bank_account\" = EXCLUDED.\"bank_account\",\"website_url\" = EXCLUDED.\"website_url\",\"image_url\" = EXCLUDED.\"image_url\",\"email\" = EXCLUDED.\"email\",\"code\" = EXCLUDED.\"code\",\"auto_create_ffm\" = EXCLUDED.\"auto_create_ffm\",\"order_source_id\" = EXCLUDED.\"order_source_id\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"recognized_hosts\" = EXCLUDED.\"recognized_hosts\",\"ghn_note_code\" = EXCLUDED.\"ghn_note_code\",\"try_on\" = EXCLUDED.\"try_on\",\"company_info\" = EXCLUDED.\"company_info\",\"money_transaction_rrule\" = EXCLUDED.\"money_transaction_rrule\",\"survey_info\" = EXCLUDED.\"survey_info\",\"shipping_service_select_strategy\" = EXCLUDED.\"shipping_service_select_strategy\",\"inventory_overstock\" = EXCLUDED.\"inventory_overstock\""
const __sqlShop_Insert = "INSERT INTO \"shop\" (" + __sqlShop_ListCols + ") VALUES"
const __sqlShop_Select = "SELECT " + __sqlShop_ListCols + " FROM \"shop\""
const __sqlShop_Select_history = "SELECT " + __sqlShop_ListCols + " FROM history.\"shop\""
const __sqlShop_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShop_ListCols + ")"
const __sqlShop_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shop_pkey DO UPDATE SET"

func (m *Shop) SQLTableName() string  { return "shop" }
func (m *Shops) SQLTableName() string { return "shop" }
func (m *Shop) SQLListCols() string   { return __sqlShop_ListCols }

func (m *Shop) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShop_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Shop)(nil))
}

func (m *Shop) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Name),
		m.OwnerID,
		core.Int(m.IsTest),
		m.AddressID,
		m.ShipToAddressID,
		m.ShipFromAddressID,
		core.String(m.Phone),
		core.JSON{m.BankAccount},
		core.String(m.WebsiteURL),
		core.String(m.ImageURL),
		core.String(m.Email),
		core.String(m.Code),
		core.Bool(m.AutoCreateFFM),
		m.OrderSourceID,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.RecognizedHosts, opts},
		m.GhnNoteCode,
		m.TryOn,
		core.JSON{m.CompanyInfo},
		core.String(m.MoneyTransactionRRule),
		core.JSON{m.SurveyInfo},
		core.JSON{m.ShippingServiceSelectStrategy},
		m.InventoryOverstock,
	}
}

func (m *Shop) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		&m.OwnerID,
		(*core.Int)(&m.IsTest),
		&m.AddressID,
		&m.ShipToAddressID,
		&m.ShipFromAddressID,
		(*core.String)(&m.Phone),
		core.JSON{&m.BankAccount},
		(*core.String)(&m.WebsiteURL),
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.Email),
		(*core.String)(&m.Code),
		(*core.Bool)(&m.AutoCreateFFM),
		&m.OrderSourceID,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.RecognizedHosts, opts},
		&m.GhnNoteCode,
		&m.TryOn,
		core.JSON{&m.CompanyInfo},
		(*core.String)(&m.MoneyTransactionRRule),
		core.JSON{&m.SurveyInfo},
		core.JSON{&m.ShippingServiceSelectStrategy},
		&m.InventoryOverstock,
	}
}

func (m *Shop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Shops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Shops, 0, 128)
	for rows.Next() {
		m := new(Shop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Shop) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (_ *Shops) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (m *Shop) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(27)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Shops) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(27)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Shop) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShop_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShop_ListColsOnConflict)
	return nil
}

func (ms Shops) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShop_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShop_ListColsOnConflict)
	return nil
}

func (m *Shop) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.AddressID != 0 {
		flag = true
		w.WriteName("address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AddressID)
	}
	if m.ShipToAddressID != 0 {
		flag = true
		w.WriteName("ship_to_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipToAddressID)
	}
	if m.ShipFromAddressID != 0 {
		flag = true
		w.WriteName("ship_from_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipFromAddressID)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.BankAccount != nil {
		flag = true
		w.WriteName("bank_account")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.BankAccount})
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.AutoCreateFFM {
		flag = true
		w.WriteName("auto_create_ffm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AutoCreateFFM)
	}
	if m.OrderSourceID != 0 {
		flag = true
		w.WriteName("order_source_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OrderSourceID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.GhnNoteCode != 0 {
		flag = true
		w.WriteName("ghn_note_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.GhnNoteCode)
	}
	if m.TryOn != 0 {
		flag = true
		w.WriteName("try_on")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TryOn)
	}
	if m.CompanyInfo != nil {
		flag = true
		w.WriteName("company_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.CompanyInfo})
	}
	if m.MoneyTransactionRRule != "" {
		flag = true
		w.WriteName("money_transaction_rrule")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.MoneyTransactionRRule)
	}
	if m.SurveyInfo != nil {
		flag = true
		w.WriteName("survey_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.SurveyInfo})
	}
	if m.ShippingServiceSelectStrategy != nil {
		flag = true
		w.WriteName("shipping_service_select_strategy")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ShippingServiceSelectStrategy})
	}
	if m.InventoryOverstock.Valid {
		flag = true
		w.WriteName("inventory_overstock")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InventoryOverstock)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Shop) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(27)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopHistory map[string]interface{}
type ShopHistories []map[string]interface{}

func (m *ShopHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistory) ID() core.Interface              { return core.Interface{m["id"]} }
func (m ShopHistory) Name() core.Interface            { return core.Interface{m["name"]} }
func (m ShopHistory) OwnerID() core.Interface         { return core.Interface{m["owner_id"]} }
func (m ShopHistory) IsTest() core.Interface          { return core.Interface{m["is_test"]} }
func (m ShopHistory) AddressID() core.Interface       { return core.Interface{m["address_id"]} }
func (m ShopHistory) ShipToAddressID() core.Interface { return core.Interface{m["ship_to_address_id"]} }
func (m ShopHistory) ShipFromAddressID() core.Interface {
	return core.Interface{m["ship_from_address_id"]}
}
func (m ShopHistory) Phone() core.Interface           { return core.Interface{m["phone"]} }
func (m ShopHistory) BankAccount() core.Interface     { return core.Interface{m["bank_account"]} }
func (m ShopHistory) WebsiteURL() core.Interface      { return core.Interface{m["website_url"]} }
func (m ShopHistory) ImageURL() core.Interface        { return core.Interface{m["image_url"]} }
func (m ShopHistory) Email() core.Interface           { return core.Interface{m["email"]} }
func (m ShopHistory) Code() core.Interface            { return core.Interface{m["code"]} }
func (m ShopHistory) AutoCreateFFM() core.Interface   { return core.Interface{m["auto_create_ffm"]} }
func (m ShopHistory) OrderSourceID() core.Interface   { return core.Interface{m["order_source_id"]} }
func (m ShopHistory) Status() core.Interface          { return core.Interface{m["status"]} }
func (m ShopHistory) CreatedAt() core.Interface       { return core.Interface{m["created_at"]} }
func (m ShopHistory) UpdatedAt() core.Interface       { return core.Interface{m["updated_at"]} }
func (m ShopHistory) DeletedAt() core.Interface       { return core.Interface{m["deleted_at"]} }
func (m ShopHistory) RecognizedHosts() core.Interface { return core.Interface{m["recognized_hosts"]} }
func (m ShopHistory) GhnNoteCode() core.Interface     { return core.Interface{m["ghn_note_code"]} }
func (m ShopHistory) TryOn() core.Interface           { return core.Interface{m["try_on"]} }
func (m ShopHistory) CompanyInfo() core.Interface     { return core.Interface{m["company_info"]} }
func (m ShopHistory) MoneyTransactionRRule() core.Interface {
	return core.Interface{m["money_transaction_rrule"]}
}
func (m ShopHistory) SurveyInfo() core.Interface { return core.Interface{m["survey_info"]} }
func (m ShopHistory) ShippingServiceSelectStrategy() core.Interface {
	return core.Interface{m["shipping_service_select_strategy"]}
}
func (m ShopHistory) InventoryOverstock() core.Interface {
	return core.Interface{m["inventory_overstock"]}
}

func (m *ShopHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 27)
	args := make([]interface{}, 27)
	for i := 0; i < 27; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopHistory, 27)
	res["id"] = data[0]
	res["name"] = data[1]
	res["owner_id"] = data[2]
	res["is_test"] = data[3]
	res["address_id"] = data[4]
	res["ship_to_address_id"] = data[5]
	res["ship_from_address_id"] = data[6]
	res["phone"] = data[7]
	res["bank_account"] = data[8]
	res["website_url"] = data[9]
	res["image_url"] = data[10]
	res["email"] = data[11]
	res["code"] = data[12]
	res["auto_create_ffm"] = data[13]
	res["order_source_id"] = data[14]
	res["status"] = data[15]
	res["created_at"] = data[16]
	res["updated_at"] = data[17]
	res["deleted_at"] = data[18]
	res["recognized_hosts"] = data[19]
	res["ghn_note_code"] = data[20]
	res["try_on"] = data[21]
	res["company_info"] = data[22]
	res["money_transaction_rrule"] = data[23]
	res["survey_info"] = data[24]
	res["shipping_service_select_strategy"] = data[25]
	res["inventory_overstock"] = data[26]
	*m = res
	return nil
}

func (ms *ShopHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 27)
	args := make([]interface{}, 27)
	for i := 0; i < 27; i++ {
		args[i] = &data[i]
	}
	res := make(ShopHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["owner_id"] = data[2]
		m["is_test"] = data[3]
		m["address_id"] = data[4]
		m["ship_to_address_id"] = data[5]
		m["ship_from_address_id"] = data[6]
		m["phone"] = data[7]
		m["bank_account"] = data[8]
		m["website_url"] = data[9]
		m["image_url"] = data[10]
		m["email"] = data[11]
		m["code"] = data[12]
		m["auto_create_ffm"] = data[13]
		m["order_source_id"] = data[14]
		m["status"] = data[15]
		m["created_at"] = data[16]
		m["updated_at"] = data[17]
		m["deleted_at"] = data[18]
		m["recognized_hosts"] = data[19]
		m["ghn_note_code"] = data[20]
		m["try_on"] = data[21]
		m["company_info"] = data[22]
		m["money_transaction_rrule"] = data[23]
		m["survey_info"] = data[24]
		m["shipping_service_select_strategy"] = data[25]
		m["inventory_overstock"] = data[26]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type ShopExtended represents a join
func sqlgenShopExtended(_ *ShopExtended, _ *Shop, as sq.AS, t0 sq.JOIN_TYPE, _ *model.Address, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlShopExtended_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlShopExtended_As = as
	__sqlShopExtended_JoinAs = []sq.AS{a0, a1}
	__sqlShopExtended_JoinConds = []string{c0, c1}
	return true
}

type ShopExtendeds []*ShopExtended

var __sqlShopExtended_JoinTypes []sq.JOIN_TYPE
var __sqlShopExtended_As sq.AS
var __sqlShopExtended_JoinAs []sq.AS
var __sqlShopExtended_JoinConds []string

func (m *ShopExtended) SQLTableName() string  { return "shop" }
func (m *ShopExtendeds) SQLTableName() string { return "shop" }

func (m *ShopExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopExtendeds, 0, 128)
	for rows.Next() {
		m := new(ShopExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *ShopExtended) SQLSelect(w SQLWriter) error {
	(*ShopExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*ShopExtended)(nil).__sqlJoin(w, __sqlShopExtended_JoinTypes)
	return nil
}

func (m *ShopExtendeds) SQLSelect(w SQLWriter) error {
	return (*ShopExtended)(nil).SQLSelect(w)
}

func (m *ShopExtended) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlShopExtended_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *ShopExtendeds) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*ShopExtended)(nil).SQLJoin(w, types)
}

func (m *ShopExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlShopExtended_As), (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlShopExtended_JoinAs[0]), (*model.Address)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlShopExtended_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *ShopExtended) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("shop")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*model.Address)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlShopExtended_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlShopExtended_JoinConds[1])
}

func (m *ShopExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.Address = new(model.Address)
	args = append(args, m.Address.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// *ShopDelete is a substruct of *Shop
func substructShopDelete(_ *ShopDelete, _ *Shop) bool { return true }

func ShopDeletesFromShops(ps []*Shop) []*ShopDelete {
	ss := make([]*ShopDelete, len(ps))
	for i, p := range ps {
		ss[i] = NewShopDeleteFromShop(p)
	}
	return ss
}

func ShopDeletesToShops(ss []*ShopDelete) []*Shop {
	ps := make([]*Shop, len(ss))
	for i, s := range ss {
		ps[i] = s.ToShop()
	}
	return ps
}

func NewShopDeleteFromShop(sp *Shop) *ShopDelete {
	if sp == nil {
		return nil
	}
	s := new(ShopDelete)
	s.CopyFrom(sp)
	return s
}

func (s *ShopDelete) ToShop() *Shop {
	if s == nil {
		return nil
	}
	sp := new(Shop)
	s.AssignTo(sp)
	return sp
}

func (s *ShopDelete) CopyFrom(sp *Shop) {
	s.DeletedAt = sp.DeletedAt
}

func (s *ShopDelete) AssignTo(sp *Shop) {
	sp.DeletedAt = s.DeletedAt
}

// Type ShopDelete represents table shop
func sqlgenShopDelete(_ *ShopDelete, _ *Shop) bool { return true }

type ShopDeletes []*ShopDelete

const __sqlShopDelete_Table = "shop"
const __sqlShopDelete_ListCols = "\"deleted_at\""
const __sqlShopDelete_ListColsOnConflict = "\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlShopDelete_Insert = "INSERT INTO \"shop\" (" + __sqlShopDelete_ListCols + ") VALUES"
const __sqlShopDelete_Select = "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\""
const __sqlShopDelete_Select_history = "SELECT " + __sqlShopDelete_ListCols + " FROM history.\"shop\""
const __sqlShopDelete_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShopDelete_ListCols + ")"
const __sqlShopDelete_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shop_pkey DO UPDATE SET"

func (m *ShopDelete) SQLTableName() string  { return "shop" }
func (m *ShopDeletes) SQLTableName() string { return "shop" }
func (m *ShopDelete) SQLListCols() string   { return __sqlShopDelete_ListCols }

func (m *ShopDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShopDelete)(nil))
}

func (m *ShopDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopDeletes, 0, 128)
	for rows.Next() {
		m := new(ShopDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShopDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (_ *ShopDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (m *ShopDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShopDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShopDelete) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShopDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopDelete_ListColsOnConflict)
	return nil
}

func (ms ShopDeletes) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShopDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopDelete_ListColsOnConflict)
	return nil
}

func (m *ShopDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShopDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopDeleteHistory map[string]interface{}
type ShopDeleteHistories []map[string]interface{}

func (m *ShopDeleteHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopDeleteHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *ShopDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *ShopDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(ShopDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Partner represents table partner
func sqlgenPartner(_ *Partner) bool { return true }

type Partners []*Partner

const __sqlPartner_Table = "partner"
const __sqlPartner_ListCols = "\"id\",\"owner_id\",\"status\",\"is_test\",\"name\",\"public_name\",\"phone\",\"email\",\"image_url\",\"website_url\",\"contact_persons\",\"recognized_hosts\",\"redirect_urls\",\"available_from_etop\",\"available_from_etop_config\",\"white_label_key\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlPartner_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"status\" = EXCLUDED.\"status\",\"is_test\" = EXCLUDED.\"is_test\",\"name\" = EXCLUDED.\"name\",\"public_name\" = EXCLUDED.\"public_name\",\"phone\" = EXCLUDED.\"phone\",\"email\" = EXCLUDED.\"email\",\"image_url\" = EXCLUDED.\"image_url\",\"website_url\" = EXCLUDED.\"website_url\",\"contact_persons\" = EXCLUDED.\"contact_persons\",\"recognized_hosts\" = EXCLUDED.\"recognized_hosts\",\"redirect_urls\" = EXCLUDED.\"redirect_urls\",\"available_from_etop\" = EXCLUDED.\"available_from_etop\",\"available_from_etop_config\" = EXCLUDED.\"available_from_etop_config\",\"white_label_key\" = EXCLUDED.\"white_label_key\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlPartner_Insert = "INSERT INTO \"partner\" (" + __sqlPartner_ListCols + ") VALUES"
const __sqlPartner_Select = "SELECT " + __sqlPartner_ListCols + " FROM \"partner\""
const __sqlPartner_Select_history = "SELECT " + __sqlPartner_ListCols + " FROM history.\"partner\""
const __sqlPartner_UpdateAll = "UPDATE \"partner\" SET (" + __sqlPartner_ListCols + ")"
const __sqlPartner_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT partner_pkey DO UPDATE SET"

func (m *Partner) SQLTableName() string  { return "partner" }
func (m *Partners) SQLTableName() string { return "partner" }
func (m *Partner) SQLListCols() string   { return __sqlPartner_ListCols }

func (m *Partner) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartner_ListCols + " FROM \"partner\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Partner)(nil))
}

func (m *Partner) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		m.Status,
		core.Int(m.IsTest),
		core.String(m.Name),
		core.String(m.PublicName),
		core.String(m.Phone),
		core.String(m.Email),
		core.String(m.ImageURL),
		core.String(m.WebsiteURL),
		core.JSON{m.ContactPersons},
		core.Array{m.RecognizedHosts, opts},
		core.Array{m.RedirectURLs, opts},
		core.Bool(m.AvailableFromEtop),
		core.JSON{m.AvailableFromEtopConfig},
		core.String(m.WhiteLabelKey),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *Partner) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		&m.Status,
		(*core.Int)(&m.IsTest),
		(*core.String)(&m.Name),
		(*core.String)(&m.PublicName),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Email),
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.WebsiteURL),
		core.JSON{&m.ContactPersons},
		core.Array{&m.RecognizedHosts, opts},
		core.Array{&m.RedirectURLs, opts},
		(*core.Bool)(&m.AvailableFromEtop),
		core.JSON{&m.AvailableFromEtopConfig},
		(*core.String)(&m.WhiteLabelKey),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *Partner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Partners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Partners, 0, 128)
	for rows.Next() {
		m := new(Partner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Partner) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (_ *Partners) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (m *Partner) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Partners) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(19)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Partner) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlPartner_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartner_ListColsOnConflict)
	return nil
}

func (ms Partners) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlPartner_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartner_ListColsOnConflict)
	return nil
}

func (m *Partner) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.PublicName != "" {
		flag = true
		w.WriteName("public_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PublicName)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ContactPersons != nil {
		flag = true
		w.WriteName("contact_persons")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ContactPersons})
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.RedirectURLs != nil {
		flag = true
		w.WriteName("redirect_urls")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RedirectURLs, opts})
	}
	if m.AvailableFromEtop {
		flag = true
		w.WriteName("available_from_etop")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AvailableFromEtop)
	}
	if m.AvailableFromEtopConfig != nil {
		flag = true
		w.WriteName("available_from_etop_config")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.AvailableFromEtopConfig})
	}
	if m.WhiteLabelKey != "" {
		flag = true
		w.WriteName("white_label_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WhiteLabelKey)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Partner) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerHistory map[string]interface{}
type PartnerHistories []map[string]interface{}

func (m *PartnerHistory) SQLTableName() string  { return "history.\"partner\"" }
func (m PartnerHistories) SQLTableName() string { return "history.\"partner\"" }

func (m *PartnerHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistory) ID() core.Interface              { return core.Interface{m["id"]} }
func (m PartnerHistory) OwnerID() core.Interface         { return core.Interface{m["owner_id"]} }
func (m PartnerHistory) Status() core.Interface          { return core.Interface{m["status"]} }
func (m PartnerHistory) IsTest() core.Interface          { return core.Interface{m["is_test"]} }
func (m PartnerHistory) Name() core.Interface            { return core.Interface{m["name"]} }
func (m PartnerHistory) PublicName() core.Interface      { return core.Interface{m["public_name"]} }
func (m PartnerHistory) Phone() core.Interface           { return core.Interface{m["phone"]} }
func (m PartnerHistory) Email() core.Interface           { return core.Interface{m["email"]} }
func (m PartnerHistory) ImageURL() core.Interface        { return core.Interface{m["image_url"]} }
func (m PartnerHistory) WebsiteURL() core.Interface      { return core.Interface{m["website_url"]} }
func (m PartnerHistory) ContactPersons() core.Interface  { return core.Interface{m["contact_persons"]} }
func (m PartnerHistory) RecognizedHosts() core.Interface { return core.Interface{m["recognized_hosts"]} }
func (m PartnerHistory) RedirectURLs() core.Interface    { return core.Interface{m["redirect_urls"]} }
func (m PartnerHistory) AvailableFromEtop() core.Interface {
	return core.Interface{m["available_from_etop"]}
}
func (m PartnerHistory) AvailableFromEtopConfig() core.Interface {
	return core.Interface{m["available_from_etop_config"]}
}
func (m PartnerHistory) WhiteLabelKey() core.Interface { return core.Interface{m["white_label_key"]} }
func (m PartnerHistory) CreatedAt() core.Interface     { return core.Interface{m["created_at"]} }
func (m PartnerHistory) UpdatedAt() core.Interface     { return core.Interface{m["updated_at"]} }
func (m PartnerHistory) DeletedAt() core.Interface     { return core.Interface{m["deleted_at"]} }

func (m *PartnerHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerHistory, 19)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["status"] = data[2]
	res["is_test"] = data[3]
	res["name"] = data[4]
	res["public_name"] = data[5]
	res["phone"] = data[6]
	res["email"] = data[7]
	res["image_url"] = data[8]
	res["website_url"] = data[9]
	res["contact_persons"] = data[10]
	res["recognized_hosts"] = data[11]
	res["redirect_urls"] = data[12]
	res["available_from_etop"] = data[13]
	res["available_from_etop_config"] = data[14]
	res["white_label_key"] = data[15]
	res["created_at"] = data[16]
	res["updated_at"] = data[17]
	res["deleted_at"] = data[18]
	*m = res
	return nil
}

func (ms *PartnerHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["status"] = data[2]
		m["is_test"] = data[3]
		m["name"] = data[4]
		m["public_name"] = data[5]
		m["phone"] = data[6]
		m["email"] = data[7]
		m["image_url"] = data[8]
		m["website_url"] = data[9]
		m["contact_persons"] = data[10]
		m["recognized_hosts"] = data[11]
		m["redirect_urls"] = data[12]
		m["available_from_etop"] = data[13]
		m["available_from_etop_config"] = data[14]
		m["white_label_key"] = data[15]
		m["created_at"] = data[16]
		m["updated_at"] = data[17]
		m["deleted_at"] = data[18]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountAuth represents table account_auth
func sqlgenAccountAuth(_ *AccountAuth) bool { return true }

type AccountAuths []*AccountAuth

const __sqlAccountAuth_Table = "account_auth"
const __sqlAccountAuth_ListCols = "\"auth_key\",\"account_id\",\"status\",\"roles\",\"permissions\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlAccountAuth_ListColsOnConflict = "\"auth_key\" = EXCLUDED.\"auth_key\",\"account_id\" = EXCLUDED.\"account_id\",\"status\" = EXCLUDED.\"status\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlAccountAuth_Insert = "INSERT INTO \"account_auth\" (" + __sqlAccountAuth_ListCols + ") VALUES"
const __sqlAccountAuth_Select = "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\""
const __sqlAccountAuth_Select_history = "SELECT " + __sqlAccountAuth_ListCols + " FROM history.\"account_auth\""
const __sqlAccountAuth_UpdateAll = "UPDATE \"account_auth\" SET (" + __sqlAccountAuth_ListCols + ")"
const __sqlAccountAuth_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_auth_pkey DO UPDATE SET"

func (m *AccountAuth) SQLTableName() string  { return "account_auth" }
func (m *AccountAuths) SQLTableName() string { return "account_auth" }
func (m *AccountAuth) SQLListCols() string   { return __sqlAccountAuth_ListCols }

func (m *AccountAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountAuth)(nil))
}

func (m *AccountAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.AccountID,
		m.Status,
		core.Array{m.Roles, opts},
		core.Array{m.Permissions, opts},
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.AccountID,
		&m.Status,
		core.Array{&m.Roles, opts},
		core.Array{&m.Permissions, opts},
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuths, 0, 128)
	for rows.Next() {
		m := new(AccountAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (_ *AccountAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (m *AccountAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(8)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountAuth) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountAuth_ListColsOnConflict)
	return nil
}

func (ms AccountAuths) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountAuth_ListColsOnConflict)
	return nil
}

func (m *AccountAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_auth")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Roles, opts})
	}
	if m.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permissions, opts})
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountAuthHistory map[string]interface{}
type AccountAuthHistories []map[string]interface{}

func (m *AccountAuthHistory) SQLTableName() string  { return "history.\"account_auth\"" }
func (m AccountAuthHistories) SQLTableName() string { return "history.\"account_auth\"" }

func (m *AccountAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistory) AuthKey() core.Interface     { return core.Interface{m["auth_key"]} }
func (m AccountAuthHistory) AccountID() core.Interface   { return core.Interface{m["account_id"]} }
func (m AccountAuthHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m AccountAuthHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountAuthHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountAuthHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountAuthHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountAuthHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }

func (m *AccountAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountAuthHistory, 8)
	res["auth_key"] = data[0]
	res["account_id"] = data[1]
	res["status"] = data[2]
	res["roles"] = data[3]
	res["permissions"] = data[4]
	res["created_at"] = data[5]
	res["updated_at"] = data[6]
	res["deleted_at"] = data[7]
	*m = res
	return nil
}

func (ms *AccountAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	res := make(AccountAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountAuthHistory)
		m["auth_key"] = data[0]
		m["account_id"] = data[1]
		m["status"] = data[2]
		m["roles"] = data[3]
		m["permissions"] = data[4]
		m["created_at"] = data[5]
		m["updated_at"] = data[6]
		m["deleted_at"] = data[7]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountAuthFtPartner represents a join
func sqlgenAccountAuthFtPartner(_ *AccountAuthFtPartner, _ *AccountAuth, as sq.AS, t0 sq.JOIN_TYPE, _ *Partner, a0 sq.AS, c0 string) bool {
	__sqlAccountAuthFtPartner_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlAccountAuthFtPartner_As = as
	__sqlAccountAuthFtPartner_JoinAs = []sq.AS{a0}
	__sqlAccountAuthFtPartner_JoinConds = []string{c0}
	return true
}

type AccountAuthFtPartners []*AccountAuthFtPartner

var __sqlAccountAuthFtPartner_JoinTypes []sq.JOIN_TYPE
var __sqlAccountAuthFtPartner_As sq.AS
var __sqlAccountAuthFtPartner_JoinAs []sq.AS
var __sqlAccountAuthFtPartner_JoinConds []string

func (m *AccountAuthFtPartner) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtPartners) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtPartner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtPartners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtPartners, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtPartner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtPartner) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtPartner)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtPartner)(nil).__sqlJoin(w, __sqlAccountAuthFtPartner_JoinTypes)
	return nil
}

func (m *AccountAuthFtPartners) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtPartner)(nil).SQLSelect(w)
}

func (m *AccountAuthFtPartner) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountAuthFtPartner_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountAuthFtPartners) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountAuthFtPartner)(nil).SQLJoin(w, types)
}

func (m *AccountAuthFtPartner) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountAuthFtPartner_As), (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountAuthFtPartner_JoinAs[0]), (*Partner)(nil).SQLListCols())
}

func (m *AccountAuthFtPartner) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtPartner_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Partner)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtPartner_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountAuthFtPartner_JoinConds[0])
}

func (m *AccountAuthFtPartner) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Partner = new(Partner)
	args = append(args, m.Partner.SQLScanArgs(opts)...)

	return args
}

// Type AccountAuthFtShop represents a join
func sqlgenAccountAuthFtShop(_ *AccountAuthFtShop, _ *AccountAuth, as sq.AS, t0 sq.JOIN_TYPE, _ *Shop, a0 sq.AS, c0 string) bool {
	__sqlAccountAuthFtShop_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlAccountAuthFtShop_As = as
	__sqlAccountAuthFtShop_JoinAs = []sq.AS{a0}
	__sqlAccountAuthFtShop_JoinConds = []string{c0}
	return true
}

type AccountAuthFtShops []*AccountAuthFtShop

var __sqlAccountAuthFtShop_JoinTypes []sq.JOIN_TYPE
var __sqlAccountAuthFtShop_As sq.AS
var __sqlAccountAuthFtShop_JoinAs []sq.AS
var __sqlAccountAuthFtShop_JoinConds []string

func (m *AccountAuthFtShop) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtShops) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtShops, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtShop) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtShop)(nil).__sqlJoin(w, __sqlAccountAuthFtShop_JoinTypes)
	return nil
}

func (m *AccountAuthFtShops) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtShop)(nil).SQLSelect(w)
}

func (m *AccountAuthFtShop) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountAuthFtShop_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountAuthFtShops) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountAuthFtShop)(nil).SQLJoin(w, types)
}

func (m *AccountAuthFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountAuthFtShop_As), (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountAuthFtShop_JoinAs[0]), (*Shop)(nil).SQLListCols())
}

func (m *AccountAuthFtShop) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtShop_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtShop_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountAuthFtShop_JoinConds[0])
}

func (m *AccountAuthFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)

	return args
}

// Type PartnerRelation represents table partner_relation
func sqlgenPartnerRelation(_ *PartnerRelation) bool { return true }

type PartnerRelations []*PartnerRelation

const __sqlPartnerRelation_Table = "partner_relation"
const __sqlPartnerRelation_ListCols = "\"auth_key\",\"partner_id\",\"subject_id\",\"subject_type\",\"external_subject_id\",\"nonce\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\""
const __sqlPartnerRelation_ListColsOnConflict = "\"auth_key\" = EXCLUDED.\"auth_key\",\"partner_id\" = EXCLUDED.\"partner_id\",\"subject_id\" = EXCLUDED.\"subject_id\",\"subject_type\" = EXCLUDED.\"subject_type\",\"external_subject_id\" = EXCLUDED.\"external_subject_id\",\"nonce\" = EXCLUDED.\"nonce\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\""
const __sqlPartnerRelation_Insert = "INSERT INTO \"partner_relation\" (" + __sqlPartnerRelation_ListCols + ") VALUES"
const __sqlPartnerRelation_Select = "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\""
const __sqlPartnerRelation_Select_history = "SELECT " + __sqlPartnerRelation_ListCols + " FROM history.\"partner_relation\""
const __sqlPartnerRelation_UpdateAll = "UPDATE \"partner_relation\" SET (" + __sqlPartnerRelation_ListCols + ")"
const __sqlPartnerRelation_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT partner_relation_pkey DO UPDATE SET"

func (m *PartnerRelation) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelations) SQLTableName() string { return "partner_relation" }
func (m *PartnerRelation) SQLListCols() string   { return __sqlPartnerRelation_ListCols }

func (m *PartnerRelation) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*PartnerRelation)(nil))
}

func (m *PartnerRelation) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.PartnerID,
		m.SubjectID,
		core.String(m.SubjectType),
		core.String(m.ExternalSubjectID),
		m.Nonce,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.PartnerID,
		&m.SubjectID,
		(*core.String)(&m.SubjectType),
		(*core.String)(&m.ExternalSubjectID),
		&m.Nonce,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelations) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelations, 0, 128)
	for rows.Next() {
		m := new(PartnerRelation)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *PartnerRelation) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (_ *PartnerRelations) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (m *PartnerRelation) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms PartnerRelations) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(12)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *PartnerRelation) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlPartnerRelation_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartnerRelation_ListColsOnConflict)
	return nil
}

func (ms PartnerRelations) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlPartnerRelation_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartnerRelation_ListColsOnConflict)
	return nil
}

func (m *PartnerRelation) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner_relation")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.PartnerID != 0 {
		flag = true
		w.WriteName("partner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PartnerID)
	}
	if m.SubjectID != 0 {
		flag = true
		w.WriteName("subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.SubjectID)
	}
	if m.SubjectType != "" {
		flag = true
		w.WriteName("subject_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.SubjectType))
	}
	if m.ExternalSubjectID != "" {
		flag = true
		w.WriteName("external_subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalSubjectID)
	}
	if m.Nonce != 0 {
		flag = true
		w.WriteName("nonce")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Nonce)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *PartnerRelation) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerRelationHistory map[string]interface{}
type PartnerRelationHistories []map[string]interface{}

func (m *PartnerRelationHistory) SQLTableName() string  { return "history.\"partner_relation\"" }
func (m PartnerRelationHistories) SQLTableName() string { return "history.\"partner_relation\"" }

func (m *PartnerRelationHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistory) AuthKey() core.Interface     { return core.Interface{m["auth_key"]} }
func (m PartnerRelationHistory) PartnerID() core.Interface   { return core.Interface{m["partner_id"]} }
func (m PartnerRelationHistory) SubjectID() core.Interface   { return core.Interface{m["subject_id"]} }
func (m PartnerRelationHistory) SubjectType() core.Interface { return core.Interface{m["subject_type"]} }
func (m PartnerRelationHistory) ExternalSubjectID() core.Interface {
	return core.Interface{m["external_subject_id"]}
}
func (m PartnerRelationHistory) Nonce() core.Interface       { return core.Interface{m["nonce"]} }
func (m PartnerRelationHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m PartnerRelationHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m PartnerRelationHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m PartnerRelationHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m PartnerRelationHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m PartnerRelationHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }

func (m *PartnerRelationHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerRelationHistory, 12)
	res["auth_key"] = data[0]
	res["partner_id"] = data[1]
	res["subject_id"] = data[2]
	res["subject_type"] = data[3]
	res["external_subject_id"] = data[4]
	res["nonce"] = data[5]
	res["status"] = data[6]
	res["created_at"] = data[7]
	res["updated_at"] = data[8]
	res["deleted_at"] = data[9]
	res["roles"] = data[10]
	res["permissions"] = data[11]
	*m = res
	return nil
}

func (ms *PartnerRelationHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerRelationHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerRelationHistory)
		m["auth_key"] = data[0]
		m["partner_id"] = data[1]
		m["subject_id"] = data[2]
		m["subject_type"] = data[3]
		m["external_subject_id"] = data[4]
		m["nonce"] = data[5]
		m["status"] = data[6]
		m["created_at"] = data[7]
		m["updated_at"] = data[8]
		m["deleted_at"] = data[9]
		m["roles"] = data[10]
		m["permissions"] = data[11]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type PartnerRelationFtShop represents a join
func sqlgenPartnerRelationFtShop(_ *PartnerRelationFtShop, _ *PartnerRelation, as sq.AS, t0 sq.JOIN_TYPE, _ *Shop, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlPartnerRelationFtShop_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlPartnerRelationFtShop_As = as
	__sqlPartnerRelationFtShop_JoinAs = []sq.AS{a0, a1}
	__sqlPartnerRelationFtShop_JoinConds = []string{c0, c1}
	return true
}

type PartnerRelationFtShops []*PartnerRelationFtShop

var __sqlPartnerRelationFtShop_JoinTypes []sq.JOIN_TYPE
var __sqlPartnerRelationFtShop_As sq.AS
var __sqlPartnerRelationFtShop_JoinAs []sq.AS
var __sqlPartnerRelationFtShop_JoinConds []string

func (m *PartnerRelationFtShop) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelationFtShops) SQLTableName() string { return "partner_relation" }

func (m *PartnerRelationFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelationFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelationFtShops, 0, 128)
	for rows.Next() {
		m := new(PartnerRelationFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *PartnerRelationFtShop) SQLSelect(w SQLWriter) error {
	(*PartnerRelationFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*PartnerRelationFtShop)(nil).__sqlJoin(w, __sqlPartnerRelationFtShop_JoinTypes)
	return nil
}

func (m *PartnerRelationFtShops) SQLSelect(w SQLWriter) error {
	return (*PartnerRelationFtShop)(nil).SQLSelect(w)
}

func (m *PartnerRelationFtShop) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlPartnerRelationFtShop_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *PartnerRelationFtShops) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*PartnerRelationFtShop)(nil).SQLJoin(w, types)
}

func (m *PartnerRelationFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_As), (*PartnerRelation)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_JoinAs[0]), (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *PartnerRelationFtShop) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("partner_relation")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlPartnerRelationFtShop_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlPartnerRelationFtShop_JoinConds[1])
}

func (m *PartnerRelationFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.PartnerRelation = new(PartnerRelation)
	args = append(args, m.PartnerRelation.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// Type User represents table user
func sqlgenUser(_ *User) bool { return true }

type Users []*User

const __sqlUser_Table = "user"
const __sqlUser_ListCols = "\"id\",\"full_name\",\"short_name\",\"email\",\"phone\",\"status\",\"created_at\",\"updated_at\",\"agreed_tos_at\",\"agreed_email_info_at\",\"email_verified_at\",\"phone_verified_at\",\"email_verification_sent_at\",\"phone_verification_sent_at\",\"is_test\",\"source\",\"ref_user_id\",\"ref_sale_id\""
const __sqlUser_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"full_name\" = EXCLUDED.\"full_name\",\"short_name\" = EXCLUDED.\"short_name\",\"email\" = EXCLUDED.\"email\",\"phone\" = EXCLUDED.\"phone\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"agreed_tos_at\" = EXCLUDED.\"agreed_tos_at\",\"agreed_email_info_at\" = EXCLUDED.\"agreed_email_info_at\",\"email_verified_at\" = EXCLUDED.\"email_verified_at\",\"phone_verified_at\" = EXCLUDED.\"phone_verified_at\",\"email_verification_sent_at\" = EXCLUDED.\"email_verification_sent_at\",\"phone_verification_sent_at\" = EXCLUDED.\"phone_verification_sent_at\",\"is_test\" = EXCLUDED.\"is_test\",\"source\" = EXCLUDED.\"source\",\"ref_user_id\" = EXCLUDED.\"ref_user_id\",\"ref_sale_id\" = EXCLUDED.\"ref_sale_id\""
const __sqlUser_Insert = "INSERT INTO \"user\" (" + __sqlUser_ListCols + ") VALUES"
const __sqlUser_Select = "SELECT " + __sqlUser_ListCols + " FROM \"user\""
const __sqlUser_Select_history = "SELECT " + __sqlUser_ListCols + " FROM history.\"user\""
const __sqlUser_UpdateAll = "UPDATE \"user\" SET (" + __sqlUser_ListCols + ")"
const __sqlUser_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_pkey DO UPDATE SET"

func (m *User) SQLTableName() string  { return "user" }
func (m *Users) SQLTableName() string { return "user" }
func (m *User) SQLListCols() string   { return __sqlUser_ListCols }

func (m *User) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUser_ListCols + " FROM \"user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*User)(nil))
}

func (m *User) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.UserInner.FullName),
		core.String(m.UserInner.ShortName),
		core.String(m.UserInner.Email),
		core.String(m.UserInner.Phone),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.AgreedTOSAt),
		core.Time(m.AgreedEmailInfoAt),
		core.Time(m.EmailVerifiedAt),
		core.Time(m.PhoneVerifiedAt),
		core.Time(m.EmailVerificationSentAt),
		core.Time(m.PhoneVerificationSentAt),
		core.Int(m.IsTest),
		m.Source,
		m.RefUserID,
		m.RefSaleID,
	}
}

func (m *User) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.UserInner.FullName),
		(*core.String)(&m.UserInner.ShortName),
		(*core.String)(&m.UserInner.Email),
		(*core.String)(&m.UserInner.Phone),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.AgreedTOSAt),
		(*core.Time)(&m.AgreedEmailInfoAt),
		(*core.Time)(&m.EmailVerifiedAt),
		(*core.Time)(&m.PhoneVerifiedAt),
		(*core.Time)(&m.EmailVerificationSentAt),
		(*core.Time)(&m.PhoneVerificationSentAt),
		(*core.Int)(&m.IsTest),
		&m.Source,
		&m.RefUserID,
		&m.RefSaleID,
	}
}

func (m *User) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Users) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Users, 0, 128)
	for rows.Next() {
		m := new(User)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *User) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (_ *Users) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (m *User) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Users) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(18)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *User) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUser_ListColsOnConflict)
	return nil
}

func (ms Users) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUser_ListColsOnConflict)
	return nil
}

func (m *User) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserInner.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.FullName)
	}
	if m.UserInner.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.ShortName)
	}
	if m.UserInner.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Email)
	}
	if m.UserInner.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Phone)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.AgreedTOSAt.IsZero() {
		flag = true
		w.WriteName("agreed_tos_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedTOSAt)
	}
	if !m.AgreedEmailInfoAt.IsZero() {
		flag = true
		w.WriteName("agreed_email_info_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedEmailInfoAt)
	}
	if !m.EmailVerifiedAt.IsZero() {
		flag = true
		w.WriteName("email_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerifiedAt)
	}
	if !m.PhoneVerifiedAt.IsZero() {
		flag = true
		w.WriteName("phone_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerifiedAt)
	}
	if !m.EmailVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("email_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerificationSentAt)
	}
	if !m.PhoneVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("phone_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerificationSentAt)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Source != 0 {
		flag = true
		w.WriteName("source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Source)
	}
	if m.RefUserID != 0 {
		flag = true
		w.WriteName("ref_user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefUserID)
	}
	if m.RefSaleID != 0 {
		flag = true
		w.WriteName("ref_sale_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefSaleID)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *User) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserHistory map[string]interface{}
type UserHistories []map[string]interface{}

func (m *UserHistory) SQLTableName() string  { return "history.\"user\"" }
func (m UserHistories) SQLTableName() string { return "history.\"user\"" }

func (m *UserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m UserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m UserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m UserHistory) Email() core.Interface       { return core.Interface{m["email"]} }
func (m UserHistory) Phone() core.Interface       { return core.Interface{m["phone"]} }
func (m UserHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m UserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m UserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m UserHistory) AgreedTOSAt() core.Interface { return core.Interface{m["agreed_tos_at"]} }
func (m UserHistory) AgreedEmailInfoAt() core.Interface {
	return core.Interface{m["agreed_email_info_at"]}
}
func (m UserHistory) EmailVerifiedAt() core.Interface { return core.Interface{m["email_verified_at"]} }
func (m UserHistory) PhoneVerifiedAt() core.Interface { return core.Interface{m["phone_verified_at"]} }
func (m UserHistory) EmailVerificationSentAt() core.Interface {
	return core.Interface{m["email_verification_sent_at"]}
}
func (m UserHistory) PhoneVerificationSentAt() core.Interface {
	return core.Interface{m["phone_verification_sent_at"]}
}
func (m UserHistory) IsTest() core.Interface    { return core.Interface{m["is_test"]} }
func (m UserHistory) Source() core.Interface    { return core.Interface{m["source"]} }
func (m UserHistory) RefUserID() core.Interface { return core.Interface{m["ref_user_id"]} }
func (m UserHistory) RefSaleID() core.Interface { return core.Interface{m["ref_sale_id"]} }

func (m *UserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserHistory, 18)
	res["id"] = data[0]
	res["full_name"] = data[1]
	res["short_name"] = data[2]
	res["email"] = data[3]
	res["phone"] = data[4]
	res["status"] = data[5]
	res["created_at"] = data[6]
	res["updated_at"] = data[7]
	res["agreed_tos_at"] = data[8]
	res["agreed_email_info_at"] = data[9]
	res["email_verified_at"] = data[10]
	res["phone_verified_at"] = data[11]
	res["email_verification_sent_at"] = data[12]
	res["phone_verification_sent_at"] = data[13]
	res["is_test"] = data[14]
	res["source"] = data[15]
	res["ref_user_id"] = data[16]
	res["ref_sale_id"] = data[17]
	*m = res
	return nil
}

func (ms *UserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	res := make(UserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserHistory)
		m["id"] = data[0]
		m["full_name"] = data[1]
		m["short_name"] = data[2]
		m["email"] = data[3]
		m["phone"] = data[4]
		m["status"] = data[5]
		m["created_at"] = data[6]
		m["updated_at"] = data[7]
		m["agreed_tos_at"] = data[8]
		m["agreed_email_info_at"] = data[9]
		m["email_verified_at"] = data[10]
		m["phone_verified_at"] = data[11]
		m["email_verification_sent_at"] = data[12]
		m["phone_verification_sent_at"] = data[13]
		m["is_test"] = data[14]
		m["source"] = data[15]
		m["ref_user_id"] = data[16]
		m["ref_sale_id"] = data[17]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountUser represents table account_user
func sqlgenAccountUser(_ *AccountUser) bool { return true }

type AccountUsers []*AccountUser

const __sqlAccountUser_Table = "account_user"
const __sqlAccountUser_ListCols = "\"account_id\",\"user_id\",\"status\",\"response_status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\",\"full_name\",\"short_name\",\"position\",\"invitation_sent_at\",\"invitation_sent_by\",\"invitation_accepted_at\",\"invitation_rejected_at\",\"disabled_at\",\"disabled_by\",\"disable_reason\""
const __sqlAccountUser_ListColsOnConflict = "\"account_id\" = EXCLUDED.\"account_id\",\"user_id\" = EXCLUDED.\"user_id\",\"status\" = EXCLUDED.\"status\",\"response_status\" = EXCLUDED.\"response_status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\",\"full_name\" = EXCLUDED.\"full_name\",\"short_name\" = EXCLUDED.\"short_name\",\"position\" = EXCLUDED.\"position\",\"invitation_sent_at\" = EXCLUDED.\"invitation_sent_at\",\"invitation_sent_by\" = EXCLUDED.\"invitation_sent_by\",\"invitation_accepted_at\" = EXCLUDED.\"invitation_accepted_at\",\"invitation_rejected_at\" = EXCLUDED.\"invitation_rejected_at\",\"disabled_at\" = EXCLUDED.\"disabled_at\",\"disabled_by\" = EXCLUDED.\"disabled_by\",\"disable_reason\" = EXCLUDED.\"disable_reason\""
const __sqlAccountUser_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUser_ListCols + ") VALUES"
const __sqlAccountUser_Select = "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\""
const __sqlAccountUser_Select_history = "SELECT " + __sqlAccountUser_ListCols + " FROM history.\"account_user\""
const __sqlAccountUser_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUser_ListCols + ")"
const __sqlAccountUser_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_user_pkey DO UPDATE SET"

func (m *AccountUser) SQLTableName() string  { return "account_user" }
func (m *AccountUsers) SQLTableName() string { return "account_user" }
func (m *AccountUser) SQLListCols() string   { return __sqlAccountUser_ListCols }

func (m *AccountUser) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUser)(nil))
}

func (m *AccountUser) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.AccountID,
		m.UserID,
		m.Status,
		m.ResponseStatus,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
		core.String(m.FullName),
		core.String(m.ShortName),
		core.String(m.Position),
		core.Time(m.InvitationSentAt),
		m.InvitationSentBy,
		core.Time(m.InvitationAcceptedAt),
		core.Time(m.InvitationRejectedAt),
		core.Time(m.DisabledAt),
		core.Time(m.DisabledBy),
		core.String(m.DisableReason),
	}
}

func (m *AccountUser) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.AccountID,
		&m.UserID,
		&m.Status,
		&m.ResponseStatus,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
		(*core.String)(&m.FullName),
		(*core.String)(&m.ShortName),
		(*core.String)(&m.Position),
		(*core.Time)(&m.InvitationSentAt),
		&m.InvitationSentBy,
		(*core.Time)(&m.InvitationAcceptedAt),
		(*core.Time)(&m.InvitationRejectedAt),
		(*core.Time)(&m.DisabledAt),
		(*core.Time)(&m.DisabledBy),
		(*core.String)(&m.DisableReason),
	}
}

func (m *AccountUser) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUsers) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUsers, 0, 128)
	for rows.Next() {
		m := new(AccountUser)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUser) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (_ *AccountUsers) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (m *AccountUser) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUsers) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(19)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUser) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUser_ListColsOnConflict)
	return nil
}

func (ms AccountUsers) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUser_ListColsOnConflict)
	return nil
}

func (m *AccountUser) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.ResponseStatus != 0 {
		flag = true
		w.WriteName("response_status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ResponseStatus)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if m.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FullName)
	}
	if m.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShortName)
	}
	if m.Position != "" {
		flag = true
		w.WriteName("position")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Position)
	}
	if !m.InvitationSentAt.IsZero() {
		flag = true
		w.WriteName("invitation_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentAt)
	}
	if m.InvitationSentBy != 0 {
		flag = true
		w.WriteName("invitation_sent_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentBy)
	}
	if !m.InvitationAcceptedAt.IsZero() {
		flag = true
		w.WriteName("invitation_accepted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationAcceptedAt)
	}
	if !m.InvitationRejectedAt.IsZero() {
		flag = true
		w.WriteName("invitation_rejected_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationRejectedAt)
	}
	if !m.DisabledAt.IsZero() {
		flag = true
		w.WriteName("disabled_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledAt)
	}
	if !m.DisabledBy.IsZero() {
		flag = true
		w.WriteName("disabled_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledBy)
	}
	if m.DisableReason != "" {
		flag = true
		w.WriteName("disable_reason")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisableReason)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUser) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserHistory map[string]interface{}
type AccountUserHistories []map[string]interface{}

func (m *AccountUserHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m AccountUserHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m AccountUserHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m AccountUserHistory) ResponseStatus() core.Interface {
	return core.Interface{m["response_status"]}
}
func (m AccountUserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountUserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountUserHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m AccountUserHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountUserHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountUserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m AccountUserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m AccountUserHistory) Position() core.Interface    { return core.Interface{m["position"]} }
func (m AccountUserHistory) InvitationSentAt() core.Interface {
	return core.Interface{m["invitation_sent_at"]}
}
func (m AccountUserHistory) InvitationSentBy() core.Interface {
	return core.Interface{m["invitation_sent_by"]}
}
func (m AccountUserHistory) InvitationAcceptedAt() core.Interface {
	return core.Interface{m["invitation_accepted_at"]}
}
func (m AccountUserHistory) InvitationRejectedAt() core.Interface {
	return core.Interface{m["invitation_rejected_at"]}
}
func (m AccountUserHistory) DisabledAt() core.Interface    { return core.Interface{m["disabled_at"]} }
func (m AccountUserHistory) DisabledBy() core.Interface    { return core.Interface{m["disabled_by"]} }
func (m AccountUserHistory) DisableReason() core.Interface { return core.Interface{m["disable_reason"]} }

func (m *AccountUserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserHistory, 19)
	res["account_id"] = data[0]
	res["user_id"] = data[1]
	res["status"] = data[2]
	res["response_status"] = data[3]
	res["created_at"] = data[4]
	res["updated_at"] = data[5]
	res["deleted_at"] = data[6]
	res["roles"] = data[7]
	res["permissions"] = data[8]
	res["full_name"] = data[9]
	res["short_name"] = data[10]
	res["position"] = data[11]
	res["invitation_sent_at"] = data[12]
	res["invitation_sent_by"] = data[13]
	res["invitation_accepted_at"] = data[14]
	res["invitation_rejected_at"] = data[15]
	res["disabled_at"] = data[16]
	res["disabled_by"] = data[17]
	res["disable_reason"] = data[18]
	*m = res
	return nil
}

func (ms *AccountUserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserHistory)
		m["account_id"] = data[0]
		m["user_id"] = data[1]
		m["status"] = data[2]
		m["response_status"] = data[3]
		m["created_at"] = data[4]
		m["updated_at"] = data[5]
		m["deleted_at"] = data[6]
		m["roles"] = data[7]
		m["permissions"] = data[8]
		m["full_name"] = data[9]
		m["short_name"] = data[10]
		m["position"] = data[11]
		m["invitation_sent_at"] = data[12]
		m["invitation_sent_by"] = data[13]
		m["invitation_accepted_at"] = data[14]
		m["invitation_rejected_at"] = data[15]
		m["disabled_at"] = data[16]
		m["disabled_by"] = data[17]
		m["disable_reason"] = data[18]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountUserExtended represents a join
func sqlgenAccountUserExtended(_ *AccountUserExtended, _ *AccountUser, as sq.AS, t0 sq.JOIN_TYPE, _ *Account, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlAccountUserExtended_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlAccountUserExtended_As = as
	__sqlAccountUserExtended_JoinAs = []sq.AS{a0, a1}
	__sqlAccountUserExtended_JoinConds = []string{c0, c1}
	return true
}

type AccountUserExtendeds []*AccountUserExtended

var __sqlAccountUserExtended_JoinTypes []sq.JOIN_TYPE
var __sqlAccountUserExtended_As sq.AS
var __sqlAccountUserExtended_JoinAs []sq.AS
var __sqlAccountUserExtended_JoinConds []string

func (m *AccountUserExtended) SQLTableName() string  { return "account_user" }
func (m *AccountUserExtendeds) SQLTableName() string { return "account_user" }

func (m *AccountUserExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserExtendeds, 0, 128)
	for rows.Next() {
		m := new(AccountUserExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountUserExtended) SQLSelect(w SQLWriter) error {
	(*AccountUserExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountUserExtended)(nil).__sqlJoin(w, __sqlAccountUserExtended_JoinTypes)
	return nil
}

func (m *AccountUserExtendeds) SQLSelect(w SQLWriter) error {
	return (*AccountUserExtended)(nil).SQLSelect(w)
}

func (m *AccountUserExtended) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountUserExtended_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountUserExtendeds) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountUserExtended)(nil).SQLJoin(w, types)
}

func (m *AccountUserExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountUserExtended_As), (*AccountUser)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountUserExtended_JoinAs[0]), (*Account)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountUserExtended_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *AccountUserExtended) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_user")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Account)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountUserExtended_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountUserExtended_JoinConds[1])
}

func (m *AccountUserExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountUser = new(AccountUser)
	args = append(args, m.AccountUser.SQLScanArgs(opts)...)
	m.Account = new(Account)
	args = append(args, m.Account.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// *AccountUserDelete is a substruct of *AccountUser
func substructAccountUserDelete(_ *AccountUserDelete, _ *AccountUser) bool { return true }

func AccountUserDeletesFromAccountUsers(ps []*AccountUser) []*AccountUserDelete {
	ss := make([]*AccountUserDelete, len(ps))
	for i, p := range ps {
		ss[i] = NewAccountUserDeleteFromAccountUser(p)
	}
	return ss
}

func AccountUserDeletesToAccountUsers(ss []*AccountUserDelete) []*AccountUser {
	ps := make([]*AccountUser, len(ss))
	for i, s := range ss {
		ps[i] = s.ToAccountUser()
	}
	return ps
}

func NewAccountUserDeleteFromAccountUser(sp *AccountUser) *AccountUserDelete {
	if sp == nil {
		return nil
	}
	s := new(AccountUserDelete)
	s.CopyFrom(sp)
	return s
}

func (s *AccountUserDelete) ToAccountUser() *AccountUser {
	if s == nil {
		return nil
	}
	sp := new(AccountUser)
	s.AssignTo(sp)
	return sp
}

func (s *AccountUserDelete) CopyFrom(sp *AccountUser) {
	s.DeletedAt = sp.DeletedAt
}

func (s *AccountUserDelete) AssignTo(sp *AccountUser) {
	sp.DeletedAt = s.DeletedAt
}

// Type AccountUserDelete represents table account_user
func sqlgenAccountUserDelete(_ *AccountUserDelete, _ *AccountUser) bool { return true }

type AccountUserDeletes []*AccountUserDelete

const __sqlAccountUserDelete_Table = "account_user"
const __sqlAccountUserDelete_ListCols = "\"deleted_at\""
const __sqlAccountUserDelete_ListColsOnConflict = "\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlAccountUserDelete_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUserDelete_ListCols + ") VALUES"
const __sqlAccountUserDelete_Select = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\""
const __sqlAccountUserDelete_Select_history = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM history.\"account_user\""
const __sqlAccountUserDelete_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUserDelete_ListCols + ")"
const __sqlAccountUserDelete_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_user_pkey DO UPDATE SET"

func (m *AccountUserDelete) SQLTableName() string  { return "account_user" }
func (m *AccountUserDeletes) SQLTableName() string { return "account_user" }
func (m *AccountUserDelete) SQLListCols() string   { return __sqlAccountUserDelete_ListCols }

func (m *AccountUserDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUserDelete)(nil))
}

func (m *AccountUserDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserDeletes, 0, 128)
	for rows.Next() {
		m := new(AccountUserDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUserDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (_ *AccountUserDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (m *AccountUserDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUserDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUserDelete) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUserDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUserDelete_ListColsOnConflict)
	return nil
}

func (ms AccountUserDeletes) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUserDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUserDelete_ListColsOnConflict)
	return nil
}

func (m *AccountUserDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUserDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserDeleteHistory map[string]interface{}
type AccountUserDeleteHistories []map[string]interface{}

func (m *AccountUserDeleteHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserDeleteHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *AccountUserDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *AccountUserDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserAuth represents table user_auth
func sqlgenUserAuth(_ *UserAuth) bool { return true }

type UserAuths []*UserAuth

const __sqlUserAuth_Table = "user_auth"
const __sqlUserAuth_ListCols = "\"user_id\",\"auth_type\",\"auth_key\",\"created_at\",\"updated_at\""
const __sqlUserAuth_ListColsOnConflict = "\"user_id\" = EXCLUDED.\"user_id\",\"auth_type\" = EXCLUDED.\"auth_type\",\"auth_key\" = EXCLUDED.\"auth_key\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlUserAuth_Insert = "INSERT INTO \"user_auth\" (" + __sqlUserAuth_ListCols + ") VALUES"
const __sqlUserAuth_Select = "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\""
const __sqlUserAuth_Select_history = "SELECT " + __sqlUserAuth_ListCols + " FROM history.\"user_auth\""
const __sqlUserAuth_UpdateAll = "UPDATE \"user_auth\" SET (" + __sqlUserAuth_ListCols + ")"
const __sqlUserAuth_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_auth_pkey DO UPDATE SET"

func (m *UserAuth) SQLTableName() string  { return "user_auth" }
func (m *UserAuths) SQLTableName() string { return "user_auth" }
func (m *UserAuth) SQLListCols() string   { return __sqlUserAuth_ListCols }

func (m *UserAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserAuth)(nil))
}

func (m *UserAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.UserID,
		core.String(m.AuthType),
		core.String(m.AuthKey),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.UserID,
		(*core.String)(&m.AuthType),
		(*core.String)(&m.AuthKey),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserAuths, 0, 128)
	for rows.Next() {
		m := new(UserAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (_ *UserAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (m *UserAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(5)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserAuth) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUserAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserAuth_ListColsOnConflict)
	return nil
}

func (ms UserAuths) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUserAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserAuth_ListColsOnConflict)
	return nil
}

func (m *UserAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_auth")
	w.WriteRawString(" SET ")
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AuthType != "" {
		flag = true
		w.WriteName("auth_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthType)
	}
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserAuthHistory map[string]interface{}
type UserAuthHistories []map[string]interface{}

func (m *UserAuthHistory) SQLTableName() string  { return "history.\"user_auth\"" }
func (m UserAuthHistories) SQLTableName() string { return "history.\"user_auth\"" }

func (m *UserAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m UserAuthHistory) AuthType() core.Interface  { return core.Interface{m["auth_type"]} }
func (m UserAuthHistory) AuthKey() core.Interface   { return core.Interface{m["auth_key"]} }
func (m UserAuthHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m UserAuthHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserAuthHistory, 5)
	res["user_id"] = data[0]
	res["auth_type"] = data[1]
	res["auth_key"] = data[2]
	res["created_at"] = data[3]
	res["updated_at"] = data[4]
	*m = res
	return nil
}

func (ms *UserAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	res := make(UserAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserAuthHistory)
		m["user_id"] = data[0]
		m["auth_type"] = data[1]
		m["auth_key"] = data[2]
		m["created_at"] = data[3]
		m["updated_at"] = data[4]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserInternal represents table user_internal
func sqlgenUserInternal(_ *UserInternal) bool { return true }

type UserInternals []*UserInternal

const __sqlUserInternal_Table = "user_internal"
const __sqlUserInternal_ListCols = "\"id\",\"hashpwd\",\"updated_at\""
const __sqlUserInternal_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"hashpwd\" = EXCLUDED.\"hashpwd\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlUserInternal_Insert = "INSERT INTO \"user_internal\" (" + __sqlUserInternal_ListCols + ") VALUES"
const __sqlUserInternal_Select = "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\""
const __sqlUserInternal_Select_history = "SELECT " + __sqlUserInternal_ListCols + " FROM history.\"user_internal\""
const __sqlUserInternal_UpdateAll = "UPDATE \"user_internal\" SET (" + __sqlUserInternal_ListCols + ")"
const __sqlUserInternal_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_internal_pkey DO UPDATE SET"

func (m *UserInternal) SQLTableName() string  { return "user_internal" }
func (m *UserInternals) SQLTableName() string { return "user_internal" }
func (m *UserInternal) SQLListCols() string   { return __sqlUserInternal_ListCols }

func (m *UserInternal) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserInternal)(nil))
}

func (m *UserInternal) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Hashpwd),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserInternal) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Hashpwd),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserInternal) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserInternals) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserInternals, 0, 128)
	for rows.Next() {
		m := new(UserInternal)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserInternal) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (_ *UserInternals) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (m *UserInternal) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserInternals) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserInternal) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUserInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserInternal_ListColsOnConflict)
	return nil
}

func (ms UserInternals) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUserInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserInternal_ListColsOnConflict)
	return nil
}

func (m *UserInternal) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_internal")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Hashpwd != "" {
		flag = true
		w.WriteName("hashpwd")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Hashpwd)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserInternal) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserInternalHistory map[string]interface{}
type UserInternalHistories []map[string]interface{}

func (m *UserInternalHistory) SQLTableName() string  { return "history.\"user_internal\"" }
func (m UserInternalHistories) SQLTableName() string { return "history.\"user_internal\"" }

func (m *UserInternalHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m UserInternalHistory) Hashpwd() core.Interface   { return core.Interface{m["hashpwd"]} }
func (m UserInternalHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserInternalHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserInternalHistory, 3)
	res["id"] = data[0]
	res["hashpwd"] = data[1]
	res["updated_at"] = data[2]
	*m = res
	return nil
}

func (ms *UserInternalHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(UserInternalHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserInternalHistory)
		m["id"] = data[0]
		m["hashpwd"] = data[1]
		m["updated_at"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
