// +build !generator

// Code generated by generator sqlgen. DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	time "time"

	addressmodel "o.o/backend/com/main/address/model"
	cmsql "o.o/backend/pkg/common/sql/cmsql"
	migration "o.o/backend/pkg/common/sql/migration"
	core "o.o/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

type Accounts []*Account

const __sqlAccount_Table = "account"
const __sqlAccount_ListCols = "\"id\",\"owner_id\",\"name\",\"type\",\"image_url\",\"url_slug\",\"rid\""
const __sqlAccount_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"name\" = EXCLUDED.\"name\",\"type\" = EXCLUDED.\"type\",\"image_url\" = EXCLUDED.\"image_url\",\"url_slug\" = EXCLUDED.\"url_slug\",\"rid\" = EXCLUDED.\"rid\""
const __sqlAccount_Insert = "INSERT INTO \"account\" (" + __sqlAccount_ListCols + ") VALUES"
const __sqlAccount_Select = "SELECT " + __sqlAccount_ListCols + " FROM \"account\""
const __sqlAccount_Select_history = "SELECT " + __sqlAccount_ListCols + " FROM history.\"account\""
const __sqlAccount_UpdateAll = "UPDATE \"account\" SET (" + __sqlAccount_ListCols + ")"
const __sqlAccount_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_pkey DO UPDATE SET"

func (m *Account) SQLTableName() string  { return "account" }
func (m *Accounts) SQLTableName() string { return "account" }
func (m *Account) SQLListCols() string   { return __sqlAccount_ListCols }

func (m *Account) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccount_ListCols + " FROM \"account\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Account) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "account"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"owner_id": {
			ColumnName:       "owner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"type": {
			ColumnName:       "type",
			ColumnType:       "account_type.AccountType",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "partner", "shop", "affiliate", "carrier", "etop"},
		},
		"image_url": {
			ColumnName:       "image_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"url_slug": {
			ColumnName:       "url_slug",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"rid": {
			ColumnName:       "rid",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "account", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Account)(nil))
}

func (m *Account) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Name),
		m.Type,
		core.String(m.ImageURL),
		core.String(m.URLSlug),
		m.Rid,
	}
}

func (m *Account) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Name),
		&m.Type,
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.URLSlug),
		&m.Rid,
	}
}

func (m *Account) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Accounts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Accounts, 0, 128)
	for rows.Next() {
		m := new(Account)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Account) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (_ *Accounts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (m *Account) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Accounts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(7)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Account) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccount_ListColsOnConflict)
	return nil
}

func (ms Accounts) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccount_ListColsOnConflict)
	return nil
}

func (m *Account) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Type != 0 {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.URLSlug != "" {
		flag = true
		w.WriteName("url_slug")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.URLSlug)
	}
	if m.Rid != 0 {
		flag = true
		w.WriteName("rid")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Rid)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Account) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountHistory map[string]interface{}
type AccountHistories []map[string]interface{}

func (m *AccountHistory) SQLTableName() string  { return "history.\"account\"" }
func (m AccountHistories) SQLTableName() string { return "history.\"account\"" }

func (m *AccountHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m AccountHistory) OwnerID() core.Interface  { return core.Interface{m["owner_id"]} }
func (m AccountHistory) Name() core.Interface     { return core.Interface{m["name"]} }
func (m AccountHistory) Type() core.Interface     { return core.Interface{m["type"]} }
func (m AccountHistory) ImageURL() core.Interface { return core.Interface{m["image_url"]} }
func (m AccountHistory) URLSlug() core.Interface  { return core.Interface{m["url_slug"]} }
func (m AccountHistory) Rid() core.Interface      { return core.Interface{m["rid"]} }

func (m *AccountHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountHistory, 7)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["name"] = data[2]
	res["type"] = data[3]
	res["image_url"] = data[4]
	res["url_slug"] = data[5]
	res["rid"] = data[6]
	*m = res
	return nil
}

func (ms *AccountHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	res := make(AccountHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["name"] = data[2]
		m["type"] = data[3]
		m["image_url"] = data[4]
		m["url_slug"] = data[5]
		m["rid"] = data[6]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type AccountAuths []*AccountAuth

const __sqlAccountAuth_Table = "account_auth"
const __sqlAccountAuth_ListCols = "\"auth_key\",\"account_id\",\"status\",\"roles\",\"permissions\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlAccountAuth_ListColsOnConflict = "\"auth_key\" = EXCLUDED.\"auth_key\",\"account_id\" = EXCLUDED.\"account_id\",\"status\" = EXCLUDED.\"status\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlAccountAuth_Insert = "INSERT INTO \"account_auth\" (" + __sqlAccountAuth_ListCols + ") VALUES"
const __sqlAccountAuth_Select = "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\""
const __sqlAccountAuth_Select_history = "SELECT " + __sqlAccountAuth_ListCols + " FROM history.\"account_auth\""
const __sqlAccountAuth_UpdateAll = "UPDATE \"account_auth\" SET (" + __sqlAccountAuth_ListCols + ")"
const __sqlAccountAuth_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_auth_pkey DO UPDATE SET"

func (m *AccountAuth) SQLTableName() string  { return "account_auth" }
func (m *AccountAuths) SQLTableName() string { return "account_auth" }
func (m *AccountAuth) SQLListCols() string   { return __sqlAccountAuth_ListCols }

func (m *AccountAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *AccountAuth) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "account_auth"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"auth_key": {
			ColumnName:       "auth_key",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"roles": {
			ColumnName:       "roles",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"permissions": {
			ColumnName:       "permissions",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "account_auth", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountAuth)(nil))
}

func (m *AccountAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.AccountID,
		m.Status,
		core.Array{m.Roles, opts},
		core.Array{m.Permissions, opts},
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.AccountID,
		&m.Status,
		core.Array{&m.Roles, opts},
		core.Array{&m.Permissions, opts},
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuths, 0, 128)
	for rows.Next() {
		m := new(AccountAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (_ *AccountAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (m *AccountAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(8)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountAuth) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountAuth_ListColsOnConflict)
	return nil
}

func (ms AccountAuths) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountAuth_ListColsOnConflict)
	return nil
}

func (m *AccountAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_auth")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Roles, opts})
	}
	if m.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permissions, opts})
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountAuthHistory map[string]interface{}
type AccountAuthHistories []map[string]interface{}

func (m *AccountAuthHistory) SQLTableName() string  { return "history.\"account_auth\"" }
func (m AccountAuthHistories) SQLTableName() string { return "history.\"account_auth\"" }

func (m *AccountAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistory) AuthKey() core.Interface     { return core.Interface{m["auth_key"]} }
func (m AccountAuthHistory) AccountID() core.Interface   { return core.Interface{m["account_id"]} }
func (m AccountAuthHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m AccountAuthHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountAuthHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountAuthHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountAuthHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountAuthHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }

func (m *AccountAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountAuthHistory, 8)
	res["auth_key"] = data[0]
	res["account_id"] = data[1]
	res["status"] = data[2]
	res["roles"] = data[3]
	res["permissions"] = data[4]
	res["created_at"] = data[5]
	res["updated_at"] = data[6]
	res["deleted_at"] = data[7]
	*m = res
	return nil
}

func (ms *AccountAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	res := make(AccountAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountAuthHistory)
		m["auth_key"] = data[0]
		m["account_id"] = data[1]
		m["status"] = data[2]
		m["roles"] = data[3]
		m["permissions"] = data[4]
		m["created_at"] = data[5]
		m["updated_at"] = data[6]
		m["deleted_at"] = data[7]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type AccountAuthFtPartners []*AccountAuthFtPartner

func (m *AccountAuthFtPartner) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtPartners) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtPartner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtPartners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtPartners, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtPartner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtPartner) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtPartner)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtPartner)(nil).__sqlJoin(w)
	return nil
}

func (m *AccountAuthFtPartners) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtPartner)(nil).SQLSelect(w)
}

func (m *AccountAuthFtPartner) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *AccountAuthFtPartners) SQLJoin(w SQLWriter) error {
	return (*AccountAuthFtPartner)(nil).SQLJoin(w)
}

func (m *AccountAuthFtPartner) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "aa", (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "p", (*Partner)(nil).SQLListCols())
}

func (m *AccountAuthFtPartner) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteName("aa")
	w.WriteRawString(" JOIN ")
	w.WriteName((*Partner)(nil).SQLTableName())
	w.WriteRawString(" AS p ON")
	w.WriteQueryString(" aa.account_id = p.id")
}

func (m *AccountAuthFtPartner) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Partner = new(Partner)
	args = append(args, m.Partner.SQLScanArgs(opts)...)
	return args
}

type AccountAuthFtShops []*AccountAuthFtShop

func (m *AccountAuthFtShop) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtShops) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtShops, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtShop) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtShop)(nil).__sqlJoin(w)
	return nil
}

func (m *AccountAuthFtShops) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtShop)(nil).SQLSelect(w)
}

func (m *AccountAuthFtShop) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *AccountAuthFtShops) SQLJoin(w SQLWriter) error {
	return (*AccountAuthFtShop)(nil).SQLJoin(w)
}

func (m *AccountAuthFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "aa", (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "s", (*Shop)(nil).SQLListCols())
}

func (m *AccountAuthFtShop) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteName("aa")
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS s ON")
	w.WriteQueryString(" aa.account_id = s.id")
}

func (m *AccountAuthFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	return args
}

type AccountUsers []*AccountUser

const __sqlAccountUser_Table = "account_user"
const __sqlAccountUser_ListCols = "\"account_id\",\"user_id\",\"status\",\"response_status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\",\"full_name\",\"short_name\",\"position\",\"invitation_sent_at\",\"invitation_sent_by\",\"invitation_accepted_at\",\"invitation_rejected_at\",\"disabled_at\",\"disabled_by\",\"disable_reason\",\"rid\""
const __sqlAccountUser_ListColsOnConflict = "\"account_id\" = EXCLUDED.\"account_id\",\"user_id\" = EXCLUDED.\"user_id\",\"status\" = EXCLUDED.\"status\",\"response_status\" = EXCLUDED.\"response_status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\",\"full_name\" = EXCLUDED.\"full_name\",\"short_name\" = EXCLUDED.\"short_name\",\"position\" = EXCLUDED.\"position\",\"invitation_sent_at\" = EXCLUDED.\"invitation_sent_at\",\"invitation_sent_by\" = EXCLUDED.\"invitation_sent_by\",\"invitation_accepted_at\" = EXCLUDED.\"invitation_accepted_at\",\"invitation_rejected_at\" = EXCLUDED.\"invitation_rejected_at\",\"disabled_at\" = EXCLUDED.\"disabled_at\",\"disabled_by\" = EXCLUDED.\"disabled_by\",\"disable_reason\" = EXCLUDED.\"disable_reason\",\"rid\" = EXCLUDED.\"rid\""
const __sqlAccountUser_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUser_ListCols + ") VALUES"
const __sqlAccountUser_Select = "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\""
const __sqlAccountUser_Select_history = "SELECT " + __sqlAccountUser_ListCols + " FROM history.\"account_user\""
const __sqlAccountUser_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUser_ListCols + ")"
const __sqlAccountUser_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_user_pkey DO UPDATE SET"

func (m *AccountUser) SQLTableName() string  { return "account_user" }
func (m *AccountUsers) SQLTableName() string { return "account_user" }
func (m *AccountUser) SQLListCols() string   { return __sqlAccountUser_ListCols }

func (m *AccountUser) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *AccountUser) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "account_user"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"user_id": {
			ColumnName:       "user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"response_status": {
			ColumnName:       "response_status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"roles": {
			ColumnName:       "roles",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"permissions": {
			ColumnName:       "permissions",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"full_name": {
			ColumnName:       "full_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"short_name": {
			ColumnName:       "short_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"position": {
			ColumnName:       "position",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"invitation_sent_at": {
			ColumnName:       "invitation_sent_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"invitation_sent_by": {
			ColumnName:       "invitation_sent_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"invitation_accepted_at": {
			ColumnName:       "invitation_accepted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"invitation_rejected_at": {
			ColumnName:       "invitation_rejected_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"disabled_at": {
			ColumnName:       "disabled_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"disabled_by": {
			ColumnName:       "disabled_by",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"disable_reason": {
			ColumnName:       "disable_reason",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"rid": {
			ColumnName:       "rid",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "account_user", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUser)(nil))
}

func (m *AccountUser) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.AccountID,
		m.UserID,
		m.Status,
		m.ResponseStatus,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
		core.String(m.FullName),
		core.String(m.ShortName),
		core.String(m.Position),
		core.Time(m.InvitationSentAt),
		m.InvitationSentBy,
		core.Time(m.InvitationAcceptedAt),
		core.Time(m.InvitationRejectedAt),
		core.Time(m.DisabledAt),
		core.Time(m.DisabledBy),
		core.String(m.DisableReason),
		m.Rid,
	}
}

func (m *AccountUser) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.AccountID,
		&m.UserID,
		&m.Status,
		&m.ResponseStatus,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
		(*core.String)(&m.FullName),
		(*core.String)(&m.ShortName),
		(*core.String)(&m.Position),
		(*core.Time)(&m.InvitationSentAt),
		&m.InvitationSentBy,
		(*core.Time)(&m.InvitationAcceptedAt),
		(*core.Time)(&m.InvitationRejectedAt),
		(*core.Time)(&m.DisabledAt),
		(*core.Time)(&m.DisabledBy),
		(*core.String)(&m.DisableReason),
		&m.Rid,
	}
}

func (m *AccountUser) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUsers) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUsers, 0, 128)
	for rows.Next() {
		m := new(AccountUser)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUser) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (_ *AccountUsers) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (m *AccountUser) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUsers) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(20)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUser) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUser_ListColsOnConflict)
	return nil
}

func (ms AccountUsers) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUser_ListColsOnConflict)
	return nil
}

func (m *AccountUser) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.ResponseStatus != 0 {
		flag = true
		w.WriteName("response_status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ResponseStatus)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if m.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FullName)
	}
	if m.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShortName)
	}
	if m.Position != "" {
		flag = true
		w.WriteName("position")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Position)
	}
	if !m.InvitationSentAt.IsZero() {
		flag = true
		w.WriteName("invitation_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentAt)
	}
	if m.InvitationSentBy != 0 {
		flag = true
		w.WriteName("invitation_sent_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentBy)
	}
	if !m.InvitationAcceptedAt.IsZero() {
		flag = true
		w.WriteName("invitation_accepted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationAcceptedAt)
	}
	if !m.InvitationRejectedAt.IsZero() {
		flag = true
		w.WriteName("invitation_rejected_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationRejectedAt)
	}
	if !m.DisabledAt.IsZero() {
		flag = true
		w.WriteName("disabled_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledAt)
	}
	if !m.DisabledBy.IsZero() {
		flag = true
		w.WriteName("disabled_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledBy)
	}
	if m.DisableReason != "" {
		flag = true
		w.WriteName("disable_reason")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisableReason)
	}
	if m.Rid != 0 {
		flag = true
		w.WriteName("rid")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Rid)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUser) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserHistory map[string]interface{}
type AccountUserHistories []map[string]interface{}

func (m *AccountUserHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m AccountUserHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m AccountUserHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m AccountUserHistory) ResponseStatus() core.Interface {
	return core.Interface{m["response_status"]}
}
func (m AccountUserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountUserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountUserHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m AccountUserHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountUserHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountUserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m AccountUserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m AccountUserHistory) Position() core.Interface    { return core.Interface{m["position"]} }
func (m AccountUserHistory) InvitationSentAt() core.Interface {
	return core.Interface{m["invitation_sent_at"]}
}
func (m AccountUserHistory) InvitationSentBy() core.Interface {
	return core.Interface{m["invitation_sent_by"]}
}
func (m AccountUserHistory) InvitationAcceptedAt() core.Interface {
	return core.Interface{m["invitation_accepted_at"]}
}
func (m AccountUserHistory) InvitationRejectedAt() core.Interface {
	return core.Interface{m["invitation_rejected_at"]}
}
func (m AccountUserHistory) DisabledAt() core.Interface { return core.Interface{m["disabled_at"]} }
func (m AccountUserHistory) DisabledBy() core.Interface { return core.Interface{m["disabled_by"]} }
func (m AccountUserHistory) DisableReason() core.Interface {
	return core.Interface{m["disable_reason"]}
}
func (m AccountUserHistory) Rid() core.Interface { return core.Interface{m["rid"]} }

func (m *AccountUserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserHistory, 20)
	res["account_id"] = data[0]
	res["user_id"] = data[1]
	res["status"] = data[2]
	res["response_status"] = data[3]
	res["created_at"] = data[4]
	res["updated_at"] = data[5]
	res["deleted_at"] = data[6]
	res["roles"] = data[7]
	res["permissions"] = data[8]
	res["full_name"] = data[9]
	res["short_name"] = data[10]
	res["position"] = data[11]
	res["invitation_sent_at"] = data[12]
	res["invitation_sent_by"] = data[13]
	res["invitation_accepted_at"] = data[14]
	res["invitation_rejected_at"] = data[15]
	res["disabled_at"] = data[16]
	res["disabled_by"] = data[17]
	res["disable_reason"] = data[18]
	res["rid"] = data[19]
	*m = res
	return nil
}

func (ms *AccountUserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserHistory)
		m["account_id"] = data[0]
		m["user_id"] = data[1]
		m["status"] = data[2]
		m["response_status"] = data[3]
		m["created_at"] = data[4]
		m["updated_at"] = data[5]
		m["deleted_at"] = data[6]
		m["roles"] = data[7]
		m["permissions"] = data[8]
		m["full_name"] = data[9]
		m["short_name"] = data[10]
		m["position"] = data[11]
		m["invitation_sent_at"] = data[12]
		m["invitation_sent_by"] = data[13]
		m["invitation_accepted_at"] = data[14]
		m["invitation_rejected_at"] = data[15]
		m["disabled_at"] = data[16]
		m["disabled_by"] = data[17]
		m["disable_reason"] = data[18]
		m["rid"] = data[19]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// AccountUserDelete is a substruct of AccountUserfunc substructAccountUserDelete(_ AccountUserDelete, _ AccountUser) bool { return true }func CcountUserDeletesFromCcountUsers(ps []AccountUser) []AccountUserDelete {	ss := make([]AccountUserDelete, len(ps))	for i, p := range ps {		ss[i] = NewCcountUserDeleteFromCcountUser(p)	}	return ss}func CcountUserDeletesToCcountUsers(ss []AccountUserDelete) []AccountUser {	ps := make([]AccountUser, len(ss))	for i, s := range ss {		ps[i] = s.ToccountUser()	}	return ps}func NewCcountUserDeleteFromCcountUser(sp AccountUser) AccountUserDelete {	if sp == nil {\t\treturn nil	}	s := new(ccountUserDelete)	s.CopyFrom(sp)	return s}func (s AccountUserDelete) ToCcountUser() AccountUser {	if s == nil {		return nil	}	sp := new(ccountUser)	s.AssignTo(sp)	return sp}func (s AccountUserDelete) CopyFrom(sp AccountUser) {	s.DeletedAt = sp.DeletedAt}func (s AccountUserDelete) AssignTo(sp AccountUser) {	sp.DeletedAt = s.DeletedAt}
type AccountUserDeletes []*AccountUserDelete

const __sqlAccountUserDelete_Table = "account_user"
const __sqlAccountUserDelete_ListCols = "\"deleted_at\""
const __sqlAccountUserDelete_ListColsOnConflict = "\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlAccountUserDelete_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUserDelete_ListCols + ") VALUES"
const __sqlAccountUserDelete_Select = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\""
const __sqlAccountUserDelete_Select_history = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM history.\"account_user\""
const __sqlAccountUserDelete_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUserDelete_ListCols + ")"
const __sqlAccountUserDelete_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT account_user_pkey DO UPDATE SET"

func (m *AccountUserDelete) SQLTableName() string  { return "account_user" }
func (m *AccountUserDeletes) SQLTableName() string { return "account_user" }
func (m *AccountUserDelete) SQLListCols() string   { return __sqlAccountUserDelete_ListCols }

func (m *AccountUserDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *AccountUserDelete) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "account_user"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "account_user", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUserDelete)(nil))
}

func (m *AccountUserDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserDeletes, 0, 128)
	for rows.Next() {
		m := new(AccountUserDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUserDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (_ *AccountUserDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (m *AccountUserDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUserDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUserDelete) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUserDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUserDelete_ListColsOnConflict)
	return nil
}

func (ms AccountUserDeletes) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAccountUserDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAccountUserDelete_ListColsOnConflict)
	return nil
}

func (m *AccountUserDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUserDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserDeleteHistory map[string]interface{}
type AccountUserDeleteHistories []map[string]interface{}

func (m *AccountUserDeleteHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserDeleteHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *AccountUserDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *AccountUserDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type AccountUserExtendeds []*AccountUserExtended

func (m *AccountUserExtended) SQLTableName() string  { return "account_user" }
func (m *AccountUserExtendeds) SQLTableName() string { return "account_user" }

func (m *AccountUserExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserExtendeds, 0, 128)
	for rows.Next() {
		m := new(AccountUserExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountUserExtended) SQLSelect(w SQLWriter) error {
	(*AccountUserExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountUserExtended)(nil).__sqlJoin(w)
	return nil
}

func (m *AccountUserExtendeds) SQLSelect(w SQLWriter) error {
	return (*AccountUserExtended)(nil).SQLSelect(w)
}

func (m *AccountUserExtended) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *AccountUserExtendeds) SQLJoin(w SQLWriter) error {
	return (*AccountUserExtended)(nil).SQLJoin(w)
}

func (m *AccountUserExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "au", (*AccountUser)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "a", (*Account)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "u", (*User)(nil).SQLListCols())
}

func (m *AccountUserExtended) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("account_user")
	w.WriteRawString(" AS ")
	w.WriteName("au")
	w.WriteRawString(" JOIN ")
	w.WriteName((*Account)(nil).SQLTableName())
	w.WriteRawString(" AS a ON")
	w.WriteQueryString(" au.account_id = a.id")
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS u ON")
	w.WriteQueryString(" au.user_id = u.id")
}

func (m *AccountUserExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountUser = new(AccountUser)
	args = append(args, m.AccountUser.SQLScanArgs(opts)...)
	m.Account = new(Account)
	args = append(args, m.Account.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	return args
}

type Affiliates []*Affiliate

const __sqlAffiliate_Table = "affiliate"
const __sqlAffiliate_ListCols = "\"id\",\"owner_id\",\"name\",\"phone\",\"email\",\"is_test\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"bank_account\""
const __sqlAffiliate_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"name\" = EXCLUDED.\"name\",\"phone\" = EXCLUDED.\"phone\",\"email\" = EXCLUDED.\"email\",\"is_test\" = EXCLUDED.\"is_test\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"bank_account\" = EXCLUDED.\"bank_account\""
const __sqlAffiliate_Insert = "INSERT INTO \"affiliate\" (" + __sqlAffiliate_ListCols + ") VALUES"
const __sqlAffiliate_Select = "SELECT " + __sqlAffiliate_ListCols + " FROM \"affiliate\""
const __sqlAffiliate_Select_history = "SELECT " + __sqlAffiliate_ListCols + " FROM history.\"affiliate\""
const __sqlAffiliate_UpdateAll = "UPDATE \"affiliate\" SET (" + __sqlAffiliate_ListCols + ")"
const __sqlAffiliate_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT affiliate_pkey DO UPDATE SET"

func (m *Affiliate) SQLTableName() string  { return "affiliate" }
func (m *Affiliates) SQLTableName() string { return "affiliate" }
func (m *Affiliate) SQLListCols() string   { return __sqlAffiliate_ListCols }

func (m *Affiliate) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAffiliate_ListCols + " FROM \"affiliate\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Affiliate) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "affiliate"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"owner_id": {
			ColumnName:       "owner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone": {
			ColumnName:       "phone",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email": {
			ColumnName:       "email",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"is_test": {
			ColumnName:       "is_test",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"bank_account": {
			ColumnName:       "bank_account",
			ColumnType:       "*sharemodel.BankAccount",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "affiliate", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Affiliate)(nil))
}

func (m *Affiliate) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Name),
		core.String(m.Phone),
		core.String(m.Email),
		core.Int(m.IsTest),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.JSON{m.BankAccount},
	}
}

func (m *Affiliate) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Name),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Email),
		(*core.Int)(&m.IsTest),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.JSON{&m.BankAccount},
	}
}

func (m *Affiliate) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Affiliates) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Affiliates, 0, 128)
	for rows.Next() {
		m := new(Affiliate)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Affiliate) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select)
	return nil
}

func (_ *Affiliates) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select)
	return nil
}

func (m *Affiliate) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Affiliates) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(11)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Affiliate) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlAffiliate_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAffiliate_ListColsOnConflict)
	return nil
}

func (ms Affiliates) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlAffiliate_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlAffiliate_ListColsOnConflict)
	return nil
}

func (m *Affiliate) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("affiliate")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.BankAccount != nil {
		flag = true
		w.WriteName("bank_account")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.BankAccount})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Affiliate) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(11)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AffiliateHistory map[string]interface{}
type AffiliateHistories []map[string]interface{}

func (m *AffiliateHistory) SQLTableName() string  { return "history.\"affiliate\"" }
func (m AffiliateHistories) SQLTableName() string { return "history.\"affiliate\"" }

func (m *AffiliateHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select_history)
	return nil
}

func (m AffiliateHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAffiliate_Select_history)
	return nil
}

func (m AffiliateHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m AffiliateHistory) OwnerID() core.Interface     { return core.Interface{m["owner_id"]} }
func (m AffiliateHistory) Name() core.Interface        { return core.Interface{m["name"]} }
func (m AffiliateHistory) Phone() core.Interface       { return core.Interface{m["phone"]} }
func (m AffiliateHistory) Email() core.Interface       { return core.Interface{m["email"]} }
func (m AffiliateHistory) IsTest() core.Interface      { return core.Interface{m["is_test"]} }
func (m AffiliateHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m AffiliateHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AffiliateHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AffiliateHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m AffiliateHistory) BankAccount() core.Interface { return core.Interface{m["bank_account"]} }

func (m *AffiliateHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AffiliateHistory, 11)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["name"] = data[2]
	res["phone"] = data[3]
	res["email"] = data[4]
	res["is_test"] = data[5]
	res["status"] = data[6]
	res["created_at"] = data[7]
	res["updated_at"] = data[8]
	res["deleted_at"] = data[9]
	res["bank_account"] = data[10]
	*m = res
	return nil
}

func (ms *AffiliateHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 11)
	args := make([]interface{}, 11)
	for i := 0; i < 11; i++ {
		args[i] = &data[i]
	}
	res := make(AffiliateHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AffiliateHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["name"] = data[2]
		m["phone"] = data[3]
		m["email"] = data[4]
		m["is_test"] = data[5]
		m["status"] = data[6]
		m["created_at"] = data[7]
		m["updated_at"] = data[8]
		m["deleted_at"] = data[9]
		m["bank_account"] = data[10]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type Partners []*Partner

const __sqlPartner_Table = "partner"
const __sqlPartner_ListCols = "\"id\",\"owner_id\",\"status\",\"is_test\",\"name\",\"public_name\",\"phone\",\"email\",\"image_url\",\"website_url\",\"contact_persons\",\"recognized_hosts\",\"redirect_urls\",\"available_from_etop\",\"available_from_etop_config\",\"white_label_key\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlPartner_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"status\" = EXCLUDED.\"status\",\"is_test\" = EXCLUDED.\"is_test\",\"name\" = EXCLUDED.\"name\",\"public_name\" = EXCLUDED.\"public_name\",\"phone\" = EXCLUDED.\"phone\",\"email\" = EXCLUDED.\"email\",\"image_url\" = EXCLUDED.\"image_url\",\"website_url\" = EXCLUDED.\"website_url\",\"contact_persons\" = EXCLUDED.\"contact_persons\",\"recognized_hosts\" = EXCLUDED.\"recognized_hosts\",\"redirect_urls\" = EXCLUDED.\"redirect_urls\",\"available_from_etop\" = EXCLUDED.\"available_from_etop\",\"available_from_etop_config\" = EXCLUDED.\"available_from_etop_config\",\"white_label_key\" = EXCLUDED.\"white_label_key\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlPartner_Insert = "INSERT INTO \"partner\" (" + __sqlPartner_ListCols + ") VALUES"
const __sqlPartner_Select = "SELECT " + __sqlPartner_ListCols + " FROM \"partner\""
const __sqlPartner_Select_history = "SELECT " + __sqlPartner_ListCols + " FROM history.\"partner\""
const __sqlPartner_UpdateAll = "UPDATE \"partner\" SET (" + __sqlPartner_ListCols + ")"
const __sqlPartner_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT partner_pkey DO UPDATE SET"

func (m *Partner) SQLTableName() string  { return "partner" }
func (m *Partners) SQLTableName() string { return "partner" }
func (m *Partner) SQLListCols() string   { return __sqlPartner_ListCols }

func (m *Partner) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartner_ListCols + " FROM \"partner\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Partner) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "partner"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"owner_id": {
			ColumnName:       "owner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"is_test": {
			ColumnName:       "is_test",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"public_name": {
			ColumnName:       "public_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone": {
			ColumnName:       "phone",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email": {
			ColumnName:       "email",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"image_url": {
			ColumnName:       "image_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"website_url": {
			ColumnName:       "website_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"contact_persons": {
			ColumnName:       "contact_persons",
			ColumnType:       "[]*sharemodel.ContactPerson",
			ColumnDBType:     "[]*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"recognized_hosts": {
			ColumnName:       "recognized_hosts",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"redirect_urls": {
			ColumnName:       "redirect_urls",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"available_from_etop": {
			ColumnName:       "available_from_etop",
			ColumnType:       "bool",
			ColumnDBType:     "bool",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"available_from_etop_config": {
			ColumnName:       "available_from_etop_config",
			ColumnType:       "*AvailableFromEtopConfig",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"white_label_key": {
			ColumnName:       "white_label_key",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "partner", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Partner)(nil))
}

func (m *Partner) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		m.Status,
		core.Int(m.IsTest),
		core.String(m.Name),
		core.String(m.PublicName),
		core.String(m.Phone),
		core.String(m.Email),
		core.String(m.ImageURL),
		core.String(m.WebsiteURL),
		core.JSON{m.ContactPersons},
		core.Array{m.RecognizedHosts, opts},
		core.Array{m.RedirectURLs, opts},
		core.Bool(m.AvailableFromEtop),
		core.JSON{m.AvailableFromEtopConfig},
		core.String(m.WhiteLabelKey),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *Partner) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		&m.Status,
		(*core.Int)(&m.IsTest),
		(*core.String)(&m.Name),
		(*core.String)(&m.PublicName),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Email),
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.WebsiteURL),
		core.JSON{&m.ContactPersons},
		core.Array{&m.RecognizedHosts, opts},
		core.Array{&m.RedirectURLs, opts},
		(*core.Bool)(&m.AvailableFromEtop),
		core.JSON{&m.AvailableFromEtopConfig},
		(*core.String)(&m.WhiteLabelKey),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *Partner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Partners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Partners, 0, 128)
	for rows.Next() {
		m := new(Partner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Partner) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (_ *Partners) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (m *Partner) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Partners) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(19)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Partner) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlPartner_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartner_ListColsOnConflict)
	return nil
}

func (ms Partners) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlPartner_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartner_ListColsOnConflict)
	return nil
}

func (m *Partner) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.PublicName != "" {
		flag = true
		w.WriteName("public_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PublicName)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ContactPersons != nil {
		flag = true
		w.WriteName("contact_persons")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ContactPersons})
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.RedirectURLs != nil {
		flag = true
		w.WriteName("redirect_urls")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RedirectURLs, opts})
	}
	if m.AvailableFromEtop {
		flag = true
		w.WriteName("available_from_etop")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AvailableFromEtop)
	}
	if m.AvailableFromEtopConfig != nil {
		flag = true
		w.WriteName("available_from_etop_config")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.AvailableFromEtopConfig})
	}
	if m.WhiteLabelKey != "" {
		flag = true
		w.WriteName("white_label_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WhiteLabelKey)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Partner) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerHistory map[string]interface{}
type PartnerHistories []map[string]interface{}

func (m *PartnerHistory) SQLTableName() string  { return "history.\"partner\"" }
func (m PartnerHistories) SQLTableName() string { return "history.\"partner\"" }

func (m *PartnerHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistory) ID() core.Interface             { return core.Interface{m["id"]} }
func (m PartnerHistory) OwnerID() core.Interface        { return core.Interface{m["owner_id"]} }
func (m PartnerHistory) Status() core.Interface         { return core.Interface{m["status"]} }
func (m PartnerHistory) IsTest() core.Interface         { return core.Interface{m["is_test"]} }
func (m PartnerHistory) Name() core.Interface           { return core.Interface{m["name"]} }
func (m PartnerHistory) PublicName() core.Interface     { return core.Interface{m["public_name"]} }
func (m PartnerHistory) Phone() core.Interface          { return core.Interface{m["phone"]} }
func (m PartnerHistory) Email() core.Interface          { return core.Interface{m["email"]} }
func (m PartnerHistory) ImageURL() core.Interface       { return core.Interface{m["image_url"]} }
func (m PartnerHistory) WebsiteURL() core.Interface     { return core.Interface{m["website_url"]} }
func (m PartnerHistory) ContactPersons() core.Interface { return core.Interface{m["contact_persons"]} }
func (m PartnerHistory) RecognizedHosts() core.Interface {
	return core.Interface{m["recognized_hosts"]}
}
func (m PartnerHistory) RedirectURLs() core.Interface { return core.Interface{m["redirect_urls"]} }
func (m PartnerHistory) AvailableFromEtop() core.Interface {
	return core.Interface{m["available_from_etop"]}
}
func (m PartnerHistory) AvailableFromEtopConfig() core.Interface {
	return core.Interface{m["available_from_etop_config"]}
}
func (m PartnerHistory) WhiteLabelKey() core.Interface { return core.Interface{m["white_label_key"]} }
func (m PartnerHistory) CreatedAt() core.Interface     { return core.Interface{m["created_at"]} }
func (m PartnerHistory) UpdatedAt() core.Interface     { return core.Interface{m["updated_at"]} }
func (m PartnerHistory) DeletedAt() core.Interface     { return core.Interface{m["deleted_at"]} }

func (m *PartnerHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerHistory, 19)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["status"] = data[2]
	res["is_test"] = data[3]
	res["name"] = data[4]
	res["public_name"] = data[5]
	res["phone"] = data[6]
	res["email"] = data[7]
	res["image_url"] = data[8]
	res["website_url"] = data[9]
	res["contact_persons"] = data[10]
	res["recognized_hosts"] = data[11]
	res["redirect_urls"] = data[12]
	res["available_from_etop"] = data[13]
	res["available_from_etop_config"] = data[14]
	res["white_label_key"] = data[15]
	res["created_at"] = data[16]
	res["updated_at"] = data[17]
	res["deleted_at"] = data[18]
	*m = res
	return nil
}

func (ms *PartnerHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["status"] = data[2]
		m["is_test"] = data[3]
		m["name"] = data[4]
		m["public_name"] = data[5]
		m["phone"] = data[6]
		m["email"] = data[7]
		m["image_url"] = data[8]
		m["website_url"] = data[9]
		m["contact_persons"] = data[10]
		m["recognized_hosts"] = data[11]
		m["redirect_urls"] = data[12]
		m["available_from_etop"] = data[13]
		m["available_from_etop_config"] = data[14]
		m["white_label_key"] = data[15]
		m["created_at"] = data[16]
		m["updated_at"] = data[17]
		m["deleted_at"] = data[18]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type PartnerRelations []*PartnerRelation

const __sqlPartnerRelation_Table = "partner_relation"
const __sqlPartnerRelation_ListCols = "\"auth_key\",\"partner_id\",\"subject_id\",\"subject_type\",\"external_subject_id\",\"nonce\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\""
const __sqlPartnerRelation_ListColsOnConflict = "\"auth_key\" = EXCLUDED.\"auth_key\",\"partner_id\" = EXCLUDED.\"partner_id\",\"subject_id\" = EXCLUDED.\"subject_id\",\"subject_type\" = EXCLUDED.\"subject_type\",\"external_subject_id\" = EXCLUDED.\"external_subject_id\",\"nonce\" = EXCLUDED.\"nonce\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"roles\" = EXCLUDED.\"roles\",\"permissions\" = EXCLUDED.\"permissions\""
const __sqlPartnerRelation_Insert = "INSERT INTO \"partner_relation\" (" + __sqlPartnerRelation_ListCols + ") VALUES"
const __sqlPartnerRelation_Select = "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\""
const __sqlPartnerRelation_Select_history = "SELECT " + __sqlPartnerRelation_ListCols + " FROM history.\"partner_relation\""
const __sqlPartnerRelation_UpdateAll = "UPDATE \"partner_relation\" SET (" + __sqlPartnerRelation_ListCols + ")"
const __sqlPartnerRelation_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT partner_relation_pkey DO UPDATE SET"

func (m *PartnerRelation) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelations) SQLTableName() string { return "partner_relation" }
func (m *PartnerRelation) SQLListCols() string   { return __sqlPartnerRelation_ListCols }

func (m *PartnerRelation) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *PartnerRelation) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "partner_relation"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"auth_key": {
			ColumnName:       "auth_key",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"partner_id": {
			ColumnName:       "partner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"subject_id": {
			ColumnName:       "subject_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"subject_type": {
			ColumnName:       "subject_type",
			ColumnType:       "SubjectType",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"external_subject_id": {
			ColumnName:       "external_subject_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"nonce": {
			ColumnName:       "nonce",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"roles": {
			ColumnName:       "roles",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"permissions": {
			ColumnName:       "permissions",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "partner_relation", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*PartnerRelation)(nil))
}

func (m *PartnerRelation) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.PartnerID,
		m.SubjectID,
		core.String(m.SubjectType),
		core.String(m.ExternalSubjectID),
		m.Nonce,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.PartnerID,
		&m.SubjectID,
		(*core.String)(&m.SubjectType),
		(*core.String)(&m.ExternalSubjectID),
		&m.Nonce,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelations) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelations, 0, 128)
	for rows.Next() {
		m := new(PartnerRelation)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *PartnerRelation) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (_ *PartnerRelations) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (m *PartnerRelation) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms PartnerRelations) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(12)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *PartnerRelation) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlPartnerRelation_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartnerRelation_ListColsOnConflict)
	return nil
}

func (ms PartnerRelations) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlPartnerRelation_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlPartnerRelation_ListColsOnConflict)
	return nil
}

func (m *PartnerRelation) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner_relation")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.PartnerID != 0 {
		flag = true
		w.WriteName("partner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PartnerID)
	}
	if m.SubjectID != 0 {
		flag = true
		w.WriteName("subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.SubjectID)
	}
	if m.SubjectType != "" {
		flag = true
		w.WriteName("subject_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.SubjectType))
	}
	if m.ExternalSubjectID != "" {
		flag = true
		w.WriteName("external_subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalSubjectID)
	}
	if m.Nonce != 0 {
		flag = true
		w.WriteName("nonce")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Nonce)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *PartnerRelation) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerRelationHistory map[string]interface{}
type PartnerRelationHistories []map[string]interface{}

func (m *PartnerRelationHistory) SQLTableName() string  { return "history.\"partner_relation\"" }
func (m PartnerRelationHistories) SQLTableName() string { return "history.\"partner_relation\"" }

func (m *PartnerRelationHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistory) AuthKey() core.Interface   { return core.Interface{m["auth_key"]} }
func (m PartnerRelationHistory) PartnerID() core.Interface { return core.Interface{m["partner_id"]} }
func (m PartnerRelationHistory) SubjectID() core.Interface { return core.Interface{m["subject_id"]} }
func (m PartnerRelationHistory) SubjectType() core.Interface {
	return core.Interface{m["subject_type"]}
}
func (m PartnerRelationHistory) ExternalSubjectID() core.Interface {
	return core.Interface{m["external_subject_id"]}
}
func (m PartnerRelationHistory) Nonce() core.Interface       { return core.Interface{m["nonce"]} }
func (m PartnerRelationHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m PartnerRelationHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m PartnerRelationHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m PartnerRelationHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m PartnerRelationHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m PartnerRelationHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }

func (m *PartnerRelationHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerRelationHistory, 12)
	res["auth_key"] = data[0]
	res["partner_id"] = data[1]
	res["subject_id"] = data[2]
	res["subject_type"] = data[3]
	res["external_subject_id"] = data[4]
	res["nonce"] = data[5]
	res["status"] = data[6]
	res["created_at"] = data[7]
	res["updated_at"] = data[8]
	res["deleted_at"] = data[9]
	res["roles"] = data[10]
	res["permissions"] = data[11]
	*m = res
	return nil
}

func (ms *PartnerRelationHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerRelationHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerRelationHistory)
		m["auth_key"] = data[0]
		m["partner_id"] = data[1]
		m["subject_id"] = data[2]
		m["subject_type"] = data[3]
		m["external_subject_id"] = data[4]
		m["nonce"] = data[5]
		m["status"] = data[6]
		m["created_at"] = data[7]
		m["updated_at"] = data[8]
		m["deleted_at"] = data[9]
		m["roles"] = data[10]
		m["permissions"] = data[11]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type PartnerRelationFtShops []*PartnerRelationFtShop

func (m *PartnerRelationFtShop) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelationFtShops) SQLTableName() string { return "partner_relation" }

func (m *PartnerRelationFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelationFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelationFtShops, 0, 128)
	for rows.Next() {
		m := new(PartnerRelationFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *PartnerRelationFtShop) SQLSelect(w SQLWriter) error {
	(*PartnerRelationFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*PartnerRelationFtShop)(nil).__sqlJoin(w)
	return nil
}

func (m *PartnerRelationFtShops) SQLSelect(w SQLWriter) error {
	return (*PartnerRelationFtShop)(nil).SQLSelect(w)
}

func (m *PartnerRelationFtShop) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *PartnerRelationFtShops) SQLJoin(w SQLWriter) error {
	return (*PartnerRelationFtShop)(nil).SQLJoin(w)
}

func (m *PartnerRelationFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "pr", (*PartnerRelation)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "s", (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "u", (*User)(nil).SQLListCols())
}

func (m *PartnerRelationFtShop) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("partner_relation")
	w.WriteRawString(" AS ")
	w.WriteName("pr")
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS s ON")
	w.WriteQueryString(" pr.subject_id = s.id")
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS u ON")
	w.WriteQueryString(" s.owner_id = u.id")
}

func (m *PartnerRelationFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.PartnerRelation = new(PartnerRelation)
	args = append(args, m.PartnerRelation.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	return args
}

type PartnerRelationFtUsers []*PartnerRelationFtUser

func (m *PartnerRelationFtUser) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelationFtUsers) SQLTableName() string { return "partner_relation" }

func (m *PartnerRelationFtUser) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelationFtUsers) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelationFtUsers, 0, 128)
	for rows.Next() {
		m := new(PartnerRelationFtUser)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *PartnerRelationFtUser) SQLSelect(w SQLWriter) error {
	(*PartnerRelationFtUser)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*PartnerRelationFtUser)(nil).__sqlJoin(w)
	return nil
}

func (m *PartnerRelationFtUsers) SQLSelect(w SQLWriter) error {
	return (*PartnerRelationFtUser)(nil).SQLSelect(w)
}

func (m *PartnerRelationFtUser) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *PartnerRelationFtUsers) SQLJoin(w SQLWriter) error {
	return (*PartnerRelationFtUser)(nil).SQLJoin(w)
}

func (m *PartnerRelationFtUser) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "pr", (*PartnerRelation)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "u", (*User)(nil).SQLListCols())
}

func (m *PartnerRelationFtUser) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("partner_relation")
	w.WriteRawString(" AS ")
	w.WriteName("pr")
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS u ON")
	w.WriteQueryString(" pr.subject_id = u.id")
}

func (m *PartnerRelationFtUser) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.PartnerRelation = new(PartnerRelation)
	args = append(args, m.PartnerRelation.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	return args
}

type Shops []*Shop

const __sqlShop_Table = "shop"
const __sqlShop_ListCols = "\"id\",\"owner_id\",\"is_test\",\"name\",\"address_id\",\"ship_to_address_id\",\"ship_from_address_id\",\"phone\",\"bank_account\",\"website_url\",\"image_url\",\"email\",\"code\",\"auto_create_ffm\",\"order_source_id\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"recognized_hosts\",\"ghn_note_code\",\"try_on\",\"company_info\",\"money_transaction_rrule\",\"survey_info\",\"shipping_service_select_strategy\",\"inventory_overstock\",\"wl_partner_id\",\"rid\""
const __sqlShop_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"owner_id\" = EXCLUDED.\"owner_id\",\"is_test\" = EXCLUDED.\"is_test\",\"name\" = EXCLUDED.\"name\",\"address_id\" = EXCLUDED.\"address_id\",\"ship_to_address_id\" = EXCLUDED.\"ship_to_address_id\",\"ship_from_address_id\" = EXCLUDED.\"ship_from_address_id\",\"phone\" = EXCLUDED.\"phone\",\"bank_account\" = EXCLUDED.\"bank_account\",\"website_url\" = EXCLUDED.\"website_url\",\"image_url\" = EXCLUDED.\"image_url\",\"email\" = EXCLUDED.\"email\",\"code\" = EXCLUDED.\"code\",\"auto_create_ffm\" = EXCLUDED.\"auto_create_ffm\",\"order_source_id\" = EXCLUDED.\"order_source_id\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"recognized_hosts\" = EXCLUDED.\"recognized_hosts\",\"ghn_note_code\" = EXCLUDED.\"ghn_note_code\",\"try_on\" = EXCLUDED.\"try_on\",\"company_info\" = EXCLUDED.\"company_info\",\"money_transaction_rrule\" = EXCLUDED.\"money_transaction_rrule\",\"survey_info\" = EXCLUDED.\"survey_info\",\"shipping_service_select_strategy\" = EXCLUDED.\"shipping_service_select_strategy\",\"inventory_overstock\" = EXCLUDED.\"inventory_overstock\",\"wl_partner_id\" = EXCLUDED.\"wl_partner_id\",\"rid\" = EXCLUDED.\"rid\""
const __sqlShop_Insert = "INSERT INTO \"shop\" (" + __sqlShop_ListCols + ") VALUES"
const __sqlShop_Select = "SELECT " + __sqlShop_ListCols + " FROM \"shop\""
const __sqlShop_Select_history = "SELECT " + __sqlShop_ListCols + " FROM history.\"shop\""
const __sqlShop_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShop_ListCols + ")"
const __sqlShop_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shop_pkey DO UPDATE SET"

func (m *Shop) SQLTableName() string  { return "shop" }
func (m *Shops) SQLTableName() string { return "shop" }
func (m *Shop) SQLListCols() string   { return __sqlShop_ListCols }

func (m *Shop) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShop_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Shop) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "shop"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"owner_id": {
			ColumnName:       "owner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"is_test": {
			ColumnName:       "is_test",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"address_id": {
			ColumnName:       "address_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ship_to_address_id": {
			ColumnName:       "ship_to_address_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ship_from_address_id": {
			ColumnName:       "ship_from_address_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone": {
			ColumnName:       "phone",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"bank_account": {
			ColumnName:       "bank_account",
			ColumnType:       "*sharemodel.BankAccount",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"website_url": {
			ColumnName:       "website_url",
			ColumnType:       "dot.NullString",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"image_url": {
			ColumnName:       "image_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email": {
			ColumnName:       "email",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"code": {
			ColumnName:       "code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"auto_create_ffm": {
			ColumnName:       "auto_create_ffm",
			ColumnType:       "bool",
			ColumnDBType:     "bool",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"order_source_id": {
			ColumnName:       "order_source_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"recognized_hosts": {
			ColumnName:       "recognized_hosts",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ghn_note_code": {
			ColumnName:       "ghn_note_code",
			ColumnType:       "ghn_note_code.GHNNoteCode",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "CHOTHUHANG", "CHOXEMHANGKHONGTHU", "KHONGCHOXEMHANG"},
		},
		"try_on": {
			ColumnName:       "try_on",
			ColumnType:       "try_on.TryOnCode",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "none", "open", "try"},
		},
		"company_info": {
			ColumnName:       "company_info",
			ColumnType:       "*sharemodel.CompanyInfo",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"money_transaction_rrule": {
			ColumnName:       "money_transaction_rrule",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"survey_info": {
			ColumnName:       "survey_info",
			ColumnType:       "[]*SurveyInfo",
			ColumnDBType:     "[]*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"shipping_service_select_strategy": {
			ColumnName:       "shipping_service_select_strategy",
			ColumnType:       "[]*ShippingServiceSelectStrategyItem",
			ColumnDBType:     "[]*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"inventory_overstock": {
			ColumnName:       "inventory_overstock",
			ColumnType:       "dot.NullBool",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"wl_partner_id": {
			ColumnName:       "wl_partner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"rid": {
			ColumnName:       "rid",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "shop", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Shop)(nil))
}

func (m *Shop) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.Int(m.IsTest),
		core.String(m.Name),
		m.AddressID,
		m.ShipToAddressID,
		m.ShipFromAddressID,
		core.String(m.Phone),
		core.JSON{m.BankAccount},
		m.WebsiteURL,
		core.String(m.ImageURL),
		core.String(m.Email),
		core.String(m.Code),
		core.Bool(m.AutoCreateFFM),
		m.OrderSourceID,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.RecognizedHosts, opts},
		m.GhnNoteCode,
		m.TryOn,
		core.JSON{m.CompanyInfo},
		core.String(m.MoneyTransactionRRule),
		core.JSON{m.SurveyInfo},
		core.JSON{m.ShippingServiceSelectStrategy},
		m.InventoryOverstock,
		m.WLPartnerID,
		m.Rid,
	}
}

func (m *Shop) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.Int)(&m.IsTest),
		(*core.String)(&m.Name),
		&m.AddressID,
		&m.ShipToAddressID,
		&m.ShipFromAddressID,
		(*core.String)(&m.Phone),
		core.JSON{&m.BankAccount},
		&m.WebsiteURL,
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.Email),
		(*core.String)(&m.Code),
		(*core.Bool)(&m.AutoCreateFFM),
		&m.OrderSourceID,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.RecognizedHosts, opts},
		&m.GhnNoteCode,
		&m.TryOn,
		core.JSON{&m.CompanyInfo},
		(*core.String)(&m.MoneyTransactionRRule),
		core.JSON{&m.SurveyInfo},
		core.JSON{&m.ShippingServiceSelectStrategy},
		&m.InventoryOverstock,
		&m.WLPartnerID,
		&m.Rid,
	}
}

func (m *Shop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Shops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Shops, 0, 128)
	for rows.Next() {
		m := new(Shop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Shop) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (_ *Shops) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (m *Shop) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(29)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Shops) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(29)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Shop) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShop_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShop_ListColsOnConflict)
	return nil
}

func (ms Shops) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShop_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShop_ListColsOnConflict)
	return nil
}

func (m *Shop) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.AddressID != 0 {
		flag = true
		w.WriteName("address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AddressID)
	}
	if m.ShipToAddressID != 0 {
		flag = true
		w.WriteName("ship_to_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipToAddressID)
	}
	if m.ShipFromAddressID != 0 {
		flag = true
		w.WriteName("ship_from_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipFromAddressID)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.BankAccount != nil {
		flag = true
		w.WriteName("bank_account")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.BankAccount})
	}
	if m.WebsiteURL.Valid {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.AutoCreateFFM {
		flag = true
		w.WriteName("auto_create_ffm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AutoCreateFFM)
	}
	if m.OrderSourceID != 0 {
		flag = true
		w.WriteName("order_source_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OrderSourceID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.GhnNoteCode != 0 {
		flag = true
		w.WriteName("ghn_note_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.GhnNoteCode)
	}
	if m.TryOn != 0 {
		flag = true
		w.WriteName("try_on")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TryOn)
	}
	if m.CompanyInfo != nil {
		flag = true
		w.WriteName("company_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.CompanyInfo})
	}
	if m.MoneyTransactionRRule != "" {
		flag = true
		w.WriteName("money_transaction_rrule")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.MoneyTransactionRRule)
	}
	if m.SurveyInfo != nil {
		flag = true
		w.WriteName("survey_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.SurveyInfo})
	}
	if m.ShippingServiceSelectStrategy != nil {
		flag = true
		w.WriteName("shipping_service_select_strategy")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ShippingServiceSelectStrategy})
	}
	if m.InventoryOverstock.Valid {
		flag = true
		w.WriteName("inventory_overstock")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InventoryOverstock)
	}
	if m.WLPartnerID != 0 {
		flag = true
		w.WriteName("wl_partner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WLPartnerID)
	}
	if m.Rid != 0 {
		flag = true
		w.WriteName("rid")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Rid)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Shop) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(29)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopHistory map[string]interface{}
type ShopHistories []map[string]interface{}

func (m *ShopHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistory) ID() core.Interface              { return core.Interface{m["id"]} }
func (m ShopHistory) OwnerID() core.Interface         { return core.Interface{m["owner_id"]} }
func (m ShopHistory) IsTest() core.Interface          { return core.Interface{m["is_test"]} }
func (m ShopHistory) Name() core.Interface            { return core.Interface{m["name"]} }
func (m ShopHistory) AddressID() core.Interface       { return core.Interface{m["address_id"]} }
func (m ShopHistory) ShipToAddressID() core.Interface { return core.Interface{m["ship_to_address_id"]} }
func (m ShopHistory) ShipFromAddressID() core.Interface {
	return core.Interface{m["ship_from_address_id"]}
}
func (m ShopHistory) Phone() core.Interface           { return core.Interface{m["phone"]} }
func (m ShopHistory) BankAccount() core.Interface     { return core.Interface{m["bank_account"]} }
func (m ShopHistory) WebsiteURL() core.Interface      { return core.Interface{m["website_url"]} }
func (m ShopHistory) ImageURL() core.Interface        { return core.Interface{m["image_url"]} }
func (m ShopHistory) Email() core.Interface           { return core.Interface{m["email"]} }
func (m ShopHistory) Code() core.Interface            { return core.Interface{m["code"]} }
func (m ShopHistory) AutoCreateFFM() core.Interface   { return core.Interface{m["auto_create_ffm"]} }
func (m ShopHistory) OrderSourceID() core.Interface   { return core.Interface{m["order_source_id"]} }
func (m ShopHistory) Status() core.Interface          { return core.Interface{m["status"]} }
func (m ShopHistory) CreatedAt() core.Interface       { return core.Interface{m["created_at"]} }
func (m ShopHistory) UpdatedAt() core.Interface       { return core.Interface{m["updated_at"]} }
func (m ShopHistory) DeletedAt() core.Interface       { return core.Interface{m["deleted_at"]} }
func (m ShopHistory) RecognizedHosts() core.Interface { return core.Interface{m["recognized_hosts"]} }
func (m ShopHistory) GhnNoteCode() core.Interface     { return core.Interface{m["ghn_note_code"]} }
func (m ShopHistory) TryOn() core.Interface           { return core.Interface{m["try_on"]} }
func (m ShopHistory) CompanyInfo() core.Interface     { return core.Interface{m["company_info"]} }
func (m ShopHistory) MoneyTransactionRRule() core.Interface {
	return core.Interface{m["money_transaction_rrule"]}
}
func (m ShopHistory) SurveyInfo() core.Interface { return core.Interface{m["survey_info"]} }
func (m ShopHistory) ShippingServiceSelectStrategy() core.Interface {
	return core.Interface{m["shipping_service_select_strategy"]}
}
func (m ShopHistory) InventoryOverstock() core.Interface {
	return core.Interface{m["inventory_overstock"]}
}
func (m ShopHistory) WLPartnerID() core.Interface { return core.Interface{m["wl_partner_id"]} }
func (m ShopHistory) Rid() core.Interface         { return core.Interface{m["rid"]} }

func (m *ShopHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 29)
	args := make([]interface{}, 29)
	for i := 0; i < 29; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopHistory, 29)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["is_test"] = data[2]
	res["name"] = data[3]
	res["address_id"] = data[4]
	res["ship_to_address_id"] = data[5]
	res["ship_from_address_id"] = data[6]
	res["phone"] = data[7]
	res["bank_account"] = data[8]
	res["website_url"] = data[9]
	res["image_url"] = data[10]
	res["email"] = data[11]
	res["code"] = data[12]
	res["auto_create_ffm"] = data[13]
	res["order_source_id"] = data[14]
	res["status"] = data[15]
	res["created_at"] = data[16]
	res["updated_at"] = data[17]
	res["deleted_at"] = data[18]
	res["recognized_hosts"] = data[19]
	res["ghn_note_code"] = data[20]
	res["try_on"] = data[21]
	res["company_info"] = data[22]
	res["money_transaction_rrule"] = data[23]
	res["survey_info"] = data[24]
	res["shipping_service_select_strategy"] = data[25]
	res["inventory_overstock"] = data[26]
	res["wl_partner_id"] = data[27]
	res["rid"] = data[28]
	*m = res
	return nil
}

func (ms *ShopHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 29)
	args := make([]interface{}, 29)
	for i := 0; i < 29; i++ {
		args[i] = &data[i]
	}
	res := make(ShopHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["is_test"] = data[2]
		m["name"] = data[3]
		m["address_id"] = data[4]
		m["ship_to_address_id"] = data[5]
		m["ship_from_address_id"] = data[6]
		m["phone"] = data[7]
		m["bank_account"] = data[8]
		m["website_url"] = data[9]
		m["image_url"] = data[10]
		m["email"] = data[11]
		m["code"] = data[12]
		m["auto_create_ffm"] = data[13]
		m["order_source_id"] = data[14]
		m["status"] = data[15]
		m["created_at"] = data[16]
		m["updated_at"] = data[17]
		m["deleted_at"] = data[18]
		m["recognized_hosts"] = data[19]
		m["ghn_note_code"] = data[20]
		m["try_on"] = data[21]
		m["company_info"] = data[22]
		m["money_transaction_rrule"] = data[23]
		m["survey_info"] = data[24]
		m["shipping_service_select_strategy"] = data[25]
		m["inventory_overstock"] = data[26]
		m["wl_partner_id"] = data[27]
		m["rid"] = data[28]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// ShopDelete is a substruct of Shopfunc substructShopDelete(_ ShopDelete, _ Shop) bool { return true }func HopDeletesFromHops(ps []Shop) []ShopDelete {	ss := make([]ShopDelete, len(ps))	for i, p := range ps {		ss[i] = NewHopDeleteFromHop(p)	}	return ss}func HopDeletesToHops(ss []ShopDelete) []Shop {	ps := make([]Shop, len(ss))	for i, s := range ss {		ps[i] = s.Tohop()	}	return ps}func NewHopDeleteFromHop(sp Shop) ShopDelete {	if sp == nil {\t\treturn nil	}	s := new(hopDelete)	s.CopyFrom(sp)	return s}func (s ShopDelete) ToHop() Shop {	if s == nil {		return nil	}	sp := new(hop)	s.AssignTo(sp)	return sp}func (s ShopDelete) CopyFrom(sp Shop) {	s.DeletedAt = sp.DeletedAt}func (s ShopDelete) AssignTo(sp Shop) {	sp.DeletedAt = s.DeletedAt}
type ShopDeletes []*ShopDelete

const __sqlShopDelete_Table = "shop"
const __sqlShopDelete_ListCols = "\"deleted_at\""
const __sqlShopDelete_ListColsOnConflict = "\"deleted_at\" = EXCLUDED.\"deleted_at\""
const __sqlShopDelete_Insert = "INSERT INTO \"shop\" (" + __sqlShopDelete_ListCols + ") VALUES"
const __sqlShopDelete_Select = "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\""
const __sqlShopDelete_Select_history = "SELECT " + __sqlShopDelete_ListCols + " FROM history.\"shop\""
const __sqlShopDelete_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShopDelete_ListCols + ")"
const __sqlShopDelete_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shop_pkey DO UPDATE SET"

func (m *ShopDelete) SQLTableName() string  { return "shop" }
func (m *ShopDeletes) SQLTableName() string { return "shop" }
func (m *ShopDelete) SQLListCols() string   { return __sqlShopDelete_ListCols }

func (m *ShopDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ShopDelete) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "shop"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "shop", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShopDelete)(nil))
}

func (m *ShopDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopDeletes, 0, 128)
	for rows.Next() {
		m := new(ShopDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShopDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (_ *ShopDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (m *ShopDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShopDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShopDelete) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShopDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopDelete_ListColsOnConflict)
	return nil
}

func (ms ShopDeletes) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShopDelete_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopDelete_ListColsOnConflict)
	return nil
}

func (m *ShopDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShopDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopDeleteHistory map[string]interface{}
type ShopDeleteHistories []map[string]interface{}

func (m *ShopDeleteHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopDeleteHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *ShopDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *ShopDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(ShopDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type ShopExtendeds []*ShopExtended

func (m *ShopExtended) SQLTableName() string  { return "shop" }
func (m *ShopExtendeds) SQLTableName() string { return "shop" }

func (m *ShopExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopExtendeds, 0, 128)
	for rows.Next() {
		m := new(ShopExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *ShopExtended) SQLSelect(w SQLWriter) error {
	(*ShopExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*ShopExtended)(nil).__sqlJoin(w)
	return nil
}

func (m *ShopExtendeds) SQLSelect(w SQLWriter) error {
	return (*ShopExtended)(nil).SQLSelect(w)
}

func (m *ShopExtended) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *ShopExtendeds) SQLJoin(w SQLWriter) error {
	return (*ShopExtended)(nil).SQLJoin(w)
}

func (m *ShopExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "s", (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "a", (*addressmodel.Address)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "u", (*User)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "ss", (*ShopSearch)(nil).SQLListCols())
}

func (m *ShopExtended) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("shop")
	w.WriteRawString(" AS ")
	w.WriteName("s")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*addressmodel.Address)(nil).SQLTableName())
	w.WriteRawString(" AS a ON")
	w.WriteQueryString(" s.address_id = a.id")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS u ON")
	w.WriteQueryString(" s.owner_id = u.id")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*ShopSearch)(nil).SQLTableName())
	w.WriteRawString(" AS ss ON")
	w.WriteQueryString(" s.id = ss.id")
}

func (m *ShopExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.Address = new(addressmodel.Address)
	args = append(args, m.Address.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	m.ShopSearch = new(ShopSearch)
	args = append(args, m.ShopSearch.SQLScanArgs(opts)...)
	return args
}

type ShopSearchs []*ShopSearch

const __sqlShopSearch_Table = "shop_search"
const __sqlShopSearch_ListCols = "\"id\",\"name\",\"name_norm\""
const __sqlShopSearch_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"name\" = EXCLUDED.\"name\",\"name_norm\" = EXCLUDED.\"name_norm\""
const __sqlShopSearch_Insert = "INSERT INTO \"shop_search\" (" + __sqlShopSearch_ListCols + ") VALUES"
const __sqlShopSearch_Select = "SELECT " + __sqlShopSearch_ListCols + " FROM \"shop_search\""
const __sqlShopSearch_Select_history = "SELECT " + __sqlShopSearch_ListCols + " FROM history.\"shop_search\""
const __sqlShopSearch_UpdateAll = "UPDATE \"shop_search\" SET (" + __sqlShopSearch_ListCols + ")"
const __sqlShopSearch_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shop_search_pkey DO UPDATE SET"

func (m *ShopSearch) SQLTableName() string  { return "shop_search" }
func (m *ShopSearchs) SQLTableName() string { return "shop_search" }
func (m *ShopSearch) SQLListCols() string   { return __sqlShopSearch_ListCols }

func (m *ShopSearch) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShopSearch_ListCols + " FROM \"shop_search\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ShopSearch) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "shop_search"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name_norm": {
			ColumnName:       "name_norm",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "shop_search", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShopSearch)(nil))
}

func (m *ShopSearch) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		core.String(m.Name),
		core.String(m.NameNorm),
	}
}

func (m *ShopSearch) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		(*core.String)(&m.NameNorm),
	}
}

func (m *ShopSearch) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopSearchs) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopSearchs, 0, 128)
	for rows.Next() {
		m := new(ShopSearch)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShopSearch) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Select)
	return nil
}

func (_ *ShopSearchs) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Select)
	return nil
}

func (m *ShopSearch) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShopSearchs) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShopSearch) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShopSearch_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopSearch_ListColsOnConflict)
	return nil
}

func (ms ShopSearchs) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShopSearch_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShopSearch_ListColsOnConflict)
	return nil
}

func (m *ShopSearch) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop_search")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.NameNorm != "" {
		flag = true
		w.WriteName("name_norm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NameNorm)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShopSearch) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopSearchHistory map[string]interface{}
type ShopSearchHistories []map[string]interface{}

func (m *ShopSearchHistory) SQLTableName() string  { return "history.\"shop_search\"" }
func (m ShopSearchHistories) SQLTableName() string { return "history.\"shop_search\"" }

func (m *ShopSearchHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Select_history)
	return nil
}

func (m ShopSearchHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopSearch_Select_history)
	return nil
}

func (m ShopSearchHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m ShopSearchHistory) Name() core.Interface     { return core.Interface{m["name"]} }
func (m ShopSearchHistory) NameNorm() core.Interface { return core.Interface{m["name_norm"]} }

func (m *ShopSearchHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopSearchHistory, 3)
	res["id"] = data[0]
	res["name"] = data[1]
	res["name_norm"] = data[2]
	*m = res
	return nil
}

func (ms *ShopSearchHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(ShopSearchHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopSearchHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["name_norm"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type Users []*User

const __sqlUser_Table = "user"
const __sqlUser_ListCols = "\"id\",\"full_name\",\"short_name\",\"email\",\"phone\",\"status\",\"created_at\",\"updated_at\",\"agreed_tos_at\",\"agreed_email_info_at\",\"email_verified_at\",\"phone_verified_at\",\"email_verification_sent_at\",\"phone_verification_sent_at\",\"full_name_norm\",\"is_test\",\"source\",\"ref_user_id\",\"ref_sale_id\",\"wl_partner_id\",\"rid\",\"blocked_at\",\"blocked_by\",\"block_reason\""
const __sqlUser_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"full_name\" = EXCLUDED.\"full_name\",\"short_name\" = EXCLUDED.\"short_name\",\"email\" = EXCLUDED.\"email\",\"phone\" = EXCLUDED.\"phone\",\"status\" = EXCLUDED.\"status\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"agreed_tos_at\" = EXCLUDED.\"agreed_tos_at\",\"agreed_email_info_at\" = EXCLUDED.\"agreed_email_info_at\",\"email_verified_at\" = EXCLUDED.\"email_verified_at\",\"phone_verified_at\" = EXCLUDED.\"phone_verified_at\",\"email_verification_sent_at\" = EXCLUDED.\"email_verification_sent_at\",\"phone_verification_sent_at\" = EXCLUDED.\"phone_verification_sent_at\",\"full_name_norm\" = EXCLUDED.\"full_name_norm\",\"is_test\" = EXCLUDED.\"is_test\",\"source\" = EXCLUDED.\"source\",\"ref_user_id\" = EXCLUDED.\"ref_user_id\",\"ref_sale_id\" = EXCLUDED.\"ref_sale_id\",\"wl_partner_id\" = EXCLUDED.\"wl_partner_id\",\"rid\" = EXCLUDED.\"rid\",\"blocked_at\" = EXCLUDED.\"blocked_at\",\"blocked_by\" = EXCLUDED.\"blocked_by\",\"block_reason\" = EXCLUDED.\"block_reason\""
const __sqlUser_Insert = "INSERT INTO \"user\" (" + __sqlUser_ListCols + ") VALUES"
const __sqlUser_Select = "SELECT " + __sqlUser_ListCols + " FROM \"user\""
const __sqlUser_Select_history = "SELECT " + __sqlUser_ListCols + " FROM history.\"user\""
const __sqlUser_UpdateAll = "UPDATE \"user\" SET (" + __sqlUser_ListCols + ")"
const __sqlUser_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_pkey DO UPDATE SET"

func (m *User) SQLTableName() string  { return "user" }
func (m *Users) SQLTableName() string { return "user" }
func (m *User) SQLListCols() string   { return __sqlUser_ListCols }

func (m *User) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUser_ListCols + " FROM \"user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *User) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "user"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"full_name": {
			ColumnName:       "full_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"short_name": {
			ColumnName:       "short_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email": {
			ColumnName:       "email",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone": {
			ColumnName:       "phone",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status3.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "N"},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"agreed_tos_at": {
			ColumnName:       "agreed_tos_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"agreed_email_info_at": {
			ColumnName:       "agreed_email_info_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email_verified_at": {
			ColumnName:       "email_verified_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone_verified_at": {
			ColumnName:       "phone_verified_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email_verification_sent_at": {
			ColumnName:       "email_verification_sent_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"phone_verification_sent_at": {
			ColumnName:       "phone_verification_sent_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"full_name_norm": {
			ColumnName:       "full_name_norm",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"is_test": {
			ColumnName:       "is_test",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"source": {
			ColumnName:       "source",
			ColumnType:       "user_source.UserSource",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "psx", "etop", "topship", "ts_app_android", "ts_app_ios", "ts_app_web", "partner", "etop_app_ios", "etop_app_android"},
		},
		"ref_user_id": {
			ColumnName:       "ref_user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_sale_id": {
			ColumnName:       "ref_sale_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"wl_partner_id": {
			ColumnName:       "wl_partner_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"rid": {
			ColumnName:       "rid",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"blocked_at": {
			ColumnName:       "blocked_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"blocked_by": {
			ColumnName:       "blocked_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"block_reason": {
			ColumnName:       "block_reason",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "user", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*User)(nil))
}

func (m *User) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.UserInner.FullName),
		core.String(m.UserInner.ShortName),
		core.String(m.UserInner.Email),
		core.String(m.UserInner.Phone),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.AgreedTOSAt),
		core.Time(m.AgreedEmailInfoAt),
		core.Time(m.EmailVerifiedAt),
		core.Time(m.PhoneVerifiedAt),
		core.Time(m.EmailVerificationSentAt),
		core.Time(m.PhoneVerificationSentAt),
		core.String(m.FullNameNorm),
		core.Int(m.IsTest),
		m.Source,
		m.RefUserID,
		m.RefSaleID,
		m.WLPartnerID,
		core.Int(m.Rid),
		core.Time(m.BlockedAt),
		m.BlockedBy,
		core.String(m.BlockReason),
	}
}

func (m *User) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.UserInner.FullName),
		(*core.String)(&m.UserInner.ShortName),
		(*core.String)(&m.UserInner.Email),
		(*core.String)(&m.UserInner.Phone),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.AgreedTOSAt),
		(*core.Time)(&m.AgreedEmailInfoAt),
		(*core.Time)(&m.EmailVerifiedAt),
		(*core.Time)(&m.PhoneVerifiedAt),
		(*core.Time)(&m.EmailVerificationSentAt),
		(*core.Time)(&m.PhoneVerificationSentAt),
		(*core.String)(&m.FullNameNorm),
		(*core.Int)(&m.IsTest),
		&m.Source,
		&m.RefUserID,
		&m.RefSaleID,
		&m.WLPartnerID,
		(*core.Int)(&m.Rid),
		(*core.Time)(&m.BlockedAt),
		&m.BlockedBy,
		(*core.String)(&m.BlockReason),
	}
}

func (m *User) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Users) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Users, 0, 128)
	for rows.Next() {
		m := new(User)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *User) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (_ *Users) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (m *User) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(24)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Users) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(24)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *User) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUser_ListColsOnConflict)
	return nil
}

func (ms Users) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUser_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUser_ListColsOnConflict)
	return nil
}

func (m *User) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserInner.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.FullName)
	}
	if m.UserInner.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.ShortName)
	}
	if m.UserInner.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Email)
	}
	if m.UserInner.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Phone)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.AgreedTOSAt.IsZero() {
		flag = true
		w.WriteName("agreed_tos_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedTOSAt)
	}
	if !m.AgreedEmailInfoAt.IsZero() {
		flag = true
		w.WriteName("agreed_email_info_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedEmailInfoAt)
	}
	if !m.EmailVerifiedAt.IsZero() {
		flag = true
		w.WriteName("email_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerifiedAt)
	}
	if !m.PhoneVerifiedAt.IsZero() {
		flag = true
		w.WriteName("phone_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerifiedAt)
	}
	if !m.EmailVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("email_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerificationSentAt)
	}
	if !m.PhoneVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("phone_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerificationSentAt)
	}
	if m.FullNameNorm != "" {
		flag = true
		w.WriteName("full_name_norm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FullNameNorm)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Source != 0 {
		flag = true
		w.WriteName("source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Source)
	}
	if m.RefUserID != 0 {
		flag = true
		w.WriteName("ref_user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefUserID)
	}
	if m.RefSaleID != 0 {
		flag = true
		w.WriteName("ref_sale_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefSaleID)
	}
	if m.WLPartnerID != 0 {
		flag = true
		w.WriteName("wl_partner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WLPartnerID)
	}
	if m.Rid != 0 {
		flag = true
		w.WriteName("rid")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Rid)
	}
	if !m.BlockedAt.IsZero() {
		flag = true
		w.WriteName("blocked_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.BlockedAt)
	}
	if m.BlockedBy != 0 {
		flag = true
		w.WriteName("blocked_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.BlockedBy)
	}
	if m.BlockReason != "" {
		flag = true
		w.WriteName("block_reason")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.BlockReason)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *User) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(24)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserHistory map[string]interface{}
type UserHistories []map[string]interface{}

func (m *UserHistory) SQLTableName() string  { return "history.\"user\"" }
func (m UserHistories) SQLTableName() string { return "history.\"user\"" }

func (m *UserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m UserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m UserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m UserHistory) Email() core.Interface       { return core.Interface{m["email"]} }
func (m UserHistory) Phone() core.Interface       { return core.Interface{m["phone"]} }
func (m UserHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m UserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m UserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m UserHistory) AgreedTOSAt() core.Interface { return core.Interface{m["agreed_tos_at"]} }
func (m UserHistory) AgreedEmailInfoAt() core.Interface {
	return core.Interface{m["agreed_email_info_at"]}
}
func (m UserHistory) EmailVerifiedAt() core.Interface { return core.Interface{m["email_verified_at"]} }
func (m UserHistory) PhoneVerifiedAt() core.Interface { return core.Interface{m["phone_verified_at"]} }
func (m UserHistory) EmailVerificationSentAt() core.Interface {
	return core.Interface{m["email_verification_sent_at"]}
}
func (m UserHistory) PhoneVerificationSentAt() core.Interface {
	return core.Interface{m["phone_verification_sent_at"]}
}
func (m UserHistory) FullNameNorm() core.Interface { return core.Interface{m["full_name_norm"]} }
func (m UserHistory) IsTest() core.Interface       { return core.Interface{m["is_test"]} }
func (m UserHistory) Source() core.Interface       { return core.Interface{m["source"]} }
func (m UserHistory) RefUserID() core.Interface    { return core.Interface{m["ref_user_id"]} }
func (m UserHistory) RefSaleID() core.Interface    { return core.Interface{m["ref_sale_id"]} }
func (m UserHistory) WLPartnerID() core.Interface  { return core.Interface{m["wl_partner_id"]} }
func (m UserHistory) Rid() core.Interface          { return core.Interface{m["rid"]} }
func (m UserHistory) BlockedAt() core.Interface    { return core.Interface{m["blocked_at"]} }
func (m UserHistory) BlockedBy() core.Interface    { return core.Interface{m["blocked_by"]} }
func (m UserHistory) BlockReason() core.Interface  { return core.Interface{m["block_reason"]} }

func (m *UserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 24)
	args := make([]interface{}, 24)
	for i := 0; i < 24; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserHistory, 24)
	res["id"] = data[0]
	res["full_name"] = data[1]
	res["short_name"] = data[2]
	res["email"] = data[3]
	res["phone"] = data[4]
	res["status"] = data[5]
	res["created_at"] = data[6]
	res["updated_at"] = data[7]
	res["agreed_tos_at"] = data[8]
	res["agreed_email_info_at"] = data[9]
	res["email_verified_at"] = data[10]
	res["phone_verified_at"] = data[11]
	res["email_verification_sent_at"] = data[12]
	res["phone_verification_sent_at"] = data[13]
	res["full_name_norm"] = data[14]
	res["is_test"] = data[15]
	res["source"] = data[16]
	res["ref_user_id"] = data[17]
	res["ref_sale_id"] = data[18]
	res["wl_partner_id"] = data[19]
	res["rid"] = data[20]
	res["blocked_at"] = data[21]
	res["blocked_by"] = data[22]
	res["block_reason"] = data[23]
	*m = res
	return nil
}

func (ms *UserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 24)
	args := make([]interface{}, 24)
	for i := 0; i < 24; i++ {
		args[i] = &data[i]
	}
	res := make(UserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserHistory)
		m["id"] = data[0]
		m["full_name"] = data[1]
		m["short_name"] = data[2]
		m["email"] = data[3]
		m["phone"] = data[4]
		m["status"] = data[5]
		m["created_at"] = data[6]
		m["updated_at"] = data[7]
		m["agreed_tos_at"] = data[8]
		m["agreed_email_info_at"] = data[9]
		m["email_verified_at"] = data[10]
		m["phone_verified_at"] = data[11]
		m["email_verification_sent_at"] = data[12]
		m["phone_verification_sent_at"] = data[13]
		m["full_name_norm"] = data[14]
		m["is_test"] = data[15]
		m["source"] = data[16]
		m["ref_user_id"] = data[17]
		m["ref_sale_id"] = data[18]
		m["wl_partner_id"] = data[19]
		m["rid"] = data[20]
		m["blocked_at"] = data[21]
		m["blocked_by"] = data[22]
		m["block_reason"] = data[23]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type UserAuths []*UserAuth

const __sqlUserAuth_Table = "user_auth"
const __sqlUserAuth_ListCols = "\"user_id\",\"auth_type\",\"auth_key\",\"created_at\",\"updated_at\""
const __sqlUserAuth_ListColsOnConflict = "\"user_id\" = EXCLUDED.\"user_id\",\"auth_type\" = EXCLUDED.\"auth_type\",\"auth_key\" = EXCLUDED.\"auth_key\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlUserAuth_Insert = "INSERT INTO \"user_auth\" (" + __sqlUserAuth_ListCols + ") VALUES"
const __sqlUserAuth_Select = "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\""
const __sqlUserAuth_Select_history = "SELECT " + __sqlUserAuth_ListCols + " FROM history.\"user_auth\""
const __sqlUserAuth_UpdateAll = "UPDATE \"user_auth\" SET (" + __sqlUserAuth_ListCols + ")"
const __sqlUserAuth_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_auth_pkey DO UPDATE SET"

func (m *UserAuth) SQLTableName() string  { return "user_auth" }
func (m *UserAuths) SQLTableName() string { return "user_auth" }
func (m *UserAuth) SQLListCols() string   { return __sqlUserAuth_ListCols }

func (m *UserAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *UserAuth) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "user_auth"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"user_id": {
			ColumnName:       "user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"auth_type": {
			ColumnName:       "auth_type",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"auth_key": {
			ColumnName:       "auth_key",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "user_auth", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserAuth)(nil))
}

func (m *UserAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.UserID,
		core.String(m.AuthType),
		core.String(m.AuthKey),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.UserID,
		(*core.String)(&m.AuthType),
		(*core.String)(&m.AuthKey),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserAuths, 0, 128)
	for rows.Next() {
		m := new(UserAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (_ *UserAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (m *UserAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(5)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserAuth) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUserAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserAuth_ListColsOnConflict)
	return nil
}

func (ms UserAuths) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUserAuth_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserAuth_ListColsOnConflict)
	return nil
}

func (m *UserAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_auth")
	w.WriteRawString(" SET ")
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AuthType != "" {
		flag = true
		w.WriteName("auth_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthType)
	}
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserAuthHistory map[string]interface{}
type UserAuthHistories []map[string]interface{}

func (m *UserAuthHistory) SQLTableName() string  { return "history.\"user_auth\"" }
func (m UserAuthHistories) SQLTableName() string { return "history.\"user_auth\"" }

func (m *UserAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m UserAuthHistory) AuthType() core.Interface  { return core.Interface{m["auth_type"]} }
func (m UserAuthHistory) AuthKey() core.Interface   { return core.Interface{m["auth_key"]} }
func (m UserAuthHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m UserAuthHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserAuthHistory, 5)
	res["user_id"] = data[0]
	res["auth_type"] = data[1]
	res["auth_key"] = data[2]
	res["created_at"] = data[3]
	res["updated_at"] = data[4]
	*m = res
	return nil
}

func (ms *UserAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	res := make(UserAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserAuthHistory)
		m["user_id"] = data[0]
		m["auth_type"] = data[1]
		m["auth_key"] = data[2]
		m["created_at"] = data[3]
		m["updated_at"] = data[4]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type UserFtRefSaffs []*UserFtRefSaff

func (m *UserFtRefSaff) SQLTableName() string  { return "user" }
func (m *UserFtRefSaffs) SQLTableName() string { return "user" }

func (m *UserFtRefSaff) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserFtRefSaffs) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserFtRefSaffs, 0, 128)
	for rows.Next() {
		m := new(UserFtRefSaff)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserFtRefSaff) SQLSelect(w SQLWriter) error {
	(*UserFtRefSaff)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*UserFtRefSaff)(nil).__sqlJoin(w)
	return nil
}

func (m *UserFtRefSaffs) SQLSelect(w SQLWriter) error {
	return (*UserFtRefSaff)(nil).SQLSelect(w)
}

func (m *UserFtRefSaff) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *UserFtRefSaffs) SQLJoin(w SQLWriter) error {
	return (*UserFtRefSaff)(nil).SQLJoin(w)
}

func (m *UserFtRefSaff) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "u", (*User)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "urs", (*UserRefSaff)(nil).SQLListCols())
}

func (m *UserFtRefSaff) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("user")
	w.WriteRawString(" AS ")
	w.WriteName("u")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*UserRefSaff)(nil).SQLTableName())
	w.WriteRawString(" AS urs ON")
	w.WriteQueryString(" u.id = urs.user_id")
}

func (m *UserFtRefSaff) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)
	m.UserRefSaff = new(UserRefSaff)
	args = append(args, m.UserRefSaff.SQLScanArgs(opts)...)
	return args
}

type UserInternals []*UserInternal

const __sqlUserInternal_Table = "user_internal"
const __sqlUserInternal_ListCols = "\"id\",\"hashpwd\",\"updated_at\""
const __sqlUserInternal_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"hashpwd\" = EXCLUDED.\"hashpwd\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlUserInternal_Insert = "INSERT INTO \"user_internal\" (" + __sqlUserInternal_ListCols + ") VALUES"
const __sqlUserInternal_Select = "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\""
const __sqlUserInternal_Select_history = "SELECT " + __sqlUserInternal_ListCols + " FROM history.\"user_internal\""
const __sqlUserInternal_UpdateAll = "UPDATE \"user_internal\" SET (" + __sqlUserInternal_ListCols + ")"
const __sqlUserInternal_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_internal_pkey DO UPDATE SET"

func (m *UserInternal) SQLTableName() string  { return "user_internal" }
func (m *UserInternals) SQLTableName() string { return "user_internal" }
func (m *UserInternal) SQLListCols() string   { return __sqlUserInternal_ListCols }

func (m *UserInternal) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *UserInternal) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "user_internal"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"hashpwd": {
			ColumnName:       "hashpwd",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "user_internal", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserInternal)(nil))
}

func (m *UserInternal) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Hashpwd),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserInternal) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Hashpwd),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserInternal) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserInternals) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserInternals, 0, 128)
	for rows.Next() {
		m := new(UserInternal)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserInternal) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (_ *UserInternals) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (m *UserInternal) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserInternals) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserInternal) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUserInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserInternal_ListColsOnConflict)
	return nil
}

func (ms UserInternals) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUserInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserInternal_ListColsOnConflict)
	return nil
}

func (m *UserInternal) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_internal")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Hashpwd != "" {
		flag = true
		w.WriteName("hashpwd")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Hashpwd)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserInternal) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserInternalHistory map[string]interface{}
type UserInternalHistories []map[string]interface{}

func (m *UserInternalHistory) SQLTableName() string  { return "history.\"user_internal\"" }
func (m UserInternalHistories) SQLTableName() string { return "history.\"user_internal\"" }

func (m *UserInternalHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m UserInternalHistory) Hashpwd() core.Interface   { return core.Interface{m["hashpwd"]} }
func (m UserInternalHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserInternalHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserInternalHistory, 3)
	res["id"] = data[0]
	res["hashpwd"] = data[1]
	res["updated_at"] = data[2]
	*m = res
	return nil
}

func (ms *UserInternalHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(UserInternalHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserInternalHistory)
		m["id"] = data[0]
		m["hashpwd"] = data[1]
		m["updated_at"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type UserRefSaffs []*UserRefSaff

const __sqlUserRefSaff_Table = "user_ref_saff"
const __sqlUserRefSaff_ListCols = "\"user_id\",\"ref_aff\",\"ref_sale\""
const __sqlUserRefSaff_ListColsOnConflict = "\"user_id\" = EXCLUDED.\"user_id\",\"ref_aff\" = EXCLUDED.\"ref_aff\",\"ref_sale\" = EXCLUDED.\"ref_sale\""
const __sqlUserRefSaff_Insert = "INSERT INTO \"user_ref_saff\" (" + __sqlUserRefSaff_ListCols + ") VALUES"
const __sqlUserRefSaff_Select = "SELECT " + __sqlUserRefSaff_ListCols + " FROM \"user_ref_saff\""
const __sqlUserRefSaff_Select_history = "SELECT " + __sqlUserRefSaff_ListCols + " FROM history.\"user_ref_saff\""
const __sqlUserRefSaff_UpdateAll = "UPDATE \"user_ref_saff\" SET (" + __sqlUserRefSaff_ListCols + ")"
const __sqlUserRefSaff_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT user_ref_saff_pkey DO UPDATE SET"

func (m *UserRefSaff) SQLTableName() string  { return "user_ref_saff" }
func (m *UserRefSaffs) SQLTableName() string { return "user_ref_saff" }
func (m *UserRefSaff) SQLListCols() string   { return __sqlUserRefSaff_ListCols }

func (m *UserRefSaff) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserRefSaff_ListCols + " FROM \"user_ref_saff\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *UserRefSaff) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "user_ref_saff"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"user_id": {
			ColumnName:       "user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_aff": {
			ColumnName:       "ref_aff",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_sale": {
			ColumnName:       "ref_sale",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "user_ref_saff", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserRefSaff)(nil))
}

func (m *UserRefSaff) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.UserID,
		core.String(m.RefAff),
		core.String(m.RefSale),
	}
}

func (m *UserRefSaff) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.UserID,
		(*core.String)(&m.RefAff),
		(*core.String)(&m.RefSale),
	}
}

func (m *UserRefSaff) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserRefSaffs) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserRefSaffs, 0, 128)
	for rows.Next() {
		m := new(UserRefSaff)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserRefSaff) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Select)
	return nil
}

func (_ *UserRefSaffs) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Select)
	return nil
}

func (m *UserRefSaff) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserRefSaffs) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserRefSaff) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlUserRefSaff_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserRefSaff_ListColsOnConflict)
	return nil
}

func (ms UserRefSaffs) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlUserRefSaff_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlUserRefSaff_ListColsOnConflict)
	return nil
}

func (m *UserRefSaff) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_ref_saff")
	w.WriteRawString(" SET ")
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.RefAff != "" {
		flag = true
		w.WriteName("ref_aff")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefAff)
	}
	if m.RefSale != "" {
		flag = true
		w.WriteName("ref_sale")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefSale)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserRefSaff) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserRefSaffHistory map[string]interface{}
type UserRefSaffHistories []map[string]interface{}

func (m *UserRefSaffHistory) SQLTableName() string  { return "history.\"user_ref_saff\"" }
func (m UserRefSaffHistories) SQLTableName() string { return "history.\"user_ref_saff\"" }

func (m *UserRefSaffHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Select_history)
	return nil
}

func (m UserRefSaffHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserRefSaff_Select_history)
	return nil
}

func (m UserRefSaffHistory) UserID() core.Interface  { return core.Interface{m["user_id"]} }
func (m UserRefSaffHistory) RefAff() core.Interface  { return core.Interface{m["ref_aff"]} }
func (m UserRefSaffHistory) RefSale() core.Interface { return core.Interface{m["ref_sale"]} }

func (m *UserRefSaffHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserRefSaffHistory, 3)
	res["user_id"] = data[0]
	res["ref_aff"] = data[1]
	res["ref_sale"] = data[2]
	*m = res
	return nil
}

func (ms *UserRefSaffHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(UserRefSaffHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserRefSaffHistory)
		m["user_id"] = data[0]
		m["ref_aff"] = data[1]
		m["ref_sale"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
