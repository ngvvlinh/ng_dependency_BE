// +build !generator

// Code generated by generator sqlgen. DO NOT EDIT.

package modely

import (
	"database/sql"
	"sync"

	identitymodel "o.o/backend/com/main/identity/model"
	moneytxmodel "o.o/backend/com/main/moneytx/model"
	orderingmodel "o.o/backend/com/main/ordering/model"
	shippingmodel "o.o/backend/com/main/shipping/model"
	cmsql "o.o/backend/pkg/common/sql/cmsql"
	core "o.o/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

type FulfillmentExtendeds []*FulfillmentExtended

func (m *FulfillmentExtended) SQLTableName() string  { return "fulfillment" }
func (m *FulfillmentExtendeds) SQLTableName() string { return "fulfillment" }

func (m *FulfillmentExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *FulfillmentExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(FulfillmentExtendeds, 0, 128)
	for rows.Next() {
		m := new(FulfillmentExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *FulfillmentExtended) SQLSelect(w SQLWriter) error {
	(*FulfillmentExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*FulfillmentExtended)(nil).__sqlJoin(w)
	return nil
}

func (m *FulfillmentExtendeds) SQLSelect(w SQLWriter) error {
	return (*FulfillmentExtended)(nil).SQLSelect(w)
}

func (m *FulfillmentExtended) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *FulfillmentExtendeds) SQLJoin(w SQLWriter) error {
	return (*FulfillmentExtended)(nil).SQLJoin(w)
}

func (m *FulfillmentExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "f", (*shippingmodel.Fulfillment)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "s", (*identitymodel.Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "o", (*orderingmodel.Order)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "m", (*moneytxmodel.MoneyTransactionShipping)(nil).SQLListCols())
}

func (m *FulfillmentExtended) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("fulfillment")
	w.WriteRawString(" AS ")
	w.WriteName("f")
	w.WriteRawString(" JOIN ")
	w.WriteName((*identitymodel.Shop)(nil).SQLTableName())
	w.WriteRawString(" AS s ON")
	w.WriteQueryString(" s.id = f.shop_id")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*orderingmodel.Order)(nil).SQLTableName())
	w.WriteRawString(" AS o ON")
	w.WriteQueryString(" o.id = f.order_id")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*moneytxmodel.MoneyTransactionShipping)(nil).SQLTableName())
	w.WriteRawString(" AS m ON")
	w.WriteQueryString(" f.money_transaction_id = m.id")
}

func (m *FulfillmentExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Fulfillment = new(shippingmodel.Fulfillment)
	args = append(args, m.Fulfillment.SQLScanArgs(opts)...)
	m.Shop = new(identitymodel.Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.Order = new(orderingmodel.Order)
	args = append(args, m.Order.SQLScanArgs(opts)...)
	m.MoneyTransactionShipping = new(moneytxmodel.MoneyTransactionShipping)
	args = append(args, m.MoneyTransactionShipping.SQLScanArgs(opts)...)
	return args
}
