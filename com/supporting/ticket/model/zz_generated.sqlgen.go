// +build !generator

// Code generated by generator sqlgen. DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	time "time"

	cmsql "o.o/backend/pkg/common/sql/cmsql"
	migration "o.o/backend/pkg/common/sql/migration"
	core "o.o/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

type Tickets []*Ticket

const __sqlTicket_Table = "ticket"
const __sqlTicket_ListCols = "\"id\",\"code\",\"assigned_user_ids\",\"account_id\",\"label_ids\",\"ref_ticket_id\",\"title\",\"description\",\"note\",\"ref_id\",\"ref_type\",\"ref_code\",\"source\",\"state\",\"status\",\"created_by\",\"created_source\",\"created_name\",\"updated_by\",\"confirmed_by\",\"closed_by\",\"created_at\",\"updated_at\",\"confirmed_at\",\"closed_at\""
const __sqlTicket_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"code\" = EXCLUDED.\"code\",\"assigned_user_ids\" = EXCLUDED.\"assigned_user_ids\",\"account_id\" = EXCLUDED.\"account_id\",\"label_ids\" = EXCLUDED.\"label_ids\",\"ref_ticket_id\" = EXCLUDED.\"ref_ticket_id\",\"title\" = EXCLUDED.\"title\",\"description\" = EXCLUDED.\"description\",\"note\" = EXCLUDED.\"note\",\"ref_id\" = EXCLUDED.\"ref_id\",\"ref_type\" = EXCLUDED.\"ref_type\",\"ref_code\" = EXCLUDED.\"ref_code\",\"source\" = EXCLUDED.\"source\",\"state\" = EXCLUDED.\"state\",\"status\" = EXCLUDED.\"status\",\"created_by\" = EXCLUDED.\"created_by\",\"created_source\" = EXCLUDED.\"created_source\",\"created_name\" = EXCLUDED.\"created_name\",\"updated_by\" = EXCLUDED.\"updated_by\",\"confirmed_by\" = EXCLUDED.\"confirmed_by\",\"closed_by\" = EXCLUDED.\"closed_by\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"confirmed_at\" = EXCLUDED.\"confirmed_at\",\"closed_at\" = EXCLUDED.\"closed_at\""
const __sqlTicket_Insert = "INSERT INTO \"ticket\" (" + __sqlTicket_ListCols + ") VALUES"
const __sqlTicket_Select = "SELECT " + __sqlTicket_ListCols + " FROM \"ticket\""
const __sqlTicket_Select_history = "SELECT " + __sqlTicket_ListCols + " FROM history.\"ticket\""
const __sqlTicket_UpdateAll = "UPDATE \"ticket\" SET (" + __sqlTicket_ListCols + ")"
const __sqlTicket_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_pkey DO UPDATE SET"

func (m *Ticket) SQLTableName() string  { return "ticket" }
func (m *Tickets) SQLTableName() string { return "ticket" }
func (m *Ticket) SQLListCols() string   { return __sqlTicket_ListCols }

func (m *Ticket) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicket_ListCols + " FROM \"ticket\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Ticket) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"code": {
			ColumnName:       "code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"assigned_user_ids": {
			ColumnName:       "assigned_user_ids",
			ColumnType:       "[]dot.ID",
			ColumnDBType:     "[]int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"label_ids": {
			ColumnName:       "label_ids",
			ColumnType:       "[]dot.ID",
			ColumnDBType:     "[]int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_ticket_id": {
			ColumnName:       "ref_ticket_id",
			ColumnType:       "dot.NullID",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"title": {
			ColumnName:       "title",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"description": {
			ColumnName:       "description",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"note": {
			ColumnName:       "note",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_id": {
			ColumnName:       "ref_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ref_type": {
			ColumnName:       "ref_type",
			ColumnType:       "ticket_ref_type.TicketRefType",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"order_trading", "ffm", "money_transaction", "other"},
		},
		"ref_code": {
			ColumnName:       "ref_code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"source": {
			ColumnName:       "source",
			ColumnType:       "ticket_source.TicketSource",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"pos_web", "pos_app", "shipment_app", "admin", "system"},
		},
		"state": {
			ColumnName:       "state",
			ColumnType:       "ticket_state.TicketState",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"new", "received", "processing", "success", "fail", "ignore", "cancel"},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status5.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "S", "N", "NS"},
		},
		"created_by": {
			ColumnName:       "created_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_source": {
			ColumnName:       "created_source",
			ColumnType:       "account_type.AccountType",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "partner", "shop", "affiliate", "carrier", "etop"},
		},
		"created_name": {
			ColumnName:       "created_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_by": {
			ColumnName:       "updated_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"confirmed_by": {
			ColumnName:       "confirmed_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"closed_by": {
			ColumnName:       "closed_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"confirmed_at": {
			ColumnName:       "confirmed_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"closed_at": {
			ColumnName:       "closed_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Ticket)(nil))
}

func (m *Ticket) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Code),
		core.Array{m.AssignedUserIDs, opts},
		m.AccountID,
		core.Array{m.LabelIDs, opts},
		m.RefTicketID,
		core.String(m.Title),
		core.String(m.Description),
		core.String(m.Note),
		m.RefID,
		m.RefType,
		core.String(m.RefCode),
		m.Source,
		m.State,
		m.Status,
		m.CreatedBy,
		m.CreatedSource,
		core.String(m.CreatedName),
		m.UpdatedBy,
		m.ConfirmedBy,
		m.ClosedBy,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.ConfirmedAt),
		core.Time(m.ClosedAt),
	}
}

func (m *Ticket) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Code),
		core.Array{&m.AssignedUserIDs, opts},
		&m.AccountID,
		core.Array{&m.LabelIDs, opts},
		&m.RefTicketID,
		(*core.String)(&m.Title),
		(*core.String)(&m.Description),
		(*core.String)(&m.Note),
		&m.RefID,
		&m.RefType,
		(*core.String)(&m.RefCode),
		&m.Source,
		&m.State,
		&m.Status,
		&m.CreatedBy,
		&m.CreatedSource,
		(*core.String)(&m.CreatedName),
		&m.UpdatedBy,
		&m.ConfirmedBy,
		&m.ClosedBy,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.ConfirmedAt),
		(*core.Time)(&m.ClosedAt),
	}
}

func (m *Ticket) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Tickets) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Tickets, 0, 128)
	for rows.Next() {
		m := new(Ticket)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Ticket) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select)
	return nil
}

func (_ *Tickets) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select)
	return nil
}

func (m *Ticket) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(25)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Tickets) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(25)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Ticket) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicket_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicket_ListColsOnConflict)
	return nil
}

func (ms Tickets) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicket_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicket_ListColsOnConflict)
	return nil
}

func (m *Ticket) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.AssignedUserIDs != nil {
		flag = true
		w.WriteName("assigned_user_ids")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.AssignedUserIDs, opts})
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.LabelIDs != nil {
		flag = true
		w.WriteName("label_ids")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.LabelIDs, opts})
	}
	if m.RefTicketID.Valid {
		flag = true
		w.WriteName("ref_ticket_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefTicketID)
	}
	if m.Title != "" {
		flag = true
		w.WriteName("title")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Title)
	}
	if m.Description != "" {
		flag = true
		w.WriteName("description")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Description)
	}
	if m.Note != "" {
		flag = true
		w.WriteName("note")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Note)
	}
	if m.RefID != 0 {
		flag = true
		w.WriteName("ref_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefID)
	}
	if m.RefType != 0 {
		flag = true
		w.WriteName("ref_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefType)
	}
	if m.RefCode != "" {
		flag = true
		w.WriteName("ref_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefCode)
	}
	if m.Source != 0 {
		flag = true
		w.WriteName("source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Source)
	}
	if m.State != 0 {
		flag = true
		w.WriteName("state")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.State)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.CreatedBy != 0 {
		flag = true
		w.WriteName("created_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedBy)
	}
	if m.CreatedSource != 0 {
		flag = true
		w.WriteName("created_source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedSource)
	}
	if m.CreatedName != "" {
		flag = true
		w.WriteName("created_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedName)
	}
	if m.UpdatedBy != 0 {
		flag = true
		w.WriteName("updated_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UpdatedBy)
	}
	if m.ConfirmedBy != 0 {
		flag = true
		w.WriteName("confirmed_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ConfirmedBy)
	}
	if m.ClosedBy != 0 {
		flag = true
		w.WriteName("closed_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ClosedBy)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if true { // always update time
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.ConfirmedAt.IsZero() {
		flag = true
		w.WriteName("confirmed_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ConfirmedAt)
	}
	if !m.ClosedAt.IsZero() {
		flag = true
		w.WriteName("closed_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ClosedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Ticket) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(25)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketHistory map[string]interface{}
type TicketHistories []map[string]interface{}

func (m *TicketHistory) SQLTableName() string  { return "history.\"ticket\"" }
func (m TicketHistories) SQLTableName() string { return "history.\"ticket\"" }

func (m *TicketHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select_history)
	return nil
}

func (m TicketHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select_history)
	return nil
}

func (m TicketHistory) ID() core.Interface   { return core.Interface{m["id"]} }
func (m TicketHistory) Code() core.Interface { return core.Interface{m["code"]} }
func (m TicketHistory) AssignedUserIDs() core.Interface {
	return core.Interface{m["assigned_user_ids"]}
}
func (m TicketHistory) AccountID() core.Interface     { return core.Interface{m["account_id"]} }
func (m TicketHistory) LabelIDs() core.Interface      { return core.Interface{m["label_ids"]} }
func (m TicketHistory) RefTicketID() core.Interface   { return core.Interface{m["ref_ticket_id"]} }
func (m TicketHistory) Title() core.Interface         { return core.Interface{m["title"]} }
func (m TicketHistory) Description() core.Interface   { return core.Interface{m["description"]} }
func (m TicketHistory) Note() core.Interface          { return core.Interface{m["note"]} }
func (m TicketHistory) RefID() core.Interface         { return core.Interface{m["ref_id"]} }
func (m TicketHistory) RefType() core.Interface       { return core.Interface{m["ref_type"]} }
func (m TicketHistory) RefCode() core.Interface       { return core.Interface{m["ref_code"]} }
func (m TicketHistory) Source() core.Interface        { return core.Interface{m["source"]} }
func (m TicketHistory) State() core.Interface         { return core.Interface{m["state"]} }
func (m TicketHistory) Status() core.Interface        { return core.Interface{m["status"]} }
func (m TicketHistory) CreatedBy() core.Interface     { return core.Interface{m["created_by"]} }
func (m TicketHistory) CreatedSource() core.Interface { return core.Interface{m["created_source"]} }
func (m TicketHistory) CreatedName() core.Interface   { return core.Interface{m["created_name"]} }
func (m TicketHistory) UpdatedBy() core.Interface     { return core.Interface{m["updated_by"]} }
func (m TicketHistory) ConfirmedBy() core.Interface   { return core.Interface{m["confirmed_by"]} }
func (m TicketHistory) ClosedBy() core.Interface      { return core.Interface{m["closed_by"]} }
func (m TicketHistory) CreatedAt() core.Interface     { return core.Interface{m["created_at"]} }
func (m TicketHistory) UpdatedAt() core.Interface     { return core.Interface{m["updated_at"]} }
func (m TicketHistory) ConfirmedAt() core.Interface   { return core.Interface{m["confirmed_at"]} }
func (m TicketHistory) ClosedAt() core.Interface      { return core.Interface{m["closed_at"]} }

func (m *TicketHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 25)
	args := make([]interface{}, 25)
	for i := 0; i < 25; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketHistory, 25)
	res["id"] = data[0]
	res["code"] = data[1]
	res["assigned_user_ids"] = data[2]
	res["account_id"] = data[3]
	res["label_ids"] = data[4]
	res["ref_ticket_id"] = data[5]
	res["title"] = data[6]
	res["description"] = data[7]
	res["note"] = data[8]
	res["ref_id"] = data[9]
	res["ref_type"] = data[10]
	res["ref_code"] = data[11]
	res["source"] = data[12]
	res["state"] = data[13]
	res["status"] = data[14]
	res["created_by"] = data[15]
	res["created_source"] = data[16]
	res["created_name"] = data[17]
	res["updated_by"] = data[18]
	res["confirmed_by"] = data[19]
	res["closed_by"] = data[20]
	res["created_at"] = data[21]
	res["updated_at"] = data[22]
	res["confirmed_at"] = data[23]
	res["closed_at"] = data[24]
	*m = res
	return nil
}

func (ms *TicketHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 25)
	args := make([]interface{}, 25)
	for i := 0; i < 25; i++ {
		args[i] = &data[i]
	}
	res := make(TicketHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketHistory)
		m["id"] = data[0]
		m["code"] = data[1]
		m["assigned_user_ids"] = data[2]
		m["account_id"] = data[3]
		m["label_ids"] = data[4]
		m["ref_ticket_id"] = data[5]
		m["title"] = data[6]
		m["description"] = data[7]
		m["note"] = data[8]
		m["ref_id"] = data[9]
		m["ref_type"] = data[10]
		m["ref_code"] = data[11]
		m["source"] = data[12]
		m["state"] = data[13]
		m["status"] = data[14]
		m["created_by"] = data[15]
		m["created_source"] = data[16]
		m["created_name"] = data[17]
		m["updated_by"] = data[18]
		m["confirmed_by"] = data[19]
		m["closed_by"] = data[20]
		m["created_at"] = data[21]
		m["updated_at"] = data[22]
		m["confirmed_at"] = data[23]
		m["closed_at"] = data[24]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type TicketComments []*TicketComment

const __sqlTicketComment_Table = "ticket_comment"
const __sqlTicketComment_ListCols = "\"id\",\"ticket_id\",\"created_by\",\"created_source\",\"created_name\",\"account_id\",\"parent_id\",\"message\",\"image_urls\",\"deleted_at\",\"deleted_by\",\"created_at\",\"updated_at\""
const __sqlTicketComment_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"ticket_id\" = EXCLUDED.\"ticket_id\",\"created_by\" = EXCLUDED.\"created_by\",\"created_source\" = EXCLUDED.\"created_source\",\"created_name\" = EXCLUDED.\"created_name\",\"account_id\" = EXCLUDED.\"account_id\",\"parent_id\" = EXCLUDED.\"parent_id\",\"message\" = EXCLUDED.\"message\",\"image_urls\" = EXCLUDED.\"image_urls\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"deleted_by\" = EXCLUDED.\"deleted_by\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlTicketComment_Insert = "INSERT INTO \"ticket_comment\" (" + __sqlTicketComment_ListCols + ") VALUES"
const __sqlTicketComment_Select = "SELECT " + __sqlTicketComment_ListCols + " FROM \"ticket_comment\""
const __sqlTicketComment_Select_history = "SELECT " + __sqlTicketComment_ListCols + " FROM history.\"ticket_comment\""
const __sqlTicketComment_UpdateAll = "UPDATE \"ticket_comment\" SET (" + __sqlTicketComment_ListCols + ")"
const __sqlTicketComment_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_comment_pkey DO UPDATE SET"

func (m *TicketComment) SQLTableName() string  { return "ticket_comment" }
func (m *TicketComments) SQLTableName() string { return "ticket_comment" }
func (m *TicketComment) SQLListCols() string   { return __sqlTicketComment_ListCols }

func (m *TicketComment) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicketComment_ListCols + " FROM \"ticket_comment\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *TicketComment) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket_comment"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticket_id": {
			ColumnName:       "ticket_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_by": {
			ColumnName:       "created_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_source": {
			ColumnName:       "created_source",
			ColumnType:       "account_type.AccountType",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"unknown", "partner", "shop", "affiliate", "carrier", "etop"},
		},
		"created_name": {
			ColumnName:       "created_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"parent_id": {
			ColumnName:       "parent_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"message": {
			ColumnName:       "message",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"image_urls": {
			ColumnName:       "image_urls",
			ColumnType:       "[]string",
			ColumnDBType:     "[]string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_by": {
			ColumnName:       "deleted_by",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket_comment", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*TicketComment)(nil))
}

func (m *TicketComment) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.TicketID,
		m.CreatedBy,
		m.CreatedSource,
		core.String(m.CreatedName),
		m.AccountID,
		m.ParentID,
		core.String(m.Message),
		core.Array{m.ImageUrls, opts},
		core.Time(m.DeletedAt),
		m.DeletedBy,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *TicketComment) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.TicketID,
		&m.CreatedBy,
		&m.CreatedSource,
		(*core.String)(&m.CreatedName),
		&m.AccountID,
		&m.ParentID,
		(*core.String)(&m.Message),
		core.Array{&m.ImageUrls, opts},
		(*core.Time)(&m.DeletedAt),
		&m.DeletedBy,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *TicketComment) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *TicketComments) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(TicketComments, 0, 128)
	for rows.Next() {
		m := new(TicketComment)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *TicketComment) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select)
	return nil
}

func (_ *TicketComments) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select)
	return nil
}

func (m *TicketComment) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(13)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms TicketComments) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(13)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *TicketComment) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicketComment_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketComment_ListColsOnConflict)
	return nil
}

func (ms TicketComments) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicketComment_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketComment_ListColsOnConflict)
	return nil
}

func (m *TicketComment) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket_comment")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.TicketID != 0 {
		flag = true
		w.WriteName("ticket_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketID)
	}
	if m.CreatedBy != 0 {
		flag = true
		w.WriteName("created_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedBy)
	}
	if m.CreatedSource != 0 {
		flag = true
		w.WriteName("created_source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedSource)
	}
	if m.CreatedName != "" {
		flag = true
		w.WriteName("created_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedName)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.ParentID != 0 {
		flag = true
		w.WriteName("parent_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ParentID)
	}
	if m.Message != "" {
		flag = true
		w.WriteName("message")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Message)
	}
	if m.ImageUrls != nil {
		flag = true
		w.WriteName("image_urls")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.ImageUrls, opts})
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.DeletedBy != 0 {
		flag = true
		w.WriteName("deleted_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedBy)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if true { // always update time
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *TicketComment) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(13)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketCommentHistory map[string]interface{}
type TicketCommentHistories []map[string]interface{}

func (m *TicketCommentHistory) SQLTableName() string  { return "history.\"ticket_comment\"" }
func (m TicketCommentHistories) SQLTableName() string { return "history.\"ticket_comment\"" }

func (m *TicketCommentHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select_history)
	return nil
}

func (m TicketCommentHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select_history)
	return nil
}

func (m TicketCommentHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m TicketCommentHistory) TicketID() core.Interface  { return core.Interface{m["ticket_id"]} }
func (m TicketCommentHistory) CreatedBy() core.Interface { return core.Interface{m["created_by"]} }
func (m TicketCommentHistory) CreatedSource() core.Interface {
	return core.Interface{m["created_source"]}
}
func (m TicketCommentHistory) CreatedName() core.Interface { return core.Interface{m["created_name"]} }
func (m TicketCommentHistory) AccountID() core.Interface   { return core.Interface{m["account_id"]} }
func (m TicketCommentHistory) ParentID() core.Interface    { return core.Interface{m["parent_id"]} }
func (m TicketCommentHistory) Message() core.Interface     { return core.Interface{m["message"]} }
func (m TicketCommentHistory) ImageUrls() core.Interface   { return core.Interface{m["image_urls"]} }
func (m TicketCommentHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m TicketCommentHistory) DeletedBy() core.Interface   { return core.Interface{m["deleted_by"]} }
func (m TicketCommentHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m TicketCommentHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }

func (m *TicketCommentHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 13)
	args := make([]interface{}, 13)
	for i := 0; i < 13; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketCommentHistory, 13)
	res["id"] = data[0]
	res["ticket_id"] = data[1]
	res["created_by"] = data[2]
	res["created_source"] = data[3]
	res["created_name"] = data[4]
	res["account_id"] = data[5]
	res["parent_id"] = data[6]
	res["message"] = data[7]
	res["image_urls"] = data[8]
	res["deleted_at"] = data[9]
	res["deleted_by"] = data[10]
	res["created_at"] = data[11]
	res["updated_at"] = data[12]
	*m = res
	return nil
}

func (ms *TicketCommentHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 13)
	args := make([]interface{}, 13)
	for i := 0; i < 13; i++ {
		args[i] = &data[i]
	}
	res := make(TicketCommentHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketCommentHistory)
		m["id"] = data[0]
		m["ticket_id"] = data[1]
		m["created_by"] = data[2]
		m["created_source"] = data[3]
		m["created_name"] = data[4]
		m["account_id"] = data[5]
		m["parent_id"] = data[6]
		m["message"] = data[7]
		m["image_urls"] = data[8]
		m["deleted_at"] = data[9]
		m["deleted_by"] = data[10]
		m["created_at"] = data[11]
		m["updated_at"] = data[12]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type TicketExtendeds []*TicketExtended

func (m *TicketExtended) SQLTableName() string  { return "ticket" }
func (m *TicketExtendeds) SQLTableName() string { return "ticket" }

func (m *TicketExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *TicketExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(TicketExtendeds, 0, 128)
	for rows.Next() {
		m := new(TicketExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *TicketExtended) SQLSelect(w SQLWriter) error {
	(*TicketExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*TicketExtended)(nil).__sqlJoin(w)
	return nil
}

func (m *TicketExtendeds) SQLSelect(w SQLWriter) error {
	return (*TicketExtended)(nil).SQLSelect(w)
}

func (m *TicketExtended) SQLJoin(w SQLWriter) error {
	m.__sqlJoin(w)
	return nil
}

func (m *TicketExtendeds) SQLJoin(w SQLWriter) error {
	return (*TicketExtended)(nil).SQLJoin(w)
}

func (m *TicketExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, "t", (*Ticket)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, "ts", (*TicketSearch)(nil).SQLListCols())
}

func (m *TicketExtended) __sqlJoin(w SQLWriter) {
	w.WriteRawString("FROM ")
	w.WriteName("ticket")
	w.WriteRawString(" AS ")
	w.WriteName("t")
	w.WriteRawString(" LEFT JOIN ")
	w.WriteName((*TicketSearch)(nil).SQLTableName())
	w.WriteRawString(" AS ts ON")
	w.WriteQueryString(" t.id = ts.id")
}

func (m *TicketExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Ticket = new(Ticket)
	args = append(args, m.Ticket.SQLScanArgs(opts)...)
	m.TicketSearch = new(TicketSearch)
	args = append(args, m.TicketSearch.SQLScanArgs(opts)...)
	return args
}

type TicketLabels []*TicketLabel

const __sqlTicketLabel_Table = "ticket_label"
const __sqlTicketLabel_ListCols = "\"id\",\"name\",\"code\",\"color\",\"parent_id\""
const __sqlTicketLabel_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"name\" = EXCLUDED.\"name\",\"code\" = EXCLUDED.\"code\",\"color\" = EXCLUDED.\"color\",\"parent_id\" = EXCLUDED.\"parent_id\""
const __sqlTicketLabel_Insert = "INSERT INTO \"ticket_label\" (" + __sqlTicketLabel_ListCols + ") VALUES"
const __sqlTicketLabel_Select = "SELECT " + __sqlTicketLabel_ListCols + " FROM \"ticket_label\""
const __sqlTicketLabel_Select_history = "SELECT " + __sqlTicketLabel_ListCols + " FROM history.\"ticket_label\""
const __sqlTicketLabel_UpdateAll = "UPDATE \"ticket_label\" SET (" + __sqlTicketLabel_ListCols + ")"
const __sqlTicketLabel_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_label_pkey DO UPDATE SET"

func (m *TicketLabel) SQLTableName() string  { return "ticket_label" }
func (m *TicketLabels) SQLTableName() string { return "ticket_label" }
func (m *TicketLabel) SQLListCols() string   { return __sqlTicketLabel_ListCols }

func (m *TicketLabel) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicketLabel_ListCols + " FROM \"ticket_label\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *TicketLabel) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket_label"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"code": {
			ColumnName:       "code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"color": {
			ColumnName:       "color",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"parent_id": {
			ColumnName:       "parent_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket_label", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*TicketLabel)(nil))
}

func (m *TicketLabel) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		core.String(m.Name),
		core.String(m.Code),
		core.String(m.Color),
		m.ParentID,
	}
}

func (m *TicketLabel) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		(*core.String)(&m.Code),
		(*core.String)(&m.Color),
		&m.ParentID,
	}
}

func (m *TicketLabel) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *TicketLabels) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(TicketLabels, 0, 128)
	for rows.Next() {
		m := new(TicketLabel)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *TicketLabel) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Select)
	return nil
}

func (_ *TicketLabels) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Select)
	return nil
}

func (m *TicketLabel) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms TicketLabels) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(5)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *TicketLabel) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicketLabel_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketLabel_ListColsOnConflict)
	return nil
}

func (ms TicketLabels) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicketLabel_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketLabel_ListColsOnConflict)
	return nil
}

func (m *TicketLabel) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket_label")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.Color != "" {
		flag = true
		w.WriteName("color")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Color)
	}
	if m.ParentID != 0 {
		flag = true
		w.WriteName("parent_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ParentID)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *TicketLabel) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketLabelHistory map[string]interface{}
type TicketLabelHistories []map[string]interface{}

func (m *TicketLabelHistory) SQLTableName() string  { return "history.\"ticket_label\"" }
func (m TicketLabelHistories) SQLTableName() string { return "history.\"ticket_label\"" }

func (m *TicketLabelHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Select_history)
	return nil
}

func (m TicketLabelHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketLabel_Select_history)
	return nil
}

func (m TicketLabelHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m TicketLabelHistory) Name() core.Interface     { return core.Interface{m["name"]} }
func (m TicketLabelHistory) Code() core.Interface     { return core.Interface{m["code"]} }
func (m TicketLabelHistory) Color() core.Interface    { return core.Interface{m["color"]} }
func (m TicketLabelHistory) ParentID() core.Interface { return core.Interface{m["parent_id"]} }

func (m *TicketLabelHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketLabelHistory, 5)
	res["id"] = data[0]
	res["name"] = data[1]
	res["code"] = data[2]
	res["color"] = data[3]
	res["parent_id"] = data[4]
	*m = res
	return nil
}

func (ms *TicketLabelHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	res := make(TicketLabelHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketLabelHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["code"] = data[2]
		m["color"] = data[3]
		m["parent_id"] = data[4]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type TicketSearchs []*TicketSearch

const __sqlTicketSearch_Table = "ticket_search"
const __sqlTicketSearch_ListCols = "\"id\",\"title_norm\""
const __sqlTicketSearch_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"title_norm\" = EXCLUDED.\"title_norm\""
const __sqlTicketSearch_Insert = "INSERT INTO \"ticket_search\" (" + __sqlTicketSearch_ListCols + ") VALUES"
const __sqlTicketSearch_Select = "SELECT " + __sqlTicketSearch_ListCols + " FROM \"ticket_search\""
const __sqlTicketSearch_Select_history = "SELECT " + __sqlTicketSearch_ListCols + " FROM history.\"ticket_search\""
const __sqlTicketSearch_UpdateAll = "UPDATE \"ticket_search\" SET (" + __sqlTicketSearch_ListCols + ")"
const __sqlTicketSearch_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_search_pkey DO UPDATE SET"

func (m *TicketSearch) SQLTableName() string  { return "ticket_search" }
func (m *TicketSearchs) SQLTableName() string { return "ticket_search" }
func (m *TicketSearch) SQLListCols() string   { return __sqlTicketSearch_ListCols }

func (m *TicketSearch) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicketSearch_ListCols + " FROM \"ticket_search\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *TicketSearch) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket_search"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"title_norm": {
			ColumnName:       "title_norm",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket_search", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*TicketSearch)(nil))
}

func (m *TicketSearch) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		core.String(m.TitleNorm),
	}
}

func (m *TicketSearch) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.TitleNorm),
	}
}

func (m *TicketSearch) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *TicketSearchs) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(TicketSearchs, 0, 128)
	for rows.Next() {
		m := new(TicketSearch)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *TicketSearch) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Select)
	return nil
}

func (_ *TicketSearchs) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Select)
	return nil
}

func (m *TicketSearch) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms TicketSearchs) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(2)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *TicketSearch) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicketSearch_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketSearch_ListColsOnConflict)
	return nil
}

func (ms TicketSearchs) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicketSearch_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketSearch_ListColsOnConflict)
	return nil
}

func (m *TicketSearch) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket_search")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.TitleNorm != "" {
		flag = true
		w.WriteName("title_norm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TitleNorm)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *TicketSearch) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(2)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketSearchHistory map[string]interface{}
type TicketSearchHistories []map[string]interface{}

func (m *TicketSearchHistory) SQLTableName() string  { return "history.\"ticket_search\"" }
func (m TicketSearchHistories) SQLTableName() string { return "history.\"ticket_search\"" }

func (m *TicketSearchHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Select_history)
	return nil
}

func (m TicketSearchHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketSearch_Select_history)
	return nil
}

func (m TicketSearchHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m TicketSearchHistory) TitleNorm() core.Interface { return core.Interface{m["title_norm"]} }

func (m *TicketSearchHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketSearchHistory, 2)
	res["id"] = data[0]
	res["title_norm"] = data[1]
	*m = res
	return nil
}

func (ms *TicketSearchHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 2)
	args := make([]interface{}, 2)
	for i := 0; i < 2; i++ {
		args[i] = &data[i]
	}
	res := make(TicketSearchHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketSearchHistory)
		m["id"] = data[0]
		m["title_norm"] = data[1]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
