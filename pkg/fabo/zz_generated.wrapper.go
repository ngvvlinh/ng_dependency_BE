// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package fabo

import (
	"context"
	"time"

	api "etop.vn/api/top/int/fabo"
	cm "etop.vn/api/top/types/common"
	common "etop.vn/backend/pkg/common"
	cmwrapper "etop.vn/backend/pkg/common/apifw/wrapper"
	bus "etop.vn/backend/pkg/common/bus"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapPageService(s *PageService) api.PageService {
	return wrapPageService{s: s}
}

type wrapPageService struct {
	s *PageService
}

type ListFbPagesEndpoint struct {
	*api.ListFbPagesRequest
	Result  *api.FbPagesResponse
	Context claims.ShopClaim
}

func (s wrapPageService) ListFbPages(ctx context.Context, req *api.ListFbPagesRequest) (resp *api.FbPagesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "fabo.Page/ListFbPages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListFbPagesEndpoint{ListFbPagesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Include Fabo's information
	if query.Context.Shop != nil {
		getFaboInfoQuery := &middleware.GetFaboInfoQuery{
			ShopID: query.Context.Shop.ID,
			UserID: query.Context.UserID,
		}
		faboInfo, err := middleware.GetFaboInfo(ctx, getFaboInfoQuery)
		if err != nil {
			return nil, err
		}
		query.Context.FaboInfo = faboInfo
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListFbPages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveFbPagesEndpoint struct {
	*api.RemoveFbPagesRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapPageService) RemoveFbPages(ctx context.Context, req *api.RemoveFbPagesRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "fabo.Page/RemoveFbPages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveFbPagesEndpoint{RemoveFbPagesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Include Fabo's information
	if query.Context.Shop != nil {
		getFaboInfoQuery := &middleware.GetFaboInfoQuery{
			ShopID: query.Context.Shop.ID,
			UserID: query.Context.UserID,
		}
		faboInfo, err := middleware.GetFaboInfo(ctx, getFaboInfoQuery)
		if err != nil {
			return nil, err
		}
		query.Context.FaboInfo = faboInfo
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveFbPages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSessionService(s *SessionService) api.SessionService {
	return wrapSessionService{s: s}
}

type wrapSessionService struct {
	s *SessionService
}

type InitSessionEndpoint struct {
	*api.InitSessionRequest
	Result  *api.InitSessionResponse
	Context claims.ShopClaim
}

func (s wrapSessionService) InitSession(ctx context.Context, req *api.InitSessionRequest) (resp *api.InitSessionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "fabo.Session/InitSession"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &InitSessionEndpoint{InitSessionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.InitSession(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
