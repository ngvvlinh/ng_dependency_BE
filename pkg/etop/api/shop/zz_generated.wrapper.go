// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package shop

import (
	"context"
	"strings"
	"time"

	cm "etop.vn/api/pb/common"
	etop "etop.vn/api/pb/etop"
	order "etop.vn/api/pb/etop/order"
	shop "etop.vn/api/pb/etop/shop"
	api "etop.vn/api/top/int/shop"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	"etop.vn/backend/pkg/etop/authorize/auth"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	model "etop.vn/backend/pkg/etop/model"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type CreateExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *shop.ExternalAccountAhamove
	Context claims.ShopClaim
}

func (s wrapAccountService) CreateExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *shop.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/CreateExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShopEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapAccountService) DeleteShop(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/DeleteShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/account:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/account:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBalanceShopEndpoint struct {
	*cm.Empty
	Result  *shop.GetBalanceShopResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) GetBalanceShop(ctx context.Context, req *cm.Empty) (resp *shop.GetBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetBalanceShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBalanceShopEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/balance:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/balance:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBalanceShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *shop.ExternalAccountAhamove
	Context claims.ShopClaim
}

func (s wrapAccountService) GetExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *shop.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterShopEndpoint struct {
	*shop.RegisterShopRequest
	Result     *shop.RegisterShopResponse
	Context    claims.UserClaim
	CtxPartner *model.Partner
}

func (s wrapAccountService) RegisterShop(ctx context.Context, req *shop.RegisterShopRequest) (resp *shop.RegisterShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RegisterShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterShopEndpoint{RegisterShopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = s.s.RegisterShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RequestVerifyExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) RequestVerifyExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RequestVerifyExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestVerifyExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RequestVerifyExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SetDefaultAddressEndpoint struct {
	*etop.SetDefaultAddressRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) SetDefaultAddress(ctx context.Context, req *etop.SetDefaultAddressRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/SetDefaultAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultAddressEndpoint{SetDefaultAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/settings/shop_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/settings/shop_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SetDefaultAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateExternalAccountAhamoveVerificationEndpoint struct {
	*shop.UpdateXAccountAhamoveVerificationRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateExternalAccountAhamoveVerification(ctx context.Context, req *shop.UpdateXAccountAhamoveVerificationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateExternalAccountAhamoveVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountAhamoveVerificationEndpoint{UpdateXAccountAhamoveVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateExternalAccountAhamoveVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateExternalAccountAhamoveVerificationImagesEndpoint struct {
	*shop.UpdateXAccountAhamoveVerificationRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateExternalAccountAhamoveVerificationImages(ctx context.Context, req *shop.UpdateXAccountAhamoveVerificationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateExternalAccountAhamoveVerificationImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountAhamoveVerificationImagesEndpoint{UpdateXAccountAhamoveVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateExternalAccountAhamoveVerificationImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShopEndpoint struct {
	*shop.UpdateShopRequest
	Result  *shop.UpdateShopResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateShop(ctx context.Context, req *shop.UpdateShopRequest) (resp *shop.UpdateShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShopEndpoint{UpdateShopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/settings/shop_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/settings/shop_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapAuthorizeService(s *AuthorizeService) api.AuthorizeService {
	return wrapAuthorizeService{s: s}
}

type wrapAuthorizeService struct {
	s *AuthorizeService
}

type AuthorizePartnerEndpoint struct {
	*shop.AuthorizePartnerRequest
	Result  *shop.AuthorizedPartnerResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) AuthorizePartner(ctx context.Context, req *shop.AuthorizePartnerRequest) (resp *shop.AuthorizedPartnerResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/AuthorizePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AuthorizePartnerEndpoint{AuthorizePartnerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AuthorizePartner(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAuthorizedPartnersEndpoint struct {
	*cm.Empty
	Result  *shop.GetAuthorizedPartnersResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) GetAuthorizedPartners(ctx context.Context, req *cm.Empty) (resp *shop.GetAuthorizedPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAuthorizedPartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAuthorizedPartnersEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAuthorizedPartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAvailablePartnersEndpoint struct {
	*cm.Empty
	Result  *shop.GetPartnersResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) GetAvailablePartners(ctx context.Context, req *cm.Empty) (resp *shop.GetPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAvailablePartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAvailablePartnersEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAvailablePartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapBrandService(s *BrandService) api.BrandService {
	return wrapBrandService{s: s}
}

type wrapBrandService struct {
	s *BrandService
}

type CreateBrandEndpoint struct {
	*shop.CreateBrandRequest
	Result  *shop.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) CreateBrand(ctx context.Context, req *shop.CreateBrandRequest) (resp *shop.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/CreateBrand"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateBrandEndpoint{CreateBrandRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateBrand(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteBrandEndpoint struct {
	*cm.IDsRequest
	Result  *shop.DeleteBrandResponse
	Context claims.ShopClaim
}

func (s wrapBrandService) DeleteBrand(ctx context.Context, req *cm.IDsRequest) (resp *shop.DeleteBrandResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/DeleteBrand"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteBrandEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteBrand(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandByIDEndpoint struct {
	*cm.IDRequest
	Result  *shop.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) GetBrandByID(ctx context.Context, req *cm.IDRequest) (resp *shop.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrandByID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandByIDEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrandByID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandsEndpoint struct {
	*shop.GetBrandsRequest
	Result     *shop.GetBrandsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapBrandService) GetBrands(ctx context.Context, req *shop.GetBrandsRequest) (resp *shop.GetBrandsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrands"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandsEndpoint{GetBrandsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrands(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.GetBrandsByIDsResponse
	Context claims.ShopClaim
}

func (s wrapBrandService) GetBrandsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.GetBrandsByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrandsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandsByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrandsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateBrandInfoEndpoint struct {
	*shop.UpdateBrandRequest
	Result  *shop.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) UpdateBrandInfo(ctx context.Context, req *shop.UpdateBrandRequest) (resp *shop.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/UpdateBrandInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateBrandInfoEndpoint{UpdateBrandRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateBrandInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCarrierService(s *CarrierService) api.CarrierService {
	return wrapCarrierService{s: s}
}

type wrapCarrierService struct {
	s *CarrierService
}

type CreateCarrierEndpoint struct {
	*shop.CreateCarrierRequest
	Result  *shop.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) CreateCarrier(ctx context.Context, req *shop.CreateCarrierRequest) (resp *shop.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/CreateCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCarrierEndpoint{CreateCarrierRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCarrierEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) DeleteCarrier(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/DeleteCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCarrierEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarrierEndpoint struct {
	*cm.IDRequest
	Result  *shop.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarrier(ctx context.Context, req *cm.IDRequest) (resp *shop.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarrierEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarriersEndpoint struct {
	*shop.GetCarriersRequest
	Result  *shop.CarriersResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarriers(ctx context.Context, req *shop.GetCarriersRequest) (resp *shop.CarriersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarriers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarriersEndpoint{GetCarriersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarriers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarriersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.CarriersResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarriersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.CarriersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarriersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarriersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarriersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCarrierEndpoint struct {
	*shop.UpdateCarrierRequest
	Result  *shop.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) UpdateCarrier(ctx context.Context, req *shop.UpdateCarrierRequest) (resp *shop.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/UpdateCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCarrierEndpoint{UpdateCarrierRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/carrier:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCategoryService(s *CategoryService) api.CategoryService {
	return wrapCategoryService{s: s}
}

type wrapCategoryService struct {
	s *CategoryService
}

type CreateCategoryEndpoint struct {
	*shop.CreateCategoryRequest
	Result  *shop.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) CreateCategory(ctx context.Context, req *shop.CreateCategoryRequest) (resp *shop.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/CreateCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCategoryEndpoint{CreateCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/category:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCategoryEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCategoryService) DeleteCategory(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/DeleteCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/category:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCategoriesEndpoint struct {
	*shop.GetCategoriesRequest
	Result  *shop.ShopCategoriesResponse
	Context claims.ShopClaim
}

func (s wrapCategoryService) GetCategories(ctx context.Context, req *shop.GetCategoriesRequest) (resp *shop.ShopCategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/GetCategories"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCategoriesEndpoint{GetCategoriesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/category:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCategories(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCategoryEndpoint struct {
	*cm.IDRequest
	Result  *shop.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) GetCategory(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/GetCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/category:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCategoryEndpoint struct {
	*shop.UpdateCategoryRequest
	Result  *shop.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) UpdateCategory(ctx context.Context, req *shop.UpdateCategoryRequest) (resp *shop.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/UpdateCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCategoryEndpoint{UpdateCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/category:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCollectionService(s *CollectionService) api.CollectionService {
	return wrapCollectionService{s: s}
}

type wrapCollectionService struct {
	s *CollectionService
}

type CreateCollectionEndpoint struct {
	*shop.CreateCollectionRequest
	Result  *shop.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) CreateCollection(ctx context.Context, req *shop.CreateCollectionRequest) (resp *shop.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/CreateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCollectionEndpoint{CreateCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/collection:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionEndpoint struct {
	*cm.IDRequest
	Result  *shop.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollection(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionsEndpoint struct {
	*shop.GetCollectionsRequest
	Result  *shop.ShopCollectionsResponse
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollections(ctx context.Context, req *shop.GetCollectionsRequest) (resp *shop.ShopCollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsEndpoint{GetCollectionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionsByProductIDEndpoint struct {
	*shop.GetShopCollectionsByProductIDRequest
	Result  *shop.CollectionsResponse
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollectionsByProductID(ctx context.Context, req *shop.GetShopCollectionsByProductIDRequest) (resp *shop.CollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollectionsByProductID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsByProductIDEndpoint{GetShopCollectionsByProductIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollectionsByProductID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCollectionEndpoint struct {
	*shop.UpdateCollectionRequest
	Result  *shop.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) UpdateCollection(ctx context.Context, req *shop.UpdateCollectionRequest) (resp *shop.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/UpdateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCollectionEndpoint{UpdateCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/collection:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerService(s *CustomerService) api.CustomerService {
	return wrapCustomerService{s: s}
}

type wrapCustomerService struct {
	s *CustomerService
}

type AddCustomersToGroupEndpoint struct {
	*shop.AddCustomerToGroupRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) AddCustomersToGroup(ctx context.Context, req *shop.AddCustomerToGroupRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/AddCustomersToGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddCustomersToGroupEndpoint{AddCustomerToGroupRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddCustomersToGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type BatchSetCustomersStatusEndpoint struct {
	*shop.SetCustomersStatusRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) BatchSetCustomersStatus(ctx context.Context, req *shop.SetCustomersStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/BatchSetCustomersStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &BatchSetCustomersStatusEndpoint{SetCustomersStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.BatchSetCustomersStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCustomerEndpoint struct {
	*shop.CreateCustomerRequest
	Result  *shop.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) CreateCustomer(ctx context.Context, req *shop.CreateCustomerRequest) (resp *shop.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/CreateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerEndpoint{CreateCustomerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCustomerAddressEndpoint struct {
	*shop.CreateCustomerAddressRequest
	Result  *shop.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerService) CreateCustomerAddress(ctx context.Context, req *shop.CreateCustomerAddressRequest) (resp *shop.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/CreateCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerAddressEndpoint{CreateCustomerAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:create|shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:create|shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomerEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) DeleteCustomer(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/DeleteCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomerEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomerAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) DeleteCustomerAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/DeleteCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomerAddressEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:update|shop/customer:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update|shop/customer:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerEndpoint struct {
	*cm.IDRequest
	Result  *shop.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomer(ctx context.Context, req *cm.IDRequest) (resp *shop.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerAddressesEndpoint struct {
	*shop.GetCustomerAddressesRequest
	Result  *shop.CustomerAddressesResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomerAddresses(ctx context.Context, req *shop.GetCustomerAddressesRequest) (resp *shop.CustomerAddressesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomerAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerAddressesEndpoint{GetCustomerAddressesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerDetailsEndpoint struct {
	*cm.IDRequest
	Result  *shop.CustomerDetailsResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomerDetails(ctx context.Context, req *cm.IDRequest) (resp *shop.CustomerDetailsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomerDetails"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerDetailsEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerDetails(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomersEndpoint struct {
	*shop.GetCustomersRequest
	Result  *shop.CustomersResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomers(ctx context.Context, req *shop.GetCustomersRequest) (resp *shop.CustomersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomersEndpoint{GetCustomersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.CustomersResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.CustomersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveCustomersFromGroupEndpoint struct {
	*shop.RemoveCustomerOutOfGroupRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) RemoveCustomersFromGroup(ctx context.Context, req *shop.RemoveCustomerOutOfGroupRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/RemoveCustomersFromGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveCustomersFromGroupEndpoint{RemoveCustomerOutOfGroupRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveCustomersFromGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SetDefaultCustomerAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) SetDefaultCustomerAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/SetDefaultCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultCustomerAddressEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SetDefaultCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerEndpoint struct {
	*shop.UpdateCustomerRequest
	Result  *shop.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) UpdateCustomer(ctx context.Context, req *shop.UpdateCustomerRequest) (resp *shop.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/UpdateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerEndpoint{UpdateCustomerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerAddressEndpoint struct {
	*shop.UpdateCustomerAddressRequest
	Result  *shop.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerService) UpdateCustomerAddress(ctx context.Context, req *shop.UpdateCustomerAddressRequest) (resp *shop.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/UpdateCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerAddressEndpoint{UpdateCustomerAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerGroupService(s *CustomerGroupService) api.CustomerGroupService {
	return wrapCustomerGroupService{s: s}
}

type wrapCustomerGroupService struct {
	s *CustomerGroupService
}

type CreateCustomerGroupEndpoint struct {
	*shop.CreateCustomerGroupRequest
	Result  *shop.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) CreateCustomerGroup(ctx context.Context, req *shop.CreateCustomerGroupRequest) (resp *shop.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/CreateCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerGroupEndpoint{CreateCustomerGroupRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer_group:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer_group:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerGroupEndpoint struct {
	*cm.IDRequest
	Result  *shop.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) GetCustomerGroup(ctx context.Context, req *cm.IDRequest) (resp *shop.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/GetCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerGroupEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerGroupsEndpoint struct {
	*shop.GetCustomerGroupsRequest
	Result  *shop.CustomerGroupsResponse
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) GetCustomerGroups(ctx context.Context, req *shop.GetCustomerGroupsRequest) (resp *shop.CustomerGroupsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/GetCustomerGroups"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerGroupsEndpoint{GetCustomerGroupsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerGroups(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerGroupEndpoint struct {
	*shop.UpdateCustomerGroupRequest
	Result  *shop.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) UpdateCustomerGroup(ctx context.Context, req *shop.UpdateCustomerGroupRequest) (resp *shop.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/UpdateCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerGroupEndpoint{UpdateCustomerGroupRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/customer_group:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer_group:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapExportService(s *ExportService) api.ExportService {
	return wrapExportService{s: s}
}

type wrapExportService struct {
	s *ExportService
}

type GetExportsEndpoint struct {
	*shop.GetExportsRequest
	Result  *shop.GetExportsResponse
	Context claims.ShopClaim
}

func (s wrapExportService) GetExports(ctx context.Context, req *shop.GetExportsRequest) (resp *shop.GetExportsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/GetExports"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExportsEndpoint{GetExportsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExports(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RequestExportEndpoint struct {
	*shop.RequestExportRequest
	Result  *shop.RequestExportResponse
	Context claims.ShopClaim
}

func (s wrapExportService) RequestExport(ctx context.Context, req *shop.RequestExportRequest) (resp *shop.RequestExportResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/RequestExport"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestExportEndpoint{RequestExportRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RequestExport(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapExternalAccountService(s *ExternalAccountService) api.ExternalAccountService {
	return wrapExternalAccountService{s: s}
}

type wrapExternalAccountService struct {
	s *ExternalAccountService
}

type ConnectCarrierServiceExternalAccountHaravanEndpoint struct {
	*cm.Empty
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapExternalAccountService) ConnectCarrierServiceExternalAccountHaravan(ctx context.Context, req *cm.Empty) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ExternalAccount/ConnectCarrierServiceExternalAccountHaravan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConnectCarrierServiceExternalAccountHaravanEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConnectCarrierServiceExternalAccountHaravan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateExternalAccountHaravanEndpoint struct {
	*shop.ExternalAccountHaravanRequest
	Result  *shop.ExternalAccountHaravan
	Context claims.ShopClaim
}

func (s wrapExternalAccountService) CreateExternalAccountHaravan(ctx context.Context, req *shop.ExternalAccountHaravanRequest) (resp *shop.ExternalAccountHaravan, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ExternalAccount/CreateExternalAccountHaravan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateExternalAccountHaravanEndpoint{ExternalAccountHaravanRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateExternalAccountHaravan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteConnectedCarrierServiceExternalAccountHaravanEndpoint struct {
	*cm.Empty
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapExternalAccountService) DeleteConnectedCarrierServiceExternalAccountHaravan(ctx context.Context, req *cm.Empty) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ExternalAccount/DeleteConnectedCarrierServiceExternalAccountHaravan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteConnectedCarrierServiceExternalAccountHaravanEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteConnectedCarrierServiceExternalAccountHaravan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetExternalAccountHaravanEndpoint struct {
	*cm.Empty
	Result  *shop.ExternalAccountHaravan
	Context claims.ShopClaim
}

func (s wrapExternalAccountService) GetExternalAccountHaravan(ctx context.Context, req *cm.Empty) (resp *shop.ExternalAccountHaravan, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ExternalAccount/GetExternalAccountHaravan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalAccountHaravanEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExternalAccountHaravan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateExternalAccountHaravanTokenEndpoint struct {
	*shop.ExternalAccountHaravanRequest
	Result  *shop.ExternalAccountHaravan
	Context claims.ShopClaim
}

func (s wrapExternalAccountService) UpdateExternalAccountHaravanToken(ctx context.Context, req *shop.ExternalAccountHaravanRequest) (resp *shop.ExternalAccountHaravan, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ExternalAccount/UpdateExternalAccountHaravanToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountHaravanTokenEndpoint{ExternalAccountHaravanRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateExternalAccountHaravanToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s *FulfillmentService) api.FulfillmentService {
	return wrapFulfillmentService{s: s}
}

type wrapFulfillmentService struct {
	s *FulfillmentService
}

type GetExternalShippingServicesEndpoint struct {
	*order.GetExternalShippingServicesRequest
	Result     *order.GetExternalShippingServicesResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapFulfillmentService) GetExternalShippingServices(ctx context.Context, req *order.GetExternalShippingServicesRequest) (resp *order.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/fulfillment:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExternalShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result     *order.Fulfillment
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/fulfillment:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsEndpoint struct {
	*shop.GetFulfillmentsRequest
	Result     *order.FulfillmentsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapFulfillmentService) GetFulfillments(ctx context.Context, req *shop.GetFulfillmentsRequest) (resp *order.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/fulfillment:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicExternalShippingServicesEndpoint struct {
	*order.GetExternalShippingServicesRequest
	Result  *order.GetExternalShippingServicesResponse
	Context claims.EmptyClaim
}

func (s wrapFulfillmentService) GetPublicExternalShippingServices(ctx context.Context, req *order.GetExternalShippingServicesRequest) (resp *order.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetPublicExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicExternalShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicFulfillmentEndpoint struct {
	*shop.GetPublicFulfillmentRequest
	Result  *order.PublicFulfillment
	Context claims.EmptyClaim
}

func (s wrapFulfillmentService) GetPublicFulfillment(ctx context.Context, req *shop.GetPublicFulfillmentRequest) (resp *order.PublicFulfillment, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetPublicFulfillmentEndpoint{GetPublicFulfillmentRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentsShippingStateEndpoint struct {
	*shop.UpdateFulfillmentsShippingStateRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentsShippingState(ctx context.Context, req *shop.UpdateFulfillmentsShippingStateRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/UpdateFulfillmentsShippingState"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentsShippingStateEndpoint{UpdateFulfillmentsShippingStateRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillmentsShippingState(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapHistoryService(s *HistoryService) api.HistoryService {
	return wrapHistoryService{s: s}
}

type wrapHistoryService struct {
	s *HistoryService
}

type GetFulfillmentHistoryEndpoint struct {
	*shop.GetFulfillmentHistoryRequest
	Result     *etop.HistoryResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapHistoryService) GetFulfillmentHistory(ctx context.Context, req *shop.GetFulfillmentHistoryRequest) (resp *etop.HistoryResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.History/GetFulfillmentHistory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentHistoryEndpoint{GetFulfillmentHistoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillmentHistory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapInventoryService(s *InventoryService) api.InventoryService {
	return wrapInventoryService{s: s}
}

type wrapInventoryService struct {
	s *InventoryService
}

type AdjustInventoryQuantityEndpoint struct {
	*shop.AdjustInventoryQuantityRequest
	Result  *shop.AdjustInventoryQuantityResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) AdjustInventoryQuantity(ctx context.Context, req *shop.AdjustInventoryQuantityRequest) (resp *shop.AdjustInventoryQuantityResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/AdjustInventoryQuantity"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdjustInventoryQuantityEndpoint{AdjustInventoryQuantityRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AdjustInventoryQuantity(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CancelInventoryVoucherEndpoint struct {
	*shop.CancelInventoryVoucherRequest
	Result  *shop.CancelInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) CancelInventoryVoucher(ctx context.Context, req *shop.CancelInventoryVoucherRequest) (resp *shop.CancelInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/CancelInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelInventoryVoucherEndpoint{CancelInventoryVoucherRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmInventoryVoucherEndpoint struct {
	*shop.ConfirmInventoryVoucherRequest
	Result  *shop.ConfirmInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) ConfirmInventoryVoucher(ctx context.Context, req *shop.ConfirmInventoryVoucherRequest) (resp *shop.ConfirmInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/ConfirmInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmInventoryVoucherEndpoint{ConfirmInventoryVoucherRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateInventoryVoucherEndpoint struct {
	*shop.CreateInventoryVoucherRequest
	Result  *shop.CreateInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) CreateInventoryVoucher(ctx context.Context, req *shop.CreateInventoryVoucherRequest) (resp *shop.CreateInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/CreateInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateInventoryVoucherEndpoint{CreateInventoryVoucherRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantEndpoint struct {
	*shop.GetInventoryVariantRequest
	Result  *shop.InventoryVariant
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariant(ctx context.Context, req *shop.GetInventoryVariantRequest) (resp *shop.InventoryVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantEndpoint{GetInventoryVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantsEndpoint struct {
	*shop.GetInventoryVariantsRequest
	Result  *shop.GetInventoryVariantsResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariants(ctx context.Context, req *shop.GetInventoryVariantsRequest) (resp *shop.GetInventoryVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariants"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantsEndpoint{GetInventoryVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariants(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantsByVariantIDsEndpoint struct {
	*shop.GetInventoryVariantsByVariantIDsRequest
	Result  *shop.GetInventoryVariantsResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariantsByVariantIDs(ctx context.Context, req *shop.GetInventoryVariantsByVariantIDsRequest) (resp *shop.GetInventoryVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariantsByVariantIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantsByVariantIDsEndpoint{GetInventoryVariantsByVariantIDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariantsByVariantIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVoucherEndpoint struct {
	*cm.IDRequest
	Result  *shop.InventoryVoucher
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVoucher(ctx context.Context, req *cm.IDRequest) (resp *shop.InventoryVoucher, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVoucherEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersEndpoint struct {
	*shop.GetInventoryVouchersRequest
	Result  *shop.GetInventoryVouchersResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchers(ctx context.Context, req *shop.GetInventoryVouchersRequest) (resp *shop.GetInventoryVouchersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersEndpoint{GetInventoryVouchersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersByIDsEndpoint struct {
	*shop.GetInventoryVouchersByIDsRequest
	Result  *shop.GetInventoryVouchersResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchersByIDs(ctx context.Context, req *shop.GetInventoryVouchersByIDsRequest) (resp *shop.GetInventoryVouchersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersByIDsEndpoint{GetInventoryVouchersByIDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersByReferenceEndpoint struct {
	*shop.GetInventoryVouchersByReferenceRequest
	Result  *shop.GetInventoryVouchersByReferenceResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchersByReference(ctx context.Context, req *shop.GetInventoryVouchersByReferenceRequest) (resp *shop.GetInventoryVouchersByReferenceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchersByReference"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersByReferenceEndpoint{GetInventoryVouchersByReferenceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchersByReference(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateInventoryVariantCostPriceEndpoint struct {
	*shop.UpdateInventoryVariantCostPriceRequest
	Result  *shop.UpdateInventoryVariantCostPriceResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) UpdateInventoryVariantCostPrice(ctx context.Context, req *shop.UpdateInventoryVariantCostPriceRequest) (resp *shop.UpdateInventoryVariantCostPriceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/UpdateInventoryVariantCostPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateInventoryVariantCostPriceEndpoint{UpdateInventoryVariantCostPriceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/cost_price:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/cost_price:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateInventoryVariantCostPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateInventoryVoucherEndpoint struct {
	*shop.UpdateInventoryVoucherRequest
	Result  *shop.UpdateInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) UpdateInventoryVoucher(ctx context.Context, req *shop.UpdateInventoryVoucherRequest) (resp *shop.UpdateInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/UpdateInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateInventoryVoucherEndpoint{UpdateInventoryVoucherRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/inventory:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapLedgerService(s *LedgerService) api.LedgerService {
	return wrapLedgerService{s: s}
}

type wrapLedgerService struct {
	s *LedgerService
}

type CreateLedgerEndpoint struct {
	*shop.CreateLedgerRequest
	Result  *shop.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) CreateLedger(ctx context.Context, req *shop.CreateLedgerRequest) (resp *shop.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/CreateLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateLedgerEndpoint{CreateLedgerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/ledger:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteLedgerEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapLedgerService) DeleteLedger(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/DeleteLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteLedgerEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/ledger:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetLedgerEndpoint struct {
	*cm.IDRequest
	Result  *shop.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) GetLedger(ctx context.Context, req *cm.IDRequest) (resp *shop.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/GetLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLedgerEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/ledger:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetLedgersEndpoint struct {
	*shop.GetLedgersRequest
	Result  *shop.LedgersResponse
	Context claims.ShopClaim
}

func (s wrapLedgerService) GetLedgers(ctx context.Context, req *shop.GetLedgersRequest) (resp *shop.LedgersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/GetLedgers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLedgersEndpoint{GetLedgersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/ledger:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetLedgers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateLedgerEndpoint struct {
	*shop.UpdateLedgerRequest
	Result  *shop.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) UpdateLedger(ctx context.Context, req *shop.UpdateLedgerRequest) (resp *shop.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/UpdateLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateLedgerEndpoint{UpdateLedgerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/ledger:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMoneyTransactionService(s *MoneyTransactionService) api.MoneyTransactionService {
	return wrapMoneyTransactionService{s: s}
}

type wrapMoneyTransactionService struct {
	s *MoneyTransactionService
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransaction
	Context claims.ShopClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/money_transaction:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/money_transaction:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionsEndpoint struct {
	*shop.GetMoneyTransactionsRequest
	Result  *order.MoneyTransactionsResponse
	Context claims.ShopClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *shop.GetMoneyTransactionsRequest) (resp *order.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/money_transaction:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/money_transaction:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapNotificationService(s *NotificationService) api.NotificationService {
	return wrapNotificationService{s: s}
}

type wrapNotificationService struct {
	s *NotificationService
}

type CreateDeviceEndpoint struct {
	*etop.CreateDeviceRequest
	Result  *etop.Device
	Context claims.ShopClaim
}

func (s wrapNotificationService) CreateDevice(ctx context.Context, req *etop.CreateDeviceRequest) (resp *etop.Device, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/CreateDevice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateDeviceEndpoint{CreateDeviceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateDevice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteDeviceEndpoint struct {
	*etop.DeleteDeviceRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) DeleteDevice(ctx context.Context, req *etop.DeleteDeviceRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/DeleteDevice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteDeviceEndpoint{DeleteDeviceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteDevice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetNotificationEndpoint struct {
	*cm.IDRequest
	Result  *etop.Notification
	Context claims.ShopClaim
}

func (s wrapNotificationService) GetNotification(ctx context.Context, req *cm.IDRequest) (resp *etop.Notification, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetNotification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetNotificationsEndpoint struct {
	*etop.GetNotificationsRequest
	Result  *etop.NotificationsResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) GetNotifications(ctx context.Context, req *etop.GetNotificationsRequest) (resp *etop.NotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationsEndpoint{GetNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateNotificationsEndpoint struct {
	*etop.UpdateNotificationsRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) UpdateNotifications(ctx context.Context, req *etop.UpdateNotificationsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/UpdateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateNotificationsEndpoint{UpdateNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s *OrderService) api.OrderService {
	return wrapOrderService{s: s}
}

type wrapOrderService struct {
	s *OrderService
}

type CancelOrderEndpoint struct {
	*shop.CancelOrderRequest
	Result     *order.OrderWithErrorsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) CancelOrder(ctx context.Context, req *shop.CancelOrderRequest) (resp *order.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelOrderEndpoint{CancelOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmOrderEndpoint struct {
	*shop.ConfirmOrderRequest
	Result     *order.Order
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) ConfirmOrder(ctx context.Context, req *shop.ConfirmOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrderEndpoint{ConfirmOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmOrderAndCreateFulfillmentsEndpoint struct {
	*shop.OrderIDRequest
	Result     *order.OrderWithErrorsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) ConfirmOrderAndCreateFulfillments(ctx context.Context, req *shop.OrderIDRequest) (resp *order.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrderAndCreateFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrderAndCreateFulfillmentsEndpoint{OrderIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmOrderAndCreateFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateOrderEndpoint struct {
	*order.CreateOrderRequest
	Result     *order.Order
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) CreateOrder(ctx context.Context, req *order.CreateOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CreateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrderEndpoint{CreateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result     *order.Order
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersEndpoint struct {
	*shop.GetOrdersRequest
	Result     *order.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) GetOrders(ctx context.Context, req *shop.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByIDsEndpoint struct {
	*etop.IDsRequest
	Result     *order.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) GetOrdersByIDs(ctx context.Context, req *etop.IDsRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByReceiptIDEndpoint struct {
	*shop.GetOrdersByReceiptIDRequest
	Result     *order.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) GetOrdersByReceiptID(ctx context.Context, req *shop.GetOrdersByReceiptIDRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrdersByReceiptID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByReceiptIDEndpoint{GetOrdersByReceiptIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByReceiptID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderEndpoint struct {
	*order.UpdateOrderRequest
	Result     *order.Order
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) UpdateOrder(ctx context.Context, req *order.UpdateOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderEndpoint{UpdateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderPaymentStatusEndpoint struct {
	*shop.UpdateOrderPaymentStatusRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) UpdateOrderPaymentStatus(ctx context.Context, req *shop.UpdateOrderPaymentStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrderPaymentStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderPaymentStatusEndpoint{UpdateOrderPaymentStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrderPaymentStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderShippingInfoEndpoint struct {
	*shop.UpdateOrderShippingInfoRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) UpdateOrderShippingInfo(ctx context.Context, req *shop.UpdateOrderShippingInfoRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrderShippingInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderShippingInfoEndpoint{UpdateOrderShippingInfoRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrderShippingInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrdersStatusEndpoint struct {
	*shop.UpdateOrdersStatusRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapOrderService) UpdateOrdersStatus(ctx context.Context, req *shop.UpdateOrdersStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrdersStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrdersStatusEndpoint{UpdateOrdersStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrdersStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapPaymentService(s *PaymentService) api.PaymentService {
	return wrapPaymentService{s: s}
}

type wrapPaymentService struct {
	s *PaymentService
}

type PaymentCheckReturnDataEndpoint struct {
	*shop.PaymentCheckReturnDataRequest
	Result  *cm.MessageResponse
	Context claims.ShopClaim
}

func (s wrapPaymentService) PaymentCheckReturnData(ctx context.Context, req *shop.PaymentCheckReturnDataRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Payment/PaymentCheckReturnData"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &PaymentCheckReturnDataEndpoint{PaymentCheckReturnDataRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.PaymentCheckReturnData(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type PaymentTradingOrderEndpoint struct {
	*shop.PaymentTradingOrderRequest
	Result  *shop.PaymentTradingOrderResponse
	Context claims.ShopClaim
}

func (s wrapPaymentService) PaymentTradingOrder(ctx context.Context, req *shop.PaymentTradingOrderRequest) (resp *shop.PaymentTradingOrderResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Payment/PaymentTradingOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &PaymentTradingOrderEndpoint{PaymentTradingOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.PaymentTradingOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductService(s *ProductService) api.ProductService {
	return wrapProductService{s: s}
}

type wrapProductService struct {
	s *ProductService
}

type AddProductCollectionEndpoint struct {
	*shop.AddShopProductCollectionRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) AddProductCollection(ctx context.Context, req *shop.AddShopProductCollectionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/AddProductCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddProductCollectionEndpoint{AddShopProductCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddProductCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateProductEndpoint struct {
	*shop.CreateProductRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) CreateProduct(ctx context.Context, req *shop.CreateProductRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/CreateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductEndpoint{CreateProductRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateVariantEndpoint struct {
	*shop.CreateVariantRequest
	Result  *shop.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) CreateVariant(ctx context.Context, req *shop.CreateVariantRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/CreateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateVariantEndpoint{CreateVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductEndpoint struct {
	*cm.IDRequest
	Result     *shop.ShopProduct
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductService) GetProduct(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductsEndpoint struct {
	*shop.GetVariantsRequest
	Result     *shop.ShopProductsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductService) GetProducts(ctx context.Context, req *shop.GetVariantsRequest) (resp *shop.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsEndpoint{GetVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductsByIDsEndpoint struct {
	*cm.IDsRequest
	Result     *shop.ShopProductsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductService) GetProductsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProductsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantEndpoint struct {
	*cm.IDRequest
	Result     *shop.ShopVariant
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductService) GetVariant(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantsByIDsEndpoint struct {
	*cm.IDsRequest
	Result     *shop.ShopVariantsResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductService) GetVariantsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.ShopVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariantsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantsByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariantsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantsBySupplierIDEndpoint struct {
	*shop.GetVariantsBySupplierIDRequest
	Result  *shop.ShopVariantsResponse
	Context claims.ShopClaim
}

func (s wrapProductService) GetVariantsBySupplierID(ctx context.Context, req *shop.GetVariantsBySupplierIDRequest) (resp *shop.ShopVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariantsBySupplierID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantsBySupplierIDEndpoint{GetVariantsBySupplierIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariantsBySupplierID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductCategoryEndpoint struct {
	*cm.IDRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProductCategory(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProductCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update|shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update|shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductCollectionEndpoint struct {
	*shop.RemoveShopProductCollectionRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProductCollection(ctx context.Context, req *shop.RemoveShopProductCollectionRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProductCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductCollectionEndpoint{RemoveShopProductCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update|shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update|shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductsEndpoint struct {
	*shop.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProducts(ctx context.Context, req *shop.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductsEndpoint{RemoveVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveVariantsEndpoint struct {
	*shop.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveVariants(ctx context.Context, req *shop.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveVariants"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveVariantsEndpoint{RemoveVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:delete|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveVariants(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductEndpoint struct {
	*shop.UpdateProductRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProduct(ctx context.Context, req *shop.UpdateProductRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductEndpoint{UpdateProductRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductCategoryEndpoint struct {
	*shop.UpdateProductCategoryRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductCategory(ctx context.Context, req *shop.UpdateProductCategoryRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductCategoryEndpoint{UpdateProductCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductImagesEndpoint struct {
	*shop.UpdateVariantImagesRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductImages(ctx context.Context, req *shop.UpdateVariantImagesRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductImagesEndpoint{UpdateVariantImagesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductMetaFieldsEndpoint struct {
	*shop.UpdateProductMetaFieldsRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductMetaFields(ctx context.Context, req *shop.UpdateProductMetaFieldsRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductMetaFields"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductMetaFieldsEndpoint{UpdateProductMetaFieldsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductMetaFields(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsStatusEndpoint struct {
	*shop.UpdateProductStatusRequest
	Result  *shop.UpdateProductStatusResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductsStatus(ctx context.Context, req *shop.UpdateProductStatusRequest) (resp *shop.UpdateProductStatusResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductsStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsStatusEndpoint{UpdateProductStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsTagsEndpoint struct {
	*shop.UpdateProductsTagsRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductsTags(ctx context.Context, req *shop.UpdateProductsTagsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductsTags"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsTagsEndpoint{UpdateProductsTagsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsTags(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantEndpoint struct {
	*shop.UpdateVariantRequest
	Result  *shop.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariant(ctx context.Context, req *shop.UpdateVariantRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantEndpoint{UpdateVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantAttributesEndpoint struct {
	*shop.UpdateVariantAttributesRequest
	Result  *shop.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantAttributes(ctx context.Context, req *shop.UpdateVariantAttributesRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantAttributes"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantAttributesEndpoint{UpdateVariantAttributesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantAttributes(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantImagesEndpoint struct {
	*shop.UpdateVariantImagesRequest
	Result  *shop.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantImages(ctx context.Context, req *shop.UpdateVariantImagesRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantImagesEndpoint{UpdateVariantImagesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantsStatusEndpoint struct {
	*shop.UpdateProductStatusRequest
	Result  *shop.UpdateProductStatusResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantsStatus(ctx context.Context, req *shop.UpdateProductStatusRequest) (resp *shop.UpdateProductStatusResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantsStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantsStatusEndpoint{UpdateProductStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantsStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductSourceService(s *ProductSourceService) api.ProductSourceService {
	return wrapProductSourceService{s: s}
}

type wrapProductSourceService struct {
	s *ProductSourceService
}

type CreateProductSourceEndpoint struct {
	*shop.CreateProductSourceRequest
	Result  *shop.ProductSource
	Context claims.ShopClaim
}

func (s wrapProductSourceService) CreateProductSource(ctx context.Context, req *shop.CreateProductSourceRequest) (resp *shop.ProductSource, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSource"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceEndpoint{CreateProductSourceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProductSource(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateProductSourceCategoryEndpoint struct {
	*shop.CreatePSCategoryRequest
	Result  *shop.Category
	Context claims.ShopClaim
}

func (s wrapProductSourceService) CreateProductSourceCategory(ctx context.Context, req *shop.CreatePSCategoryRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceCategoryEndpoint{CreatePSCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeprecatedCreateVariantEndpoint struct {
	*shop.DeprecatedCreateVariantRequest
	Result     *shop.ShopProduct
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductSourceService) CreateVariant(ctx context.Context, req *shop.DeprecatedCreateVariantRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/DeprecatedCreateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeprecatedCreateVariantEndpoint{DeprecatedCreateVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductSourceCategoriesEndpoint struct {
	*shop.GetProductSourceCategoriesRequest
	Result     *shop.CategoriesResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductSourceService) GetProductSourceCategories(ctx context.Context, req *shop.GetProductSourceCategoriesRequest) (resp *shop.CategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategories"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoriesEndpoint{GetProductSourceCategoriesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductSourceCategories(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result     *shop.Category
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductSourceService) GetProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopProductSourcesEndpoint struct {
	*cm.Empty
	Result     *shop.ProductSourcesResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapProductSourceService) GetShopProductSources(ctx context.Context, req *cm.Empty) (resp *shop.ProductSourcesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetShopProductSources"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopProductSourcesEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShopProductSources(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductSourceService) RemoveProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/RemoveProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductSourceCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:delete|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductSourceCategoryEndpoint struct {
	*shop.UpdateProductSourceCategoryRequest
	Result  *shop.Category
	Context claims.ShopClaim
}

func (s wrapProductSourceService) UpdateProductSourceCategory(ctx context.Context, req *shop.UpdateProductSourceCategoryRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductSourceCategoryEndpoint{UpdateProductSourceCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsPSCategoryEndpoint struct {
	*shop.UpdateProductsPSCategoryRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductSourceService) UpdateProductsPSCategory(ctx context.Context, req *shop.UpdateProductsPSCategoryRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductsPSCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsPSCategoryEndpoint{UpdateProductsPSCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsPSCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapPurchaseOrderService(s *PurchaseOrderService) api.PurchaseOrderService {
	return wrapPurchaseOrderService{s: s}
}

type wrapPurchaseOrderService struct {
	s *PurchaseOrderService
}

type CancelPurchaseOrderEndpoint struct {
	*shop.CancelPurchaseOrderRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) CancelPurchaseOrder(ctx context.Context, req *shop.CancelPurchaseOrderRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/CancelPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelPurchaseOrderEndpoint{CancelPurchaseOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmPurchaseOrderEndpoint struct {
	*shop.ConfirmPurchaseOrderRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) ConfirmPurchaseOrder(ctx context.Context, req *shop.ConfirmPurchaseOrderRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/ConfirmPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmPurchaseOrderEndpoint{ConfirmPurchaseOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreatePurchaseOrderEndpoint struct {
	*shop.CreatePurchaseOrderRequest
	Result  *shop.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) CreatePurchaseOrder(ctx context.Context, req *shop.CreatePurchaseOrderRequest) (resp *shop.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/CreatePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePurchaseOrderEndpoint{CreatePurchaseOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreatePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeletePurchaseOrderEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) DeletePurchaseOrder(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/DeletePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeletePurchaseOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeletePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrderEndpoint struct {
	*cm.IDRequest
	Result  *shop.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrder(ctx context.Context, req *cm.IDRequest) (resp *shop.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersEndpoint struct {
	*shop.GetPurchaseOrdersRequest
	Result  *shop.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrders(ctx context.Context, req *shop.GetPurchaseOrdersRequest) (resp *shop.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersEndpoint{GetPurchaseOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersByReceiptIDEndpoint struct {
	*cm.IDRequest
	Result  *shop.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrdersByReceiptID(ctx context.Context, req *cm.IDRequest) (resp *shop.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrdersByReceiptID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersByReceiptIDEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrdersByReceiptID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePurchaseOrderEndpoint struct {
	*shop.UpdatePurchaseOrderRequest
	Result  *shop.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) UpdatePurchaseOrder(ctx context.Context, req *shop.UpdatePurchaseOrderRequest) (resp *shop.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/UpdatePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePurchaseOrderEndpoint{UpdatePurchaseOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/purchase_order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapReceiptService(s *ReceiptService) api.ReceiptService {
	return wrapReceiptService{s: s}
}

type wrapReceiptService struct {
	s *ReceiptService
}

type CancelReceiptEndpoint struct {
	*shop.CancelReceiptRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) CancelReceipt(ctx context.Context, req *shop.CancelReceiptRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/CancelReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelReceiptEndpoint{CancelReceiptRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmReceiptEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) ConfirmReceipt(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/ConfirmReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmReceiptEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateReceiptEndpoint struct {
	*shop.CreateReceiptRequest
	Result  *shop.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) CreateReceipt(ctx context.Context, req *shop.CreateReceiptRequest) (resp *shop.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/CreateReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateReceiptEndpoint{CreateReceiptRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptEndpoint struct {
	*cm.IDRequest
	Result  *shop.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceipt(ctx context.Context, req *cm.IDRequest) (resp *shop.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptsEndpoint struct {
	*shop.GetReceiptsRequest
	Result  *shop.ReceiptsResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceipts(ctx context.Context, req *shop.GetReceiptsRequest) (resp *shop.ReceiptsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceipts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptsEndpoint{GetReceiptsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceipts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptsByLedgerTypeEndpoint struct {
	*shop.GetReceiptsByLedgerTypeRequest
	Result  *shop.ReceiptsResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceiptsByLedgerType(ctx context.Context, req *shop.GetReceiptsByLedgerTypeRequest) (resp *shop.ReceiptsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceiptsByLedgerType"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptsByLedgerTypeEndpoint{GetReceiptsByLedgerTypeRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceiptsByLedgerType(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReceiptEndpoint struct {
	*shop.UpdateReceiptRequest
	Result  *shop.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) UpdateReceipt(ctx context.Context, req *shop.UpdateReceiptRequest) (resp *shop.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/UpdateReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReceiptEndpoint{UpdateReceiptRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/receipt:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShipnowService(s *ShipnowService) api.ShipnowService {
	return wrapShipnowService{s: s}
}

type wrapShipnowService struct {
	s *ShipnowService
}

type CancelShipnowFulfillmentEndpoint struct {
	*order.CancelShipnowFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapShipnowService) CancelShipnowFulfillment(ctx context.Context, req *order.CancelShipnowFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CancelShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelShipnowFulfillmentEndpoint{CancelShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) ConfirmShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/ConfirmShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmShipnowFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShipnowFulfillmentEndpoint struct {
	*order.CreateShipnowFulfillmentRequest
	Result  *order.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) CreateShipnowFulfillment(ctx context.Context, req *order.CreateShipnowFulfillmentRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CreateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipnowFulfillmentEndpoint{CreateShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowFulfillmentsEndpoint struct {
	*order.GetShipnowFulfillmentsRequest
	Result  *order.ShipnowFulfillments
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowFulfillments(ctx context.Context, req *order.GetShipnowFulfillmentsRequest) (resp *order.ShipnowFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentsEndpoint{GetShipnowFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowServicesEndpoint struct {
	*order.GetShipnowServicesRequest
	Result  *order.GetShipnowServicesResponse
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowServices(ctx context.Context, req *order.GetShipnowServicesRequest) (resp *order.GetShipnowServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowServicesEndpoint{GetShipnowServicesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipnowFulfillmentEndpoint struct {
	*order.UpdateShipnowFulfillmentRequest
	Result  *order.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) UpdateShipnowFulfillment(ctx context.Context, req *order.UpdateShipnowFulfillmentRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/UpdateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipnowFulfillmentEndpoint{UpdateShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/shipnow:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapStocktakeService(s *StocktakeService) api.StocktakeService {
	return wrapStocktakeService{s: s}
}

type wrapStocktakeService struct {
	s *StocktakeService
}

type CancelStocktakeEndpoint struct {
	*shop.CancelStocktakeRequest
	Result  *shop.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) CancelStocktake(ctx context.Context, req *shop.CancelStocktakeRequest) (resp *shop.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/CancelStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelStocktakeEndpoint{CancelStocktakeRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmStocktakeEndpoint struct {
	*shop.ConfirmStocktakeRequest
	Result  *shop.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) ConfirmStocktake(ctx context.Context, req *shop.ConfirmStocktakeRequest) (resp *shop.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/ConfirmStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmStocktakeEndpoint{ConfirmStocktakeRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateStocktakeEndpoint struct {
	*shop.CreateStocktakeRequest
	Result  *shop.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) CreateStocktake(ctx context.Context, req *shop.CreateStocktakeRequest) (resp *shop.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/CreateStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateStocktakeEndpoint{CreateStocktakeRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.Context.Shop = session.Shop
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakeEndpoint struct {
	*cm.IDRequest
	Result  *shop.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktake(ctx context.Context, req *cm.IDRequest) (resp *shop.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakeEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakesEndpoint struct {
	*shop.GetStocktakesRequest
	Result  *shop.GetStocktakesResponse
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktakes(ctx context.Context, req *shop.GetStocktakesRequest) (resp *shop.GetStocktakesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktakes"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakesEndpoint{GetStocktakesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktakes(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakesByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.GetStocktakesByIDsResponse
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktakesByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.GetStocktakesByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktakesByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakesByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktakesByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateStocktakeEndpoint struct {
	*shop.UpdateStocktakeRequest
	Result  *shop.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) UpdateStocktake(ctx context.Context, req *shop.UpdateStocktakeRequest) (resp *shop.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/UpdateStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateStocktakeEndpoint{UpdateStocktakeRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/stocktake:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSummaryService(s *SummaryService) api.SummaryService {
	return wrapSummaryService{s: s}
}

type wrapSummaryService struct {
	s *SummaryService
}

type CalcBalanceShopEndpoint struct {
	*cm.Empty
	Result     *shop.CalcBalanceShopResponse
	Context    claims.ShopClaim
	CtxPartner *model.Partner
}

func (s wrapSummaryService) CalcBalanceShop(ctx context.Context, req *cm.Empty) (resp *shop.CalcBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/CalcBalanceShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CalcBalanceShopEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CalcBalanceShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SummarizeFulfillmentsEndpoint struct {
	*shop.SummarizeFulfillmentsRequest
	Result  *shop.SummarizeFulfillmentsResponse
	Context claims.ShopClaim
}

func (s wrapSummaryService) SummarizeFulfillments(ctx context.Context, req *shop.SummarizeFulfillmentsRequest) (resp *shop.SummarizeFulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizeFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizeFulfillmentsEndpoint{SummarizeFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SummarizeFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SummarizePOSEndpoint struct {
	*shop.SummarizePOSRequest
	Result  *shop.SummarizePOSResponse
	Context claims.ShopClaim
}

func (s wrapSummaryService) SummarizePOS(ctx context.Context, req *shop.SummarizePOSRequest) (resp *shop.SummarizePOSResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizePOS"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizePOSEndpoint{SummarizePOSRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SummarizePOS(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSupplierService(s *SupplierService) api.SupplierService {
	return wrapSupplierService{s: s}
}

type wrapSupplierService struct {
	s *SupplierService
}

type CreateSupplierEndpoint struct {
	*shop.CreateSupplierRequest
	Result  *shop.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) CreateSupplier(ctx context.Context, req *shop.CreateSupplierRequest) (resp *shop.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/CreateSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSupplierEndpoint{CreateSupplierRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSupplierEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) DeleteSupplier(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/DeleteSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSupplierEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSupplierEndpoint struct {
	*cm.IDRequest
	Result  *shop.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSupplier(ctx context.Context, req *cm.IDRequest) (resp *shop.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSupplierEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersEndpoint struct {
	*shop.GetSuppliersRequest
	Result  *shop.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliers(ctx context.Context, req *shop.GetSuppliersRequest) (resp *shop.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersEndpoint{GetSuppliersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersByVariantIDEndpoint struct {
	*shop.GetSuppliersByVariantIDRequest
	Result  *shop.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliersByVariantID(ctx context.Context, req *shop.GetSuppliersByVariantIDRequest) (resp *shop.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliersByVariantID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersByVariantIDEndpoint{GetSuppliersByVariantIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliersByVariantID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateSupplierEndpoint struct {
	*shop.UpdateSupplierRequest
	Result  *shop.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) UpdateSupplier(ctx context.Context, req *shop.UpdateSupplierRequest) (resp *shop.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/UpdateSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateSupplierEndpoint{UpdateSupplierRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/supplier:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapTradingService(s *TradingService) api.TradingService {
	return wrapTradingService{s: s}
}

type wrapTradingService struct {
	s *TradingService
}

type TradingCreateOrderEndpoint struct {
	*order.TradingCreateOrderRequest
	Result  *order.Order
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingCreateOrder(ctx context.Context, req *order.TradingCreateOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingCreateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingCreateOrderEndpoint{TradingCreateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingCreateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetOrderEndpoint struct {
	*cm.IDRequest
	Result  *order.Order
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetOrdersEndpoint struct {
	*shop.GetOrdersRequest
	Result  *order.OrdersResponse
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetOrders(ctx context.Context, req *shop.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetProductEndpoint struct {
	*cm.IDRequest
	Result  *shop.ShopProduct
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetProduct(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetProductEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/product:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/product:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetProductsEndpoint struct {
	*cm.CommonListRequest
	Result  *shop.ShopProductsResponse
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetProducts(ctx context.Context, req *cm.CommonListRequest) (resp *shop.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetProductsEndpoint{CommonListRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	if !authorization.Check(query.Context.Roles, "shop/trading/product:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/product:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
