// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package shop

import (
	"context"
	"strings"
	"time"

	etop "o.o/api/top/int/etop"
	api "o.o/api/top/int/shop"
	inttypes "o.o/api/top/int/types"
	cm "o.o/api/top/types/common"
	identitymodel "o.o/backend/com/main/identity/model"
	common "o.o/backend/pkg/common"
	cmwrapper "o.o/backend/pkg/common/apifw/wrapper"
	bus "o.o/backend/pkg/common/bus"
	auth "o.o/backend/pkg/etop/authorize/auth"
	claims "o.o/backend/pkg/etop/authorize/claims"
	middleware "o.o/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type CreateExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *api.ExternalAccountAhamove
	Context claims.ShopClaim
}

func (s wrapAccountService) CreateExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *api.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/CreateExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateExternalAccountAhamoveEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShopEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapAccountService) DeleteShop(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/DeleteShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/account:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/account:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBalanceShopEndpoint struct {
	*cm.Empty
	Result  *api.GetBalanceShopResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) GetBalanceShop(ctx context.Context, req *cm.Empty) (resp *api.GetBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetBalanceShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBalanceShopEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/balance:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/balance:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBalanceShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *api.ExternalAccountAhamove
	Context claims.ShopClaim
}

func (s wrapAccountService) GetExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *api.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalAccountAhamoveEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterShopEndpoint struct {
	*api.RegisterShopRequest
	Result     *api.RegisterShopResponse
	Context    claims.UserClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapAccountService) RegisterShop(ctx context.Context, req *api.RegisterShopRequest) (resp *api.RegisterShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RegisterShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterShopEndpoint{RegisterShopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = s.s.RegisterShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RequestVerifyExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) RequestVerifyExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RequestVerifyExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestVerifyExternalAccountAhamoveEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RequestVerifyExternalAccountAhamove(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SetDefaultAddressEndpoint struct {
	*etop.SetDefaultAddressRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) SetDefaultAddress(ctx context.Context, req *etop.SetDefaultAddressRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/SetDefaultAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultAddressEndpoint{SetDefaultAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/settings/shop_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/settings/shop_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SetDefaultAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateExternalAccountAhamoveVerificationEndpoint struct {
	*api.UpdateXAccountAhamoveVerificationRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateExternalAccountAhamoveVerification(ctx context.Context, req *api.UpdateXAccountAhamoveVerificationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateExternalAccountAhamoveVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountAhamoveVerificationEndpoint{UpdateXAccountAhamoveVerificationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateExternalAccountAhamoveVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateExternalAccountAhamoveVerificationImagesEndpoint struct {
	*api.UpdateXAccountAhamoveVerificationRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateExternalAccountAhamoveVerificationImages(ctx context.Context, req *api.UpdateXAccountAhamoveVerificationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateExternalAccountAhamoveVerificationImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountAhamoveVerificationImagesEndpoint{UpdateXAccountAhamoveVerificationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateExternalAccountAhamoveVerificationImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShopEndpoint struct {
	*api.UpdateShopRequest
	Result  *api.UpdateShopResponse
	Context claims.ShopClaim
}

func (s wrapAccountService) UpdateShop(ctx context.Context, req *api.UpdateShopRequest) (resp *api.UpdateShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShopEndpoint{UpdateShopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/settings/shop_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/settings/shop_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapAuthorizeService(s *AuthorizeService) api.AuthorizeService {
	return wrapAuthorizeService{s: s}
}

type wrapAuthorizeService struct {
	s *AuthorizeService
}

type AuthorizePartnerEndpoint struct {
	*api.AuthorizePartnerRequest
	Result  *api.AuthorizedPartnerResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) AuthorizePartner(ctx context.Context, req *api.AuthorizePartnerRequest) (resp *api.AuthorizedPartnerResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/AuthorizePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AuthorizePartnerEndpoint{AuthorizePartnerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/external_account:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/external_account:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AuthorizePartner(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAuthorizedPartnersEndpoint struct {
	*cm.Empty
	Result  *api.GetAuthorizedPartnersResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) GetAuthorizedPartners(ctx context.Context, req *cm.Empty) (resp *api.GetAuthorizedPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAuthorizedPartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAuthorizedPartnersEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAuthorizedPartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAvailablePartnersEndpoint struct {
	*cm.Empty
	Result  *api.GetPartnersResponse
	Context claims.ShopClaim
}

func (s wrapAuthorizeService) GetAvailablePartners(ctx context.Context, req *cm.Empty) (resp *api.GetPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAvailablePartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAvailablePartnersEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAvailablePartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapBrandService(s *BrandService) api.BrandService {
	return wrapBrandService{s: s}
}

type wrapBrandService struct {
	s *BrandService
}

type CreateBrandEndpoint struct {
	*api.CreateBrandRequest
	Result  *api.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) CreateBrand(ctx context.Context, req *api.CreateBrandRequest) (resp *api.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/CreateBrand"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateBrandEndpoint{CreateBrandRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateBrand(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteBrandEndpoint struct {
	*cm.IDsRequest
	Result  *api.DeleteBrandResponse
	Context claims.ShopClaim
}

func (s wrapBrandService) DeleteBrand(ctx context.Context, req *cm.IDsRequest) (resp *api.DeleteBrandResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/DeleteBrand"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteBrandEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteBrand(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandByIDEndpoint struct {
	*cm.IDRequest
	Result  *api.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) GetBrandByID(ctx context.Context, req *cm.IDRequest) (resp *api.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrandByID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandByIDEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrandByID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandsEndpoint struct {
	*api.GetBrandsRequest
	Result     *api.GetBrandsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapBrandService) GetBrands(ctx context.Context, req *api.GetBrandsRequest) (resp *api.GetBrandsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrands"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandsEndpoint{GetBrandsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrands(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBrandsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.GetBrandsByIDsResponse
	Context claims.ShopClaim
}

func (s wrapBrandService) GetBrandsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.GetBrandsByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/GetBrandsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBrandsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBrandsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateBrandInfoEndpoint struct {
	*api.UpdateBrandRequest
	Result  *api.Brand
	Context claims.ShopClaim
}

func (s wrapBrandService) UpdateBrandInfo(ctx context.Context, req *api.UpdateBrandRequest) (resp *api.Brand, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Brand/UpdateBrandInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateBrandInfoEndpoint{UpdateBrandRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateBrandInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCarrierService(s *CarrierService) api.CarrierService {
	return wrapCarrierService{s: s}
}

type wrapCarrierService struct {
	s *CarrierService
}

type CreateCarrierEndpoint struct {
	*api.CreateCarrierRequest
	Result  *api.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) CreateCarrier(ctx context.Context, req *api.CreateCarrierRequest) (resp *api.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/CreateCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCarrierEndpoint{CreateCarrierRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCarrierEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) DeleteCarrier(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/DeleteCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCarrierEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarrierEndpoint struct {
	*cm.IDRequest
	Result  *api.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarrier(ctx context.Context, req *cm.IDRequest) (resp *api.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarrierEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarriersEndpoint struct {
	*api.GetCarriersRequest
	Result  *api.CarriersResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarriers(ctx context.Context, req *api.GetCarriersRequest) (resp *api.CarriersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarriers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarriersEndpoint{GetCarriersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarriers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCarriersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.CarriersResponse
	Context claims.ShopClaim
}

func (s wrapCarrierService) GetCarriersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.CarriersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/GetCarriersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCarriersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCarriersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCarrierEndpoint struct {
	*api.UpdateCarrierRequest
	Result  *api.Carrier
	Context claims.ShopClaim
}

func (s wrapCarrierService) UpdateCarrier(ctx context.Context, req *api.UpdateCarrierRequest) (resp *api.Carrier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Carrier/UpdateCarrier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCarrierEndpoint{UpdateCarrierRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/carrier:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/carrier:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCarrier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCategoryService(s *CategoryService) api.CategoryService {
	return wrapCategoryService{s: s}
}

type wrapCategoryService struct {
	s *CategoryService
}

type CreateCategoryEndpoint struct {
	*api.CreateCategoryRequest
	Result  *api.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) CreateCategory(ctx context.Context, req *api.CreateCategoryRequest) (resp *api.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/CreateCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCategoryEndpoint{CreateCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/category:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCategoryEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCategoryService) DeleteCategory(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/DeleteCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCategoryEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/category:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCategoriesEndpoint struct {
	*api.GetCategoriesRequest
	Result  *api.ShopCategoriesResponse
	Context claims.ShopClaim
}

func (s wrapCategoryService) GetCategories(ctx context.Context, req *api.GetCategoriesRequest) (resp *api.ShopCategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/GetCategories"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCategoriesEndpoint{GetCategoriesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/category:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCategories(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCategoryEndpoint struct {
	*cm.IDRequest
	Result  *api.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) GetCategory(ctx context.Context, req *cm.IDRequest) (resp *api.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/GetCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCategoryEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/category:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCategoryEndpoint struct {
	*api.UpdateCategoryRequest
	Result  *api.ShopCategory
	Context claims.ShopClaim
}

func (s wrapCategoryService) UpdateCategory(ctx context.Context, req *api.UpdateCategoryRequest) (resp *api.ShopCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Category/UpdateCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCategoryEndpoint{UpdateCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/category:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/category:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCollectionService(s *CollectionService) api.CollectionService {
	return wrapCollectionService{s: s}
}

type wrapCollectionService struct {
	s *CollectionService
}

type CreateCollectionEndpoint struct {
	*api.CreateCollectionRequest
	Result  *api.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) CreateCollection(ctx context.Context, req *api.CreateCollectionRequest) (resp *api.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/CreateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCollectionEndpoint{CreateCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/collection:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionEndpoint struct {
	*cm.IDRequest
	Result  *api.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollection(ctx context.Context, req *cm.IDRequest) (resp *api.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionsEndpoint struct {
	*api.GetCollectionsRequest
	Result  *api.ShopCollectionsResponse
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollections(ctx context.Context, req *api.GetCollectionsRequest) (resp *api.ShopCollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsEndpoint{GetCollectionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionsByProductIDEndpoint struct {
	*api.GetShopCollectionsByProductIDRequest
	Result  *api.CollectionsResponse
	Context claims.ShopClaim
}

func (s wrapCollectionService) GetCollectionsByProductID(ctx context.Context, req *api.GetShopCollectionsByProductIDRequest) (resp *api.CollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollectionsByProductID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsByProductIDEndpoint{GetShopCollectionsByProductIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/collection:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollectionsByProductID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCollectionEndpoint struct {
	*api.UpdateCollectionRequest
	Result  *api.ShopCollection
	Context claims.ShopClaim
}

func (s wrapCollectionService) UpdateCollection(ctx context.Context, req *api.UpdateCollectionRequest) (resp *api.ShopCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/UpdateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCollectionEndpoint{UpdateCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/collection:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/collection:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapConnectionService(s *ConnectionService) api.ConnectionService {
	return wrapConnectionService{s: s}
}

type wrapConnectionService struct {
	s *ConnectionService
}

type DeleteShopConnectionEndpoint struct {
	*inttypes.DeleteShopConnectionRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapConnectionService) DeleteShopConnection(ctx context.Context, req *inttypes.DeleteShopConnectionRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/DeleteShopConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShopConnectionEndpoint{DeleteShopConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteShopConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAvailableConnectionsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetConnectionsResponse
	Context claims.ShopClaim
}

func (s wrapConnectionService) GetAvailableConnections(ctx context.Context, req *cm.Empty) (resp *inttypes.GetConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/GetAvailableConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAvailableConnectionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAvailableConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetConnectionsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetConnectionsResponse
	Context claims.ShopClaim
}

func (s wrapConnectionService) GetConnections(ctx context.Context, req *cm.Empty) (resp *inttypes.GetConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/GetConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetConnectionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopConnectionsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetShopConnectionsResponse
	Context claims.ShopClaim
}

func (s wrapConnectionService) GetShopConnections(ctx context.Context, req *cm.Empty) (resp *inttypes.GetShopConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/GetShopConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopConnectionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShopConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LoginShopConnectionEndpoint struct {
	*inttypes.LoginShopConnectionRequest
	Result  *inttypes.ShopConnection
	Context claims.ShopClaim
}

func (s wrapConnectionService) LoginShopConnection(ctx context.Context, req *inttypes.LoginShopConnectionRequest) (resp *inttypes.ShopConnection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/LoginShopConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LoginShopConnectionEndpoint{LoginShopConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.LoginShopConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterShopConnectionEndpoint struct {
	*inttypes.RegisterShopConnectionRequest
	Result  *inttypes.ShopConnection
	Context claims.ShopClaim
}

func (s wrapConnectionService) RegisterShopConnection(ctx context.Context, req *inttypes.RegisterShopConnectionRequest) (resp *inttypes.ShopConnection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/RegisterShopConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterShopConnectionEndpoint{RegisterShopConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RegisterShopConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShopConnectionEndpoint struct {
	*inttypes.UpdateShopConnectionRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapConnectionService) UpdateShopConnection(ctx context.Context, req *inttypes.UpdateShopConnectionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Connection/UpdateShopConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShopConnectionEndpoint{UpdateShopConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateShopConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerService(s *CustomerService) api.CustomerService {
	return wrapCustomerService{s: s}
}

type wrapCustomerService struct {
	s *CustomerService
}

type AddCustomersToGroupEndpoint struct {
	*api.AddCustomerToGroupRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) AddCustomersToGroup(ctx context.Context, req *api.AddCustomerToGroupRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/AddCustomersToGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddCustomersToGroupEndpoint{AddCustomerToGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddCustomersToGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type BatchSetCustomersStatusEndpoint struct {
	*api.SetCustomersStatusRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) BatchSetCustomersStatus(ctx context.Context, req *api.SetCustomersStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/BatchSetCustomersStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &BatchSetCustomersStatusEndpoint{SetCustomersStatusRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.BatchSetCustomersStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCustomerEndpoint struct {
	*api.CreateCustomerRequest
	Result  *api.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) CreateCustomer(ctx context.Context, req *api.CreateCustomerRequest) (resp *api.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/CreateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerEndpoint{CreateCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCustomerAddressEndpoint struct {
	*api.CreateCustomerAddressRequest
	Result  *api.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerService) CreateCustomerAddress(ctx context.Context, req *api.CreateCustomerAddressRequest) (resp *api.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/CreateCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerAddressEndpoint{CreateCustomerAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:create|shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:create|shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomerEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) DeleteCustomer(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/DeleteCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomerEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomerAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) DeleteCustomerAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/DeleteCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomerAddressEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:update|shop/customer:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update|shop/customer:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerEndpoint struct {
	*cm.IDRequest
	Result  *api.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomer(ctx context.Context, req *cm.IDRequest) (resp *api.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerAddressesEndpoint struct {
	*api.GetCustomerAddressesRequest
	Result  *api.CustomerAddressesResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomerAddresses(ctx context.Context, req *api.GetCustomerAddressesRequest) (resp *api.CustomerAddressesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomerAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerAddressesEndpoint{GetCustomerAddressesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerDetailsEndpoint struct {
	*cm.IDRequest
	Result  *api.CustomerDetailsResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomerDetails(ctx context.Context, req *cm.IDRequest) (resp *api.CustomerDetailsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomerDetails"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerDetailsEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerDetails(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomersEndpoint struct {
	*api.GetCustomersRequest
	Result  *api.CustomersResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomers(ctx context.Context, req *api.GetCustomersRequest) (resp *api.CustomersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomersEndpoint{GetCustomersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.CustomersResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.CustomersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/GetCustomersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveCustomersFromGroupEndpoint struct {
	*api.RemoveCustomerOutOfGroupRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) RemoveCustomersFromGroup(ctx context.Context, req *api.RemoveCustomerOutOfGroupRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/RemoveCustomersFromGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveCustomersFromGroupEndpoint{RemoveCustomerOutOfGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveCustomersFromGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SetDefaultCustomerAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) SetDefaultCustomerAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/SetDefaultCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultCustomerAddressEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SetDefaultCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerEndpoint struct {
	*api.UpdateCustomerRequest
	Result  *api.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) UpdateCustomer(ctx context.Context, req *api.UpdateCustomerRequest) (resp *api.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/UpdateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerEndpoint{UpdateCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerAddressEndpoint struct {
	*api.UpdateCustomerAddressRequest
	Result  *api.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerService) UpdateCustomerAddress(ctx context.Context, req *api.UpdateCustomerAddressRequest) (resp *api.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Customer/UpdateCustomerAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerAddressEndpoint{UpdateCustomerAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomerAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerGroupService(s *CustomerGroupService) api.CustomerGroupService {
	return wrapCustomerGroupService{s: s}
}

type wrapCustomerGroupService struct {
	s *CustomerGroupService
}

type CreateCustomerGroupEndpoint struct {
	*api.CreateCustomerGroupRequest
	Result  *api.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) CreateCustomerGroup(ctx context.Context, req *api.CreateCustomerGroupRequest) (resp *api.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/CreateCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerGroupEndpoint{CreateCustomerGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer_group:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer_group:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerGroupEndpoint struct {
	*cm.IDRequest
	Result  *api.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) GetCustomerGroup(ctx context.Context, req *cm.IDRequest) (resp *api.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/GetCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerGroupEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerGroupsEndpoint struct {
	*api.GetCustomerGroupsRequest
	Result  *api.CustomerGroupsResponse
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) GetCustomerGroups(ctx context.Context, req *api.GetCustomerGroupsRequest) (resp *api.CustomerGroupsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/GetCustomerGroups"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerGroupsEndpoint{GetCustomerGroupsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomerGroups(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerGroupEndpoint struct {
	*api.UpdateCustomerGroupRequest
	Result  *api.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) UpdateCustomerGroup(ctx context.Context, req *api.UpdateCustomerGroupRequest) (resp *api.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.CustomerGroup/UpdateCustomerGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerGroupEndpoint{UpdateCustomerGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/customer_group:manage", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/customer_group:manage", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomerGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapExportService(s *ExportService) api.ExportService {
	return wrapExportService{s: s}
}

type wrapExportService struct {
	s *ExportService
}

type GetExportsEndpoint struct {
	*api.GetExportsRequest
	Result  *api.GetExportsResponse
	Context claims.ShopClaim
}

func (s wrapExportService) GetExports(ctx context.Context, req *api.GetExportsRequest) (resp *api.GetExportsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/GetExports"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExportsEndpoint{GetExportsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExports(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RequestExportEndpoint struct {
	*api.RequestExportRequest
	Result  *api.RequestExportResponse
	Context claims.ShopClaim
}

func (s wrapExportService) RequestExport(ctx context.Context, req *api.RequestExportRequest) (resp *api.RequestExportResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/RequestExport"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestExportEndpoint{RequestExportRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RequestExport(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s *FulfillmentService) api.FulfillmentService {
	return wrapFulfillmentService{s: s}
}

type wrapFulfillmentService struct {
	s *FulfillmentService
}

type GetExternalShippingServicesEndpoint struct {
	*inttypes.GetExternalShippingServicesRequest
	Result     *inttypes.GetExternalShippingServicesResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapFulfillmentService) GetExternalShippingServices(ctx context.Context, req *inttypes.GetExternalShippingServicesRequest) (resp *inttypes.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetExternalShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result     *inttypes.Fulfillment
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsEndpoint struct {
	*api.GetFulfillmentsRequest
	Result     *inttypes.FulfillmentsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapFulfillmentService) GetFulfillments(ctx context.Context, req *api.GetFulfillmentsRequest) (resp *inttypes.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsByIDsEndpoint struct {
	*api.GetFulfillmentsByIDsRequest
	Result     *inttypes.FulfillmentsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapFulfillmentService) GetFulfillmentsByIDs(ctx context.Context, req *api.GetFulfillmentsByIDsRequest) (resp *inttypes.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillmentsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsByIDsEndpoint{GetFulfillmentsByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillmentsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicExternalShippingServicesEndpoint struct {
	*inttypes.GetExternalShippingServicesRequest
	Result  *inttypes.GetExternalShippingServicesResponse
	Context claims.EmptyClaim
}

func (s wrapFulfillmentService) GetPublicExternalShippingServices(ctx context.Context, req *inttypes.GetExternalShippingServicesRequest) (resp *inttypes.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetPublicExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicExternalShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicFulfillmentEndpoint struct {
	*api.GetPublicFulfillmentRequest
	Result  *inttypes.PublicFulfillment
	Context claims.EmptyClaim
}

func (s wrapFulfillmentService) GetPublicFulfillment(ctx context.Context, req *api.GetPublicFulfillmentRequest) (resp *inttypes.PublicFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetPublicFulfillmentEndpoint{GetPublicFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentsShippingStateEndpoint struct {
	*api.UpdateFulfillmentsShippingStateRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentsShippingState(ctx context.Context, req *api.UpdateFulfillmentsShippingStateRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/UpdateFulfillmentsShippingState"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentsShippingStateEndpoint{UpdateFulfillmentsShippingStateRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillmentsShippingState(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapHistoryService(s *HistoryService) api.HistoryService {
	return wrapHistoryService{s: s}
}

type wrapHistoryService struct {
	s *HistoryService
}

type GetFulfillmentHistoryEndpoint struct {
	*api.GetFulfillmentHistoryRequest
	Result     *etop.HistoryResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapHistoryService) GetFulfillmentHistory(ctx context.Context, req *api.GetFulfillmentHistoryRequest) (resp *etop.HistoryResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.History/GetFulfillmentHistory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentHistoryEndpoint{GetFulfillmentHistoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillmentHistory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapInventoryService(s *InventoryService) api.InventoryService {
	return wrapInventoryService{s: s}
}

type wrapInventoryService struct {
	s *InventoryService
}

type AdjustInventoryQuantityEndpoint struct {
	*api.AdjustInventoryQuantityRequest
	Result  *api.AdjustInventoryQuantityResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) AdjustInventoryQuantity(ctx context.Context, req *api.AdjustInventoryQuantityRequest) (resp *api.AdjustInventoryQuantityResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/AdjustInventoryQuantity"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdjustInventoryQuantityEndpoint{AdjustInventoryQuantityRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AdjustInventoryQuantity(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CancelInventoryVoucherEndpoint struct {
	*api.CancelInventoryVoucherRequest
	Result  *api.CancelInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) CancelInventoryVoucher(ctx context.Context, req *api.CancelInventoryVoucherRequest) (resp *api.CancelInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/CancelInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelInventoryVoucherEndpoint{CancelInventoryVoucherRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmInventoryVoucherEndpoint struct {
	*api.ConfirmInventoryVoucherRequest
	Result  *api.ConfirmInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) ConfirmInventoryVoucher(ctx context.Context, req *api.ConfirmInventoryVoucherRequest) (resp *api.ConfirmInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/ConfirmInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmInventoryVoucherEndpoint{ConfirmInventoryVoucherRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateInventoryVoucherEndpoint struct {
	*api.CreateInventoryVoucherRequest
	Result  *api.CreateInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) CreateInventoryVoucher(ctx context.Context, req *api.CreateInventoryVoucherRequest) (resp *api.CreateInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/CreateInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateInventoryVoucherEndpoint{CreateInventoryVoucherRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantEndpoint struct {
	*api.GetInventoryVariantRequest
	Result  *api.InventoryVariant
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariant(ctx context.Context, req *api.GetInventoryVariantRequest) (resp *api.InventoryVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantEndpoint{GetInventoryVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantsEndpoint struct {
	*api.GetInventoryVariantsRequest
	Result  *api.GetInventoryVariantsResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariants(ctx context.Context, req *api.GetInventoryVariantsRequest) (resp *api.GetInventoryVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariants"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantsEndpoint{GetInventoryVariantsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariants(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVariantsByVariantIDsEndpoint struct {
	*api.GetInventoryVariantsByVariantIDsRequest
	Result  *api.GetInventoryVariantsResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVariantsByVariantIDs(ctx context.Context, req *api.GetInventoryVariantsByVariantIDsRequest) (resp *api.GetInventoryVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVariantsByVariantIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVariantsByVariantIDsEndpoint{GetInventoryVariantsByVariantIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVariantsByVariantIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVoucherEndpoint struct {
	*cm.IDRequest
	Result  *api.InventoryVoucher
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVoucher(ctx context.Context, req *cm.IDRequest) (resp *api.InventoryVoucher, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVoucherEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersEndpoint struct {
	*api.GetInventoryVouchersRequest
	Result  *api.GetInventoryVouchersResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchers(ctx context.Context, req *api.GetInventoryVouchersRequest) (resp *api.GetInventoryVouchersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersEndpoint{GetInventoryVouchersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersByIDsEndpoint struct {
	*api.GetInventoryVouchersByIDsRequest
	Result  *api.GetInventoryVouchersResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchersByIDs(ctx context.Context, req *api.GetInventoryVouchersByIDsRequest) (resp *api.GetInventoryVouchersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersByIDsEndpoint{GetInventoryVouchersByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInventoryVouchersByReferenceEndpoint struct {
	*api.GetInventoryVouchersByReferenceRequest
	Result  *api.GetInventoryVouchersByReferenceResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) GetInventoryVouchersByReference(ctx context.Context, req *api.GetInventoryVouchersByReferenceRequest) (resp *api.GetInventoryVouchersByReferenceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/GetInventoryVouchersByReference"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInventoryVouchersByReferenceEndpoint{GetInventoryVouchersByReferenceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInventoryVouchersByReference(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateInventoryVariantCostPriceEndpoint struct {
	*api.UpdateInventoryVariantCostPriceRequest
	Result  *api.UpdateInventoryVariantCostPriceResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) UpdateInventoryVariantCostPrice(ctx context.Context, req *api.UpdateInventoryVariantCostPriceRequest) (resp *api.UpdateInventoryVariantCostPriceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/UpdateInventoryVariantCostPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateInventoryVariantCostPriceEndpoint{UpdateInventoryVariantCostPriceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/cost_price:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/cost_price:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateInventoryVariantCostPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateInventoryVoucherEndpoint struct {
	*api.UpdateInventoryVoucherRequest
	Result  *api.UpdateInventoryVoucherResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) UpdateInventoryVoucher(ctx context.Context, req *api.UpdateInventoryVoucherRequest) (resp *api.UpdateInventoryVoucherResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Inventory/UpdateInventoryVoucher"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateInventoryVoucherEndpoint{UpdateInventoryVoucherRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/inventory:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/inventory:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateInventoryVoucher(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapLedgerService(s *LedgerService) api.LedgerService {
	return wrapLedgerService{s: s}
}

type wrapLedgerService struct {
	s *LedgerService
}

type CreateLedgerEndpoint struct {
	*api.CreateLedgerRequest
	Result  *api.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) CreateLedger(ctx context.Context, req *api.CreateLedgerRequest) (resp *api.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/CreateLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateLedgerEndpoint{CreateLedgerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/ledger:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteLedgerEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapLedgerService) DeleteLedger(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/DeleteLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteLedgerEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/ledger:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetLedgerEndpoint struct {
	*cm.IDRequest
	Result  *api.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) GetLedger(ctx context.Context, req *cm.IDRequest) (resp *api.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/GetLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLedgerEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/ledger:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetLedgersEndpoint struct {
	*api.GetLedgersRequest
	Result  *api.LedgersResponse
	Context claims.ShopClaim
}

func (s wrapLedgerService) GetLedgers(ctx context.Context, req *api.GetLedgersRequest) (resp *api.LedgersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/GetLedgers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLedgersEndpoint{GetLedgersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/ledger:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetLedgers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateLedgerEndpoint struct {
	*api.UpdateLedgerRequest
	Result  *api.Ledger
	Context claims.ShopClaim
}

func (s wrapLedgerService) UpdateLedger(ctx context.Context, req *api.UpdateLedgerRequest) (resp *api.Ledger, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Ledger/UpdateLedger"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateLedgerEndpoint{UpdateLedgerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/ledger:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/ledger:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateLedger(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMoneyTransactionService(s *MoneyTransactionService) api.MoneyTransactionService {
	return wrapMoneyTransactionService{s: s}
}

type wrapMoneyTransactionService struct {
	s *MoneyTransactionService
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransaction
	Context claims.ShopClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/money_transaction:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/money_transaction:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionsEndpoint struct {
	*api.GetMoneyTransactionsRequest
	Result  *inttypes.MoneyTransactionsResponse
	Context claims.ShopClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *api.GetMoneyTransactionsRequest) (resp *inttypes.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/money_transaction:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/money_transaction:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapNotificationService(s *NotificationService) api.NotificationService {
	return wrapNotificationService{s: s}
}

type wrapNotificationService struct {
	s *NotificationService
}

type CreateDeviceEndpoint struct {
	*etop.CreateDeviceRequest
	Result  *etop.Device
	Context claims.ShopClaim
}

func (s wrapNotificationService) CreateDevice(ctx context.Context, req *etop.CreateDeviceRequest) (resp *etop.Device, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/CreateDevice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateDeviceEndpoint{CreateDeviceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateDevice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteDeviceEndpoint struct {
	*etop.DeleteDeviceRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) DeleteDevice(ctx context.Context, req *etop.DeleteDeviceRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/DeleteDevice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteDeviceEndpoint{DeleteDeviceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteDevice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetNotificationEndpoint struct {
	*cm.IDRequest
	Result  *etop.Notification
	Context claims.ShopClaim
}

func (s wrapNotificationService) GetNotification(ctx context.Context, req *cm.IDRequest) (resp *etop.Notification, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetNotification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetNotificationsEndpoint struct {
	*etop.GetNotificationsRequest
	Result  *etop.NotificationsResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) GetNotifications(ctx context.Context, req *etop.GetNotificationsRequest) (resp *etop.NotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationsEndpoint{GetNotificationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateNotificationsEndpoint struct {
	*etop.UpdateNotificationsRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapNotificationService) UpdateNotifications(ctx context.Context, req *etop.UpdateNotificationsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/UpdateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateNotificationsEndpoint{UpdateNotificationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s *OrderService) api.OrderService {
	return wrapOrderService{s: s}
}

type wrapOrderService struct {
	s *OrderService
}

type CancelOrderEndpoint struct {
	*api.CancelOrderRequest
	Result     *inttypes.OrderWithErrorsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) CancelOrder(ctx context.Context, req *api.CancelOrderRequest) (resp *inttypes.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelOrderEndpoint{CancelOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CompleteOrderEndpoint struct {
	*api.OrderIDRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) CompleteOrder(ctx context.Context, req *api.OrderIDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CompleteOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CompleteOrderEndpoint{OrderIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:complete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:complete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CompleteOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmOrderEndpoint struct {
	*api.ConfirmOrderRequest
	Result     *inttypes.Order
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) ConfirmOrder(ctx context.Context, req *api.ConfirmOrderRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrderEndpoint{ConfirmOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmOrderAndCreateFulfillmentsEndpoint struct {
	*api.OrderIDRequest
	Result     *inttypes.OrderWithErrorsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) ConfirmOrderAndCreateFulfillments(ctx context.Context, req *api.OrderIDRequest) (resp *inttypes.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrderAndCreateFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrderAndCreateFulfillmentsEndpoint{OrderIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmOrderAndCreateFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateOrderEndpoint struct {
	*inttypes.CreateOrderRequest
	Result     *inttypes.Order
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) CreateOrder(ctx context.Context, req *inttypes.CreateOrderRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CreateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrderEndpoint{CreateOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result     *inttypes.Order
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersEndpoint struct {
	*api.GetOrdersRequest
	Result     *inttypes.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) GetOrders(ctx context.Context, req *api.GetOrdersRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByIDsEndpoint struct {
	*etop.IDsRequest
	Result     *inttypes.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) GetOrdersByIDs(ctx context.Context, req *etop.IDsRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByReceiptIDEndpoint struct {
	*api.GetOrdersByReceiptIDRequest
	Result     *inttypes.OrdersResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) GetOrdersByReceiptID(ctx context.Context, req *api.GetOrdersByReceiptIDRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrdersByReceiptID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByReceiptIDEndpoint{GetOrdersByReceiptIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByReceiptID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderEndpoint struct {
	*inttypes.UpdateOrderRequest
	Result     *inttypes.Order
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) UpdateOrder(ctx context.Context, req *inttypes.UpdateOrderRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderEndpoint{UpdateOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderPaymentStatusEndpoint struct {
	*api.UpdateOrderPaymentStatusRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) UpdateOrderPaymentStatus(ctx context.Context, req *api.UpdateOrderPaymentStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrderPaymentStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderPaymentStatusEndpoint{UpdateOrderPaymentStatusRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrderPaymentStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrderShippingInfoEndpoint struct {
	*api.UpdateOrderShippingInfoRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) UpdateOrderShippingInfo(ctx context.Context, req *api.UpdateOrderShippingInfoRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrderShippingInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderShippingInfoEndpoint{UpdateOrderShippingInfoRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrderShippingInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateOrdersStatusEndpoint struct {
	*api.UpdateOrdersStatusRequest
	Result     *cm.UpdatedResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapOrderService) UpdateOrdersStatus(ctx context.Context, req *api.UpdateOrdersStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrdersStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrdersStatusEndpoint{UpdateOrdersStatusRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateOrdersStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapPaymentService(s *PaymentService) api.PaymentService {
	return wrapPaymentService{s: s}
}

type wrapPaymentService struct {
	s *PaymentService
}

type PaymentCheckReturnDataEndpoint struct {
	*api.PaymentCheckReturnDataRequest
	Result  *cm.MessageResponse
	Context claims.ShopClaim
}

func (s wrapPaymentService) PaymentCheckReturnData(ctx context.Context, req *api.PaymentCheckReturnDataRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Payment/PaymentCheckReturnData"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &PaymentCheckReturnDataEndpoint{PaymentCheckReturnDataRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.PaymentCheckReturnData(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type PaymentTradingOrderEndpoint struct {
	*api.PaymentTradingOrderRequest
	Result  *api.PaymentTradingOrderResponse
	Context claims.ShopClaim
}

func (s wrapPaymentService) PaymentTradingOrder(ctx context.Context, req *api.PaymentTradingOrderRequest) (resp *api.PaymentTradingOrderResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Payment/PaymentTradingOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &PaymentTradingOrderEndpoint{PaymentTradingOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.PaymentTradingOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductService(s *ProductService) api.ProductService {
	return wrapProductService{s: s}
}

type wrapProductService struct {
	s *ProductService
}

type AddProductCollectionEndpoint struct {
	*api.AddShopProductCollectionRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) AddProductCollection(ctx context.Context, req *api.AddShopProductCollectionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/AddProductCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddProductCollectionEndpoint{AddShopProductCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddProductCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateProductEndpoint struct {
	*api.CreateProductRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) CreateProduct(ctx context.Context, req *api.CreateProductRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/CreateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductEndpoint{CreateProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateVariantEndpoint struct {
	*api.CreateVariantRequest
	Result  *api.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) CreateVariant(ctx context.Context, req *api.CreateVariantRequest) (resp *api.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/CreateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateVariantEndpoint{CreateVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductEndpoint struct {
	*cm.IDRequest
	Result     *api.ShopProduct
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductService) GetProduct(ctx context.Context, req *cm.IDRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductsEndpoint struct {
	*api.GetVariantsRequest
	Result     *api.ShopProductsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductService) GetProducts(ctx context.Context, req *api.GetVariantsRequest) (resp *api.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsEndpoint{GetVariantsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductsByIDsEndpoint struct {
	*cm.IDsRequest
	Result     *api.ShopProductsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductService) GetProductsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProductsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantEndpoint struct {
	*api.GetVariantRequest
	Result     *api.ShopVariant
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductService) GetVariant(ctx context.Context, req *api.GetVariantRequest) (resp *api.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantEndpoint{GetVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantsByIDsEndpoint struct {
	*cm.IDsRequest
	Result     *api.ShopVariantsResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductService) GetVariantsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.ShopVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariantsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariantsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantsBySupplierIDEndpoint struct {
	*api.GetVariantsBySupplierIDRequest
	Result  *api.ShopVariantsResponse
	Context claims.ShopClaim
}

func (s wrapProductService) GetVariantsBySupplierID(ctx context.Context, req *api.GetVariantsBySupplierIDRequest) (resp *api.ShopVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetVariantsBySupplierID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantsBySupplierIDEndpoint{GetVariantsBySupplierIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariantsBySupplierID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductCategoryEndpoint struct {
	*cm.IDRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProductCategory(ctx context.Context, req *cm.IDRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProductCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductCategoryEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update|shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update|shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductCollectionEndpoint struct {
	*api.RemoveShopProductCollectionRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProductCollection(ctx context.Context, req *api.RemoveShopProductCollectionRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProductCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductCollectionEndpoint{RemoveShopProductCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update|shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update|shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductsEndpoint struct {
	*api.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveProducts(ctx context.Context, req *api.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductsEndpoint{RemoveVariantsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveVariantsEndpoint struct {
	*api.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) RemoveVariants(ctx context.Context, req *api.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveVariants"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveVariantsEndpoint{RemoveVariantsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:delete|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveVariants(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductEndpoint struct {
	*api.UpdateProductRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProduct(ctx context.Context, req *api.UpdateProductRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductEndpoint{UpdateProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductCategoryEndpoint struct {
	*api.UpdateProductCategoryRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductCategory(ctx context.Context, req *api.UpdateProductCategoryRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductCategoryEndpoint{UpdateProductCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductImagesEndpoint struct {
	*api.UpdateVariantImagesRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductImages(ctx context.Context, req *api.UpdateVariantImagesRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductImagesEndpoint{UpdateVariantImagesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductMetaFieldsEndpoint struct {
	*api.UpdateProductMetaFieldsRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductMetaFields(ctx context.Context, req *api.UpdateProductMetaFieldsRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductMetaFields"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductMetaFieldsEndpoint{UpdateProductMetaFieldsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductMetaFields(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsStatusEndpoint struct {
	*api.UpdateProductStatusRequest
	Result  *api.UpdateProductStatusResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductsStatus(ctx context.Context, req *api.UpdateProductStatusRequest) (resp *api.UpdateProductStatusResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductsStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsStatusEndpoint{UpdateProductStatusRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsTagsEndpoint struct {
	*api.UpdateProductsTagsRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProductsTags(ctx context.Context, req *api.UpdateProductsTagsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductsTags"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsTagsEndpoint{UpdateProductsTagsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsTags(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantEndpoint struct {
	*api.UpdateVariantRequest
	Result  *api.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariant(ctx context.Context, req *api.UpdateVariantRequest) (resp *api.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantEndpoint{UpdateVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantAttributesEndpoint struct {
	*api.UpdateVariantAttributesRequest
	Result  *api.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantAttributes(ctx context.Context, req *api.UpdateVariantAttributesRequest) (resp *api.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantAttributes"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantAttributesEndpoint{UpdateVariantAttributesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantAttributes(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantImagesEndpoint struct {
	*api.UpdateVariantImagesRequest
	Result  *api.ShopVariant
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantImages(ctx context.Context, req *api.UpdateVariantImagesRequest) (resp *api.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantImages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantImagesEndpoint{UpdateVariantImagesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantImages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantsStatusEndpoint struct {
	*api.UpdateProductStatusRequest
	Result  *api.UpdateProductStatusResponse
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateVariantsStatus(ctx context.Context, req *api.UpdateProductStatusRequest) (resp *api.UpdateProductStatusResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantsStatus"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantsStatusEndpoint{UpdateProductStatusRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariantsStatus(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductSourceService(s *ProductSourceService) api.ProductSourceService {
	return wrapProductSourceService{s: s}
}

type wrapProductSourceService struct {
	s *ProductSourceService
}

type CreateProductSourceEndpoint struct {
	*api.CreateProductSourceRequest
	Result  *api.ProductSource
	Context claims.ShopClaim
}

func (s wrapProductSourceService) CreateProductSource(ctx context.Context, req *api.CreateProductSourceRequest) (resp *api.ProductSource, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSource"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceEndpoint{CreateProductSourceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProductSource(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateProductSourceCategoryEndpoint struct {
	*api.CreatePSCategoryRequest
	Result  *api.Category
	Context claims.ShopClaim
}

func (s wrapProductSourceService) CreateProductSourceCategory(ctx context.Context, req *api.CreatePSCategoryRequest) (resp *api.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceCategoryEndpoint{CreatePSCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeprecatedCreateVariantEndpoint struct {
	*api.DeprecatedCreateVariantRequest
	Result     *api.ShopProduct
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductSourceService) CreateVariant(ctx context.Context, req *api.DeprecatedCreateVariantRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/DeprecatedCreateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeprecatedCreateVariantEndpoint{DeprecatedCreateVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductSourceCategoriesEndpoint struct {
	*api.GetProductSourceCategoriesRequest
	Result     *api.CategoriesResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductSourceService) GetProductSourceCategories(ctx context.Context, req *api.GetProductSourceCategoriesRequest) (resp *api.CategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategories"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoriesEndpoint{GetProductSourceCategoriesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductSourceCategories(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result     *api.Category
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductSourceService) GetProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *api.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoryEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopProductSourcesEndpoint struct {
	*cm.Empty
	Result     *api.ProductSourcesResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapProductSourceService) GetShopProductSources(ctx context.Context, req *cm.Empty) (resp *api.ProductSourcesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetShopProductSources"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopProductSourcesEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product/basic_info:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product/basic_info:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShopProductSources(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.ShopClaim
}

func (s wrapProductSourceService) RemoveProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/RemoveProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductSourceCategoryEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:delete|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:delete|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductSourceCategoryEndpoint struct {
	*api.UpdateProductSourceCategoryRequest
	Result  *api.Category
	Context claims.ShopClaim
}

func (s wrapProductSourceService) UpdateProductSourceCategory(ctx context.Context, req *api.UpdateProductSourceCategoryRequest) (resp *api.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductSourceCategoryEndpoint{UpdateProductSourceCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductSourceCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductsPSCategoryEndpoint struct {
	*api.UpdateProductsPSCategoryRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapProductSourceService) UpdateProductsPSCategory(ctx context.Context, req *api.UpdateProductsPSCategoryRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductsPSCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsPSCategoryEndpoint{UpdateProductsPSCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/product:create|shop/product/basic_info:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/product:create|shop/product/basic_info:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProductsPSCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapPurchaseOrderService(s *PurchaseOrderService) api.PurchaseOrderService {
	return wrapPurchaseOrderService{s: s}
}

type wrapPurchaseOrderService struct {
	s *PurchaseOrderService
}

type CancelPurchaseOrderEndpoint struct {
	*api.CancelPurchaseOrderRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) CancelPurchaseOrder(ctx context.Context, req *api.CancelPurchaseOrderRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/CancelPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelPurchaseOrderEndpoint{CancelPurchaseOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmPurchaseOrderEndpoint struct {
	*api.ConfirmPurchaseOrderRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) ConfirmPurchaseOrder(ctx context.Context, req *api.ConfirmPurchaseOrderRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/ConfirmPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmPurchaseOrderEndpoint{ConfirmPurchaseOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreatePurchaseOrderEndpoint struct {
	*api.CreatePurchaseOrderRequest
	Result  *api.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) CreatePurchaseOrder(ctx context.Context, req *api.CreatePurchaseOrderRequest) (resp *api.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/CreatePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePurchaseOrderEndpoint{CreatePurchaseOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreatePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeletePurchaseOrderEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) DeletePurchaseOrder(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/DeletePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeletePurchaseOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeletePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrderEndpoint struct {
	*cm.IDRequest
	Result  *api.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrder(ctx context.Context, req *cm.IDRequest) (resp *api.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersEndpoint struct {
	*api.GetPurchaseOrdersRequest
	Result  *api.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrders(ctx context.Context, req *api.GetPurchaseOrdersRequest) (resp *api.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersEndpoint{GetPurchaseOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseOrdersByReceiptIDEndpoint struct {
	*cm.IDRequest
	Result  *api.PurchaseOrdersResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) GetPurchaseOrdersByReceiptID(ctx context.Context, req *cm.IDRequest) (resp *api.PurchaseOrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/GetPurchaseOrdersByReceiptID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseOrdersByReceiptIDEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseOrdersByReceiptID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePurchaseOrderEndpoint struct {
	*api.UpdatePurchaseOrderRequest
	Result  *api.PurchaseOrder
	Context claims.ShopClaim
}

func (s wrapPurchaseOrderService) UpdatePurchaseOrder(ctx context.Context, req *api.UpdatePurchaseOrderRequest) (resp *api.PurchaseOrder, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseOrder/UpdatePurchaseOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePurchaseOrderEndpoint{UpdatePurchaseOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchase_order:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchase_order:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePurchaseOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapPurchaseRefundService(s *PurchaseRefundService) api.PurchaseRefundService {
	return wrapPurchaseRefundService{s: s}
}

type wrapPurchaseRefundService struct {
	s *PurchaseRefundService
}

type CancelPurchaseRefundEndpoint struct {
	*api.CancelPurchaseRefundRequest
	Result  *api.PurchaseRefund
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) CancelPurchaseRefund(ctx context.Context, req *api.CancelPurchaseRefundRequest) (resp *api.PurchaseRefund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/CancelPurchaseRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelPurchaseRefundEndpoint{CancelPurchaseRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelPurchaseRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmPurchaseRefundEndpoint struct {
	*api.ConfirmPurchaseRefundRequest
	Result  *api.PurchaseRefund
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) ConfirmPurchaseRefund(ctx context.Context, req *api.ConfirmPurchaseRefundRequest) (resp *api.PurchaseRefund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/ConfirmPurchaseRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmPurchaseRefundEndpoint{ConfirmPurchaseRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmPurchaseRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreatePurchaseRefundEndpoint struct {
	*api.CreatePurchaseRefundRequest
	Result  *api.PurchaseRefund
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) CreatePurchaseRefund(ctx context.Context, req *api.CreatePurchaseRefundRequest) (resp *api.PurchaseRefund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/CreatePurchaseRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePurchaseRefundEndpoint{CreatePurchaseRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreatePurchaseRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseRefundEndpoint struct {
	*cm.IDRequest
	Result  *api.PurchaseRefund
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) GetPurchaseRefund(ctx context.Context, req *cm.IDRequest) (resp *api.PurchaseRefund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/GetPurchaseRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseRefundEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseRefundsEndpoint struct {
	*api.GetPurchaseRefundsRequest
	Result  *api.GetPurchaseRefundsResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) GetPurchaseRefunds(ctx context.Context, req *api.GetPurchaseRefundsRequest) (resp *api.GetPurchaseRefundsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/GetPurchaseRefunds"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseRefundsEndpoint{GetPurchaseRefundsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseRefunds(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPurchaseRefundsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.GetPurchaseRefundsByIDsResponse
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) GetPurchaseRefundsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.GetPurchaseRefundsByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/GetPurchaseRefundsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPurchaseRefundsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPurchaseRefundsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePurchaseRefundEndpoint struct {
	*api.UpdatePurchaseRefundRequest
	Result  *api.PurchaseRefund
	Context claims.ShopClaim
}

func (s wrapPurchaseRefundService) UpdatePurchaseRefund(ctx context.Context, req *api.UpdatePurchaseRefundRequest) (resp *api.PurchaseRefund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.PurchaseRefund/UpdatePurchaseRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePurchaseRefundEndpoint{UpdatePurchaseRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/purchaserefund:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/purchaserefund:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePurchaseRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapReceiptService(s *ReceiptService) api.ReceiptService {
	return wrapReceiptService{s: s}
}

type wrapReceiptService struct {
	s *ReceiptService
}

type CancelReceiptEndpoint struct {
	*api.CancelReceiptRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) CancelReceipt(ctx context.Context, req *api.CancelReceiptRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/CancelReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelReceiptEndpoint{CancelReceiptRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmReceiptEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) ConfirmReceipt(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/ConfirmReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmReceiptEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateReceiptEndpoint struct {
	*api.CreateReceiptRequest
	Result  *api.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) CreateReceipt(ctx context.Context, req *api.CreateReceiptRequest) (resp *api.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/CreateReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateReceiptEndpoint{CreateReceiptRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptEndpoint struct {
	*cm.IDRequest
	Result  *api.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceipt(ctx context.Context, req *cm.IDRequest) (resp *api.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptsEndpoint struct {
	*api.GetReceiptsRequest
	Result  *api.ReceiptsResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceipts(ctx context.Context, req *api.GetReceiptsRequest) (resp *api.ReceiptsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceipts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptsEndpoint{GetReceiptsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceipts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetReceiptsByLedgerTypeEndpoint struct {
	*api.GetReceiptsByLedgerTypeRequest
	Result  *api.ReceiptsResponse
	Context claims.ShopClaim
}

func (s wrapReceiptService) GetReceiptsByLedgerType(ctx context.Context, req *api.GetReceiptsByLedgerTypeRequest) (resp *api.ReceiptsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/GetReceiptsByLedgerType"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReceiptsByLedgerTypeEndpoint{GetReceiptsByLedgerTypeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetReceiptsByLedgerType(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReceiptEndpoint struct {
	*api.UpdateReceiptRequest
	Result  *api.Receipt
	Context claims.ShopClaim
}

func (s wrapReceiptService) UpdateReceipt(ctx context.Context, req *api.UpdateReceiptRequest) (resp *api.Receipt, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Receipt/UpdateReceipt"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReceiptEndpoint{UpdateReceiptRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/receipt:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/receipt:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReceipt(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapRefundService(s *RefundService) api.RefundService {
	return wrapRefundService{s: s}
}

type wrapRefundService struct {
	s *RefundService
}

type CancelRefundEndpoint struct {
	*api.CancelRefundRequest
	Result  *api.Refund
	Context claims.ShopClaim
}

func (s wrapRefundService) CancelRefund(ctx context.Context, req *api.CancelRefundRequest) (resp *api.Refund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/CancelRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelRefundEndpoint{CancelRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmRefundEndpoint struct {
	*api.ConfirmRefundRequest
	Result  *api.Refund
	Context claims.ShopClaim
}

func (s wrapRefundService) ConfirmRefund(ctx context.Context, req *api.ConfirmRefundRequest) (resp *api.Refund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/ConfirmRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmRefundEndpoint{ConfirmRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateRefundEndpoint struct {
	*api.CreateRefundRequest
	Result  *api.Refund
	Context claims.ShopClaim
}

func (s wrapRefundService) CreateRefund(ctx context.Context, req *api.CreateRefundRequest) (resp *api.Refund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/CreateRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateRefundEndpoint{CreateRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetRefundEndpoint struct {
	*cm.IDRequest
	Result  *api.Refund
	Context claims.ShopClaim
}

func (s wrapRefundService) GetRefund(ctx context.Context, req *cm.IDRequest) (resp *api.Refund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/GetRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetRefundEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetRefundsEndpoint struct {
	*api.GetRefundsRequest
	Result  *api.GetRefundsResponse
	Context claims.ShopClaim
}

func (s wrapRefundService) GetRefunds(ctx context.Context, req *api.GetRefundsRequest) (resp *api.GetRefundsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/GetRefunds"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetRefundsEndpoint{GetRefundsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetRefunds(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetRefundsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.GetRefundsByIDsResponse
	Context claims.ShopClaim
}

func (s wrapRefundService) GetRefundsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.GetRefundsByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/GetRefundsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetRefundsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetRefundsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateRefundEndpoint struct {
	*api.UpdateRefundRequest
	Result  *api.Refund
	Context claims.ShopClaim
}

func (s wrapRefundService) UpdateRefund(ctx context.Context, req *api.UpdateRefundRequest) (resp *api.Refund, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Refund/UpdateRefund"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateRefundEndpoint{UpdateRefundRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/refund:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/refund:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateRefund(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShipmentService(s *ShipmentService) api.ShipmentService {
	return wrapShipmentService{s: s}
}

type wrapShipmentService struct {
	s *ShipmentService
}

type CancelFulfillmentEndpoint struct {
	*api.CancelFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapShipmentService) CancelFulfillment(ctx context.Context, req *api.CancelFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipment/CancelFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelFulfillmentEndpoint{CancelFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateFulfillmentsEndpoint struct {
	*api.CreateFulfillmentsRequest
	Result  *api.CreateFulfillmentsResponse
	Context claims.ShopClaim
}

func (s wrapShipmentService) CreateFulfillments(ctx context.Context, req *api.CreateFulfillmentsRequest) (resp *api.CreateFulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipment/CreateFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateFulfillmentsEndpoint{CreateFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShippingServicesEndpoint struct {
	*inttypes.GetShippingServicesRequest
	Result  *inttypes.GetShippingServicesResponse
	Context claims.ShopClaim
}

func (s wrapShipmentService) GetShippingServices(ctx context.Context, req *inttypes.GetShippingServicesRequest) (resp *inttypes.GetShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipment/GetShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShippingServicesEndpoint{GetShippingServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/fulfillment:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/fulfillment:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShipnowService(s *ShipnowService) api.ShipnowService {
	return wrapShipnowService{s: s}
}

type wrapShipnowService struct {
	s *ShipnowService
}

type CancelShipnowFulfillmentEndpoint struct {
	*inttypes.CancelShipnowFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapShipnowService) CancelShipnowFulfillment(ctx context.Context, req *inttypes.CancelShipnowFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CancelShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelShipnowFulfillmentEndpoint{CancelShipnowFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) ConfirmShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *inttypes.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/ConfirmShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmShipnowFulfillmentEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShipnowFulfillmentEndpoint struct {
	*inttypes.CreateShipnowFulfillmentRequest
	Result  *inttypes.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) CreateShipnowFulfillment(ctx context.Context, req *inttypes.CreateShipnowFulfillmentRequest) (resp *inttypes.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CreateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipnowFulfillmentEndpoint{CreateShipnowFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShipnowFulfillmentV2Endpoint struct {
	*inttypes.CreateShipnowFulfillmentV2Request
	Result  *inttypes.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) CreateShipnowFulfillmentV2(ctx context.Context, req *inttypes.CreateShipnowFulfillmentV2Request) (resp *inttypes.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CreateShipnowFulfillmentV2"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipnowFulfillmentV2Endpoint{CreateShipnowFulfillmentV2Request: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateShipnowFulfillmentV2(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *inttypes.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowFulfillmentsEndpoint struct {
	*inttypes.GetShipnowFulfillmentsRequest
	Result  *inttypes.ShipnowFulfillments
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowFulfillments(ctx context.Context, req *inttypes.GetShipnowFulfillmentsRequest) (resp *inttypes.ShipnowFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentsEndpoint{GetShipnowFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipnowServicesEndpoint struct {
	*inttypes.GetShipnowServicesRequest
	Result  *inttypes.GetShipnowServicesResponse
	Context claims.ShopClaim
}

func (s wrapShipnowService) GetShipnowServices(ctx context.Context, req *inttypes.GetShipnowServicesRequest) (resp *inttypes.GetShipnowServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowServicesEndpoint{GetShipnowServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShipnowServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipnowFulfillmentEndpoint struct {
	*inttypes.UpdateShipnowFulfillmentRequest
	Result  *inttypes.ShipnowFulfillment
	Context claims.ShopClaim
}

func (s wrapShipnowService) UpdateShipnowFulfillment(ctx context.Context, req *inttypes.UpdateShipnowFulfillmentRequest) (resp *inttypes.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/UpdateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipnowFulfillmentEndpoint{UpdateShipnowFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/shipnow:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/shipnow:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateShipnowFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapStocktakeService(s *StocktakeService) api.StocktakeService {
	return wrapStocktakeService{s: s}
}

type wrapStocktakeService struct {
	s *StocktakeService
}

type CancelStocktakeEndpoint struct {
	*api.CancelStocktakeRequest
	Result  *api.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) CancelStocktake(ctx context.Context, req *api.CancelStocktakeRequest) (resp *api.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/CancelStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelStocktakeEndpoint{CancelStocktakeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:cancel", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:cancel", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmStocktakeEndpoint struct {
	*api.ConfirmStocktakeRequest
	Result  *api.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) ConfirmStocktake(ctx context.Context, req *api.ConfirmStocktakeRequest) (resp *api.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/ConfirmStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmStocktakeEndpoint{ConfirmStocktakeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:confirm", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:confirm", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateStocktakeEndpoint struct {
	*api.CreateStocktakeRequest
	Result  *api.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) CreateStocktake(ctx context.Context, req *api.CreateStocktakeRequest) (resp *api.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/CreateStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateStocktakeEndpoint{CreateStocktakeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakeEndpoint struct {
	*cm.IDRequest
	Result  *api.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktake(ctx context.Context, req *cm.IDRequest) (resp *api.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakeEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakesEndpoint struct {
	*api.GetStocktakesRequest
	Result  *api.GetStocktakesResponse
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktakes(ctx context.Context, req *api.GetStocktakesRequest) (resp *api.GetStocktakesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktakes"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakesEndpoint{GetStocktakesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktakes(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetStocktakesByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.GetStocktakesByIDsResponse
	Context claims.ShopClaim
}

func (s wrapStocktakeService) GetStocktakesByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.GetStocktakesByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/GetStocktakesByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetStocktakesByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetStocktakesByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateStocktakeEndpoint struct {
	*api.UpdateStocktakeRequest
	Result  *api.Stocktake
	Context claims.ShopClaim
}

func (s wrapStocktakeService) UpdateStocktake(ctx context.Context, req *api.UpdateStocktakeRequest) (resp *api.Stocktake, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Stocktake/UpdateStocktake"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateStocktakeEndpoint{UpdateStocktakeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/stocktake:update|shop/stocktake:self_update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/stocktake:update|shop/stocktake:self_update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateStocktake(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSummaryService(s *SummaryService) api.SummaryService {
	return wrapSummaryService{s: s}
}

type wrapSummaryService struct {
	s *SummaryService
}

type CalcBalanceShopEndpoint struct {
	*cm.Empty
	Result     *api.CalcBalanceShopResponse
	Context    claims.ShopClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapSummaryService) CalcBalanceShop(ctx context.Context, req *cm.Empty) (resp *api.CalcBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/CalcBalanceShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CalcBalanceShopEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CalcBalanceShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SummarizeFulfillmentsEndpoint struct {
	*api.SummarizeFulfillmentsRequest
	Result  *api.SummarizeFulfillmentsResponse
	Context claims.ShopClaim
}

func (s wrapSummaryService) SummarizeFulfillments(ctx context.Context, req *api.SummarizeFulfillmentsRequest) (resp *api.SummarizeFulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizeFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizeFulfillmentsEndpoint{SummarizeFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SummarizeFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SummarizePOSEndpoint struct {
	*api.SummarizePOSRequest
	Result  *api.SummarizePOSResponse
	Context claims.ShopClaim
}

func (s wrapSummaryService) SummarizePOS(ctx context.Context, req *api.SummarizePOSRequest) (resp *api.SummarizePOSResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizePOS"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizePOSEndpoint{SummarizePOSRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/dashboard:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/dashboard:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.SummarizePOS(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SummarizeTopShipEndpoint struct {
	*api.SummarizeTopShipRequest
	Result  *api.SummarizeTopShipResponse
	Context claims.ShopClaim
}

func (s wrapSummaryService) SummarizeTopShip(ctx context.Context, req *api.SummarizeTopShipRequest) (resp *api.SummarizeTopShipResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizeTopShip"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizeTopShipEndpoint{SummarizeTopShipRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.SummarizeTopShip(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSupplierService(s *SupplierService) api.SupplierService {
	return wrapSupplierService{s: s}
}

type wrapSupplierService struct {
	s *SupplierService
}

type CreateSupplierEndpoint struct {
	*api.CreateSupplierRequest
	Result  *api.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) CreateSupplier(ctx context.Context, req *api.CreateSupplierRequest) (resp *api.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/CreateSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSupplierEndpoint{CreateSupplierRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSupplierEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) DeleteSupplier(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/DeleteSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSupplierEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSupplierEndpoint struct {
	*cm.IDRequest
	Result  *api.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSupplier(ctx context.Context, req *cm.IDRequest) (resp *api.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSupplierEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersEndpoint struct {
	*api.GetSuppliersRequest
	Result  *api.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliers(ctx context.Context, req *api.GetSuppliersRequest) (resp *api.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersEndpoint{GetSuppliersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSuppliersByVariantIDEndpoint struct {
	*api.GetSuppliersByVariantIDRequest
	Result  *api.SuppliersResponse
	Context claims.ShopClaim
}

func (s wrapSupplierService) GetSuppliersByVariantID(ctx context.Context, req *api.GetSuppliersByVariantIDRequest) (resp *api.SuppliersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/GetSuppliersByVariantID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSuppliersByVariantIDEndpoint{GetSuppliersByVariantIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetSuppliersByVariantID(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateSupplierEndpoint struct {
	*api.UpdateSupplierRequest
	Result  *api.Supplier
	Context claims.ShopClaim
}

func (s wrapSupplierService) UpdateSupplier(ctx context.Context, req *api.UpdateSupplierRequest) (resp *api.Supplier, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Supplier/UpdateSupplier"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateSupplierEndpoint{UpdateSupplierRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/supplier:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/supplier:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateSupplier(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapTradingService(s *TradingService) api.TradingService {
	return wrapTradingService{s: s}
}

type wrapTradingService struct {
	s *TradingService
}

type TradingCreateOrderEndpoint struct {
	*inttypes.TradingCreateOrderRequest
	Result  *inttypes.Order
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingCreateOrder(ctx context.Context, req *inttypes.TradingCreateOrderRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingCreateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingCreateOrderEndpoint{TradingCreateOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/order:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingCreateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetOrderEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.Order
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetOrder(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetOrdersEndpoint struct {
	*api.GetOrdersRequest
	Result  *inttypes.OrdersResponse
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetOrders(ctx context.Context, req *api.GetOrdersRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetOrdersEndpoint{GetOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/order:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/order:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetProductEndpoint struct {
	*cm.IDRequest
	Result  *api.ShopProduct
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetProduct(ctx context.Context, req *cm.IDRequest) (resp *api.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetProductEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/product:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/product:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type TradingGetProductsEndpoint struct {
	*cm.CommonListRequest
	Result  *api.ShopProductsResponse
	Context claims.ShopClaim
}

func (s wrapTradingService) TradingGetProducts(ctx context.Context, req *cm.CommonListRequest) (resp *api.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Trading/TradingGetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetProductsEndpoint{CommonListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/trading/product:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/trading/product:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.TradingGetProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapWebServerService(s *WebServerService) api.WebServerService {
	return wrapWebServerService{s: s}
}

type wrapWebServerService struct {
	s *WebServerService
}

type CreateOrUpdateWsCategoryEndpoint struct {
	*api.CreateOrUpdateWsCategoryRequest
	Result  *api.WsCategory
	Context claims.ShopClaim
}

func (s wrapWebServerService) CreateOrUpdateWsCategory(ctx context.Context, req *api.CreateOrUpdateWsCategoryRequest) (resp *api.WsCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/CreateOrUpdateWsCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrUpdateWsCategoryEndpoint{CreateOrUpdateWsCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wscategory:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wscategory:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateOrUpdateWsCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateOrUpdateWsProductEndpoint struct {
	*api.CreateOrUpdateWsProductRequest
	Result  *api.WsProduct
	Context claims.ShopClaim
}

func (s wrapWebServerService) CreateOrUpdateWsProduct(ctx context.Context, req *api.CreateOrUpdateWsProductRequest) (resp *api.WsProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/CreateOrUpdateWsProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrUpdateWsProductEndpoint{CreateOrUpdateWsProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wsproduct:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wsproduct:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateOrUpdateWsProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateWsPageEndpoint struct {
	*api.CreateWsPageRequest
	Result  *api.WsPage
	Context claims.ShopClaim
}

func (s wrapWebServerService) CreateWsPage(ctx context.Context, req *api.CreateWsPageRequest) (resp *api.WsPage, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/CreateWsPage"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateWsPageEndpoint{CreateWsPageRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateWsPage(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateWsWebsiteEndpoint struct {
	*api.CreateWsWebsiteRequest
	Result  *api.WsWebsite
	Context claims.ShopClaim
}

func (s wrapWebServerService) CreateWsWebsite(ctx context.Context, req *api.CreateWsWebsiteRequest) (resp *api.WsWebsite, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/CreateWsWebsite"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateWsWebsiteEndpoint{CreateWsWebsiteRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wswebsite:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wswebsite:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateWsWebsite(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteWsPageEndpoint struct {
	*api.DeteleWsPageRequest
	Result  *api.DeteleWsPageResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) DeleteWsPage(ctx context.Context, req *api.DeteleWsPageRequest) (resp *api.DeteleWsPageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/DeleteWsPage"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteWsPageEndpoint{DeteleWsPageRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteWsPage(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsCategoriesEndpoint struct {
	*api.GetWsCategoriesRequest
	Result  *api.GetWsCategoriesResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsCategories(ctx context.Context, req *api.GetWsCategoriesRequest) (resp *api.GetWsCategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsCategories"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsCategoriesEndpoint{GetWsCategoriesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wscategory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wscategory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsCategories(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsCategoriesByIDsEndpoint struct {
	*api.GetWsCategoriesByIDsRequest
	Result  *api.GetWsCategoriesByIDsResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsCategoriesByIDs(ctx context.Context, req *api.GetWsCategoriesByIDsRequest) (resp *api.GetWsCategoriesByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsCategoriesByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsCategoriesByIDsEndpoint{GetWsCategoriesByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wscategory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wscategory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsCategoriesByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsCategoryEndpoint struct {
	*api.GetWsCategoryRequest
	Result  *api.WsCategory
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsCategory(ctx context.Context, req *api.GetWsCategoryRequest) (resp *api.WsCategory, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsCategory"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsCategoryEndpoint{GetWsCategoryRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wscategory:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wscategory:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsCategory(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsPageEndpoint struct {
	*api.GetWsPageRequest
	Result  *api.WsPage
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsPage(ctx context.Context, req *api.GetWsPageRequest) (resp *api.WsPage, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsPage"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsPageEndpoint{GetWsPageRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsPage(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsPagesEndpoint struct {
	*api.GetWsPagesRequest
	Result  *api.GetWsPagesResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsPages(ctx context.Context, req *api.GetWsPagesRequest) (resp *api.GetWsPagesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsPages"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsPagesEndpoint{GetWsPagesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsPages(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsPagesByIDsEndpoint struct {
	*api.GetWsPagesByIDsRequest
	Result  *api.GetWsPagesByIDsResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsPagesByIDs(ctx context.Context, req *api.GetWsPagesByIDsRequest) (resp *api.GetWsPagesByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsPagesByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsPagesByIDsEndpoint{GetWsPagesByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsPagesByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsProductEndpoint struct {
	*api.GetWsProductRequest
	Result  *api.WsProduct
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsProduct(ctx context.Context, req *api.GetWsProductRequest) (resp *api.WsProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsProductEndpoint{GetWsProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wsproduct:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wsproduct:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsProductsEndpoint struct {
	*api.GetWsProductsRequest
	Result  *api.GetWsProductsResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsProducts(ctx context.Context, req *api.GetWsProductsRequest) (resp *api.GetWsProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsProductsEndpoint{GetWsProductsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wsproduct:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wsproduct:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsProductsByIDsEndpoint struct {
	*api.GetWsProductsByIDsRequest
	Result  *api.GetWsProductsByIDsResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsProductsByIDs(ctx context.Context, req *api.GetWsProductsByIDsRequest) (resp *api.GetWsProductsByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsProductsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsProductsByIDsEndpoint{GetWsProductsByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wsproduct:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wsproduct:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsProductsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsWebsiteEndpoint struct {
	*api.GetWsWebsiteRequest
	Result  *api.WsWebsite
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsWebsite(ctx context.Context, req *api.GetWsWebsiteRequest) (resp *api.WsWebsite, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsWebsite"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsWebsiteEndpoint{GetWsWebsiteRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wswebsite:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wswebsite:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsWebsite(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsWebsitesEndpoint struct {
	*api.GetWsWebsitesRequest
	Result  *api.GetWsWebsitesResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsWebsites(ctx context.Context, req *api.GetWsWebsitesRequest) (resp *api.GetWsWebsitesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsWebsites"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsWebsitesEndpoint{GetWsWebsitesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wswebsite:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wswebsite:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsWebsites(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWsWebsitesByIDsEndpoint struct {
	*api.GetWsWebsitesByIDsRequest
	Result  *api.GetWsWebsitesByIDsResponse
	Context claims.ShopClaim
}

func (s wrapWebServerService) GetWsWebsitesByIDs(ctx context.Context, req *api.GetWsWebsitesByIDsRequest) (resp *api.GetWsWebsitesByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/GetWsWebsitesByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWsWebsitesByIDsEndpoint{GetWsWebsitesByIDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wswebsite:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wswebsite:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWsWebsitesByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateWsPageEndpoint struct {
	*api.UpdateWsPageRequest
	Result  *api.WsPage
	Context claims.ShopClaim
}

func (s wrapWebServerService) UpdateWsPage(ctx context.Context, req *api.UpdateWsPageRequest) (resp *api.WsPage, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/UpdateWsPage"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateWsPageEndpoint{UpdateWsPageRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wspage:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wspage:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateWsPage(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateWsWebsiteEndpoint struct {
	*api.UpdateWsWebsiteRequest
	Result  *api.WsWebsite
	Context claims.ShopClaim
}

func (s wrapWebServerService) UpdateWsWebsite(ctx context.Context, req *api.UpdateWsWebsiteRequest) (resp *api.WsWebsite, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.WebServer/UpdateWsWebsite"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateWsWebsiteEndpoint{UpdateWsWebsiteRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "shop/webserver/wswebsite:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("shop/webserver/wswebsite:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateWsWebsite(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
