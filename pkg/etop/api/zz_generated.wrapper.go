// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package api

import (
	"context"
	"time"

	cm "etop.vn/api/pb/common"
	etop "etop.vn/api/pb/etop"
	shop "etop.vn/api/pb/etop/shop"
	api "etop.vn/api/top/int/etop"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	model "etop.vn/backend/pkg/etop/model"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type GetPublicPartnerInfoEndpoint struct {
	*cm.IDRequest
	Result  *etop.PublicAccountInfo
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartnerInfo(ctx context.Context, req *cm.IDRequest) (resp *etop.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartnerInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnerInfoEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartnerInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicPartnersEndpoint struct {
	*cm.IDsRequest
	Result  *etop.PublicAccountsResponse
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartners(ctx context.Context, req *cm.IDsRequest) (resp *etop.PublicAccountsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnersEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateURLSlugEndpoint struct {
	*etop.UpdateURLSlugRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAccountService) UpdateURLSlug(ctx context.Context, req *etop.UpdateURLSlugRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/UpdateURLSlug"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateURLSlugEndpoint{UpdateURLSlugRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateURLSlug(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapAddressService(s *AddressService) api.AddressService {
	return wrapAddressService{s: s}
}

type wrapAddressService struct {
	s *AddressService
}

type CreateAddressEndpoint struct {
	*etop.CreateAddressRequest
	Result  *etop.Address
	Context claims.UserClaim
}

func (s wrapAddressService) CreateAddress(ctx context.Context, req *etop.CreateAddressRequest) (resp *etop.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/CreateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAddressEndpoint{CreateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAddressesEndpoint struct {
	*cm.Empty
	Result     *etop.GetAddressResponse
	Context    claims.UserClaim
	CtxPartner *model.Partner
}

func (s wrapAddressService) GetAddresses(ctx context.Context, req *cm.Empty) (resp *etop.GetAddressResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/GetAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAddressesEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAddressService) RemoveAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/RemoveAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveAddressEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAddressEndpoint struct {
	*etop.UpdateAddressRequest
	Result  *etop.Address
	Context claims.UserClaim
}

func (s wrapAddressService) UpdateAddress(ctx context.Context, req *etop.UpdateAddressRequest) (resp *etop.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/UpdateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAddressEndpoint{UpdateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapBankService(s *BankService) api.BankService {
	return wrapBankService{s: s}
}

type wrapBankService struct {
	s *BankService
}

type GetBanksEndpoint struct {
	*cm.Empty
	Result  *etop.GetBanksResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBanks(ctx context.Context, req *cm.Empty) (resp *etop.GetBanksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBanks"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBanksEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBanks(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBranchesByBankProvinceEndpoint struct {
	*etop.GetBranchesByBankProvinceResquest
	Result  *etop.GetBranchesByBankProvinceResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBranchesByBankProvince(ctx context.Context, req *etop.GetBranchesByBankProvinceResquest) (resp *etop.GetBranchesByBankProvinceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBranchesByBankProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBranchesByBankProvinceEndpoint{GetBranchesByBankProvinceResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBranchesByBankProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesByBankEndpoint struct {
	*etop.GetProvincesByBankResquest
	Result  *etop.GetBankProvincesResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetProvincesByBank(ctx context.Context, req *etop.GetProvincesByBankResquest) (resp *etop.GetBankProvincesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetProvincesByBank"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProvincesByBankEndpoint{GetProvincesByBankResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvincesByBank(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapInvitationService(s *InvitationService) api.InvitationService {
	return wrapInvitationService{s: s}
}

type wrapInvitationService struct {
	s *InvitationService
}

type AcceptInvitationEndpoint struct {
	*etop.AcceptInvitationRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapInvitationService) AcceptInvitation(ctx context.Context, req *etop.AcceptInvitationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Invitation/AcceptInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AcceptInvitationEndpoint{AcceptInvitationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.AcceptInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInvitationByTokenEndpoint struct {
	*etop.GetInvitationByTokenRequest
	Result  *etop.Invitation
	Context claims.EmptyClaim
}

func (s wrapInvitationService) GetInvitationByToken(ctx context.Context, req *etop.GetInvitationByTokenRequest) (resp *etop.Invitation, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Invitation/GetInvitationByToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetInvitationByTokenEndpoint{GetInvitationByTokenRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInvitationByToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetInvitationsEndpoint struct {
	*etop.GetInvitationsRequest
	Result  *shop.InvitationsResponse
	Context claims.UserClaim
}

func (s wrapInvitationService) GetInvitations(ctx context.Context, req *etop.GetInvitationsRequest) (resp *shop.InvitationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Invitation/GetInvitations"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetInvitationsEndpoint{GetInvitationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInvitations(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RejectInvitationEndpoint struct {
	*etop.RejectInvitationRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapInvitationService) RejectInvitation(ctx context.Context, req *etop.RejectInvitationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Invitation/RejectInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RejectInvitationEndpoint{RejectInvitationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RejectInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapLocationService(s *LocationService) api.LocationService {
	return wrapLocationService{s: s}
}

type wrapLocationService struct {
	s *LocationService
}

type GetDistrictsEndpoint struct {
	*cm.Empty
	Result  *etop.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistricts(ctx context.Context, req *cm.Empty) (resp *etop.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistricts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetDistrictsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistricts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetDistrictsByProvinceEndpoint struct {
	*etop.GetDistrictsByProvinceRequest
	Result  *etop.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistrictsByProvince(ctx context.Context, req *etop.GetDistrictsByProvinceRequest) (resp *etop.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistrictsByProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetDistrictsByProvinceEndpoint{GetDistrictsByProvinceRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistrictsByProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesEndpoint struct {
	*cm.Empty
	Result  *etop.GetProvincesResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetProvinces(ctx context.Context, req *cm.Empty) (resp *etop.GetProvincesResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetProvinces"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetProvincesEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvinces(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsEndpoint struct {
	*cm.Empty
	Result  *etop.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWards(ctx context.Context, req *cm.Empty) (resp *etop.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWards"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetWardsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWards(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsByDistrictEndpoint struct {
	*etop.GetWardsByDistrictRequest
	Result  *etop.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWardsByDistrict(ctx context.Context, req *etop.GetWardsByDistrictRequest) (resp *etop.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWardsByDistrict"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetWardsByDistrictEndpoint{GetWardsByDistrictRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWardsByDistrict(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ParseLocationEndpoint struct {
	*etop.ParseLocationRequest
	Result  *etop.ParseLocationResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) ParseLocation(ctx context.Context, req *etop.ParseLocationRequest) (resp *etop.ParseLocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/ParseLocation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ParseLocationEndpoint{ParseLocationRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.ParseLocation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapRelationshipService(s *RelationshipService) api.RelationshipService {
	return wrapRelationshipService{s: s}
}

type wrapRelationshipService struct {
	s *RelationshipService
}

type AnswerInvitationEndpoint struct {
	*etop.AnswerInvitationRequest
	Result  *etop.UserAccountInfo
	Context claims.UserClaim
}

func (s wrapRelationshipService) AnswerInvitation(ctx context.Context, req *etop.AnswerInvitationRequest) (resp *etop.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/AnswerInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AnswerInvitationEndpoint{AnswerInvitationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.AnswerInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetUsersInCurrentAccountsEndpoint struct {
	*etop.GetUsersInCurrentAccountsRequest
	Result  *etop.ProtectedUsersResponse
	Context claims.UserClaim
}

func (s wrapRelationshipService) GetUsersInCurrentAccounts(ctx context.Context, req *etop.GetUsersInCurrentAccountsRequest) (resp *etop.ProtectedUsersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/GetUsersInCurrentAccounts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetUsersInCurrentAccountsEndpoint{GetUsersInCurrentAccountsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetUsersInCurrentAccounts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type InviteUserToAccountEndpoint struct {
	*etop.InviteUserToAccountRequest
	Result  *etop.UserAccountInfo
	Context claims.UserClaim
}

func (s wrapRelationshipService) InviteUserToAccount(ctx context.Context, req *etop.InviteUserToAccountRequest) (resp *etop.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/InviteUserToAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &InviteUserToAccountEndpoint{InviteUserToAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.InviteUserToAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LeaveAccountEndpoint struct {
	*etop.LeaveAccountRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapRelationshipService) LeaveAccount(ctx context.Context, req *etop.LeaveAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/LeaveAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LeaveAccountEndpoint{LeaveAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.LeaveAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveUserFromCurrentAccountEndpoint struct {
	*etop.RemoveUserFromCurrentAccountRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapRelationshipService) RemoveUserFromCurrentAccount(ctx context.Context, req *etop.RemoveUserFromCurrentAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/RemoveUserFromCurrentAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveUserFromCurrentAccountEndpoint{RemoveUserFromCurrentAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveUserFromCurrentAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapUserService(s *UserService) api.UserService {
	return wrapUserService{s: s}
}

type wrapUserService struct {
	s *UserService
}

type ChangePasswordEndpoint struct {
	*etop.ChangePasswordRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapUserService) ChangePassword(ctx context.Context, req *etop.ChangePasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ChangePasswordEndpoint{ChangePasswordRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ChangePasswordUsingTokenEndpoint struct {
	*etop.ChangePasswordUsingTokenRequest
	Result  *cm.Empty
	Context claims.EmptyClaim
}

func (s wrapUserService) ChangePasswordUsingToken(ctx context.Context, req *etop.ChangePasswordUsingTokenRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePasswordUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &ChangePasswordUsingTokenEndpoint{ChangePasswordUsingTokenRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePasswordUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LoginEndpoint struct {
	*etop.LoginRequest
	Result  *etop.LoginResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Login(ctx context.Context, req *etop.LoginRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Login"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &LoginEndpoint{LoginRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Login(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterEndpoint struct {
	*etop.CreateUserRequest
	Result  *etop.RegisterResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Register(ctx context.Context, req *etop.CreateUserRequest) (resp *etop.RegisterResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Register"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &RegisterEndpoint{CreateUserRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Register(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ResetPasswordEndpoint struct {
	*etop.ResetPasswordRequest
	Result  *cm.MessageResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) ResetPassword(ctx context.Context, req *etop.ResetPasswordRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &ResetPasswordEndpoint{ResetPasswordRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ResetPassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendEmailVerificationEndpoint struct {
	*etop.SendEmailVerificationRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendEmailVerification(ctx context.Context, req *etop.SendEmailVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendEmailVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendEmailVerificationEndpoint{SendEmailVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendEmailVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendPhoneVerificationEndpoint struct {
	*etop.SendPhoneVerificationRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendPhoneVerification(ctx context.Context, req *etop.SendPhoneVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendPhoneVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendPhoneVerificationEndpoint{SendPhoneVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendPhoneVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendSTokenEmailEndpoint struct {
	*etop.SendSTokenEmailRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendSTokenEmail(ctx context.Context, req *etop.SendSTokenEmailRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendSTokenEmail"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendSTokenEmailEndpoint{SendSTokenEmailRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendSTokenEmail(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SessionInfoEndpoint struct {
	*cm.Empty
	Result  *etop.LoginResponse
	Context claims.UserClaim
}

func (s wrapUserService) SessionInfo(ctx context.Context, req *cm.Empty) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SessionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SessionInfoEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SessionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SwitchAccountEndpoint struct {
	*etop.SwitchAccountRequest
	Result  *etop.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) SwitchAccount(ctx context.Context, req *etop.SwitchAccountRequest) (resp *etop.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SwitchAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SwitchAccountEndpoint{SwitchAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SwitchAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePermissionEndpoint struct {
	*etop.UpdatePermissionRequest
	Result  *etop.UpdatePermissionResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdatePermission(ctx context.Context, req *etop.UpdatePermissionRequest) (resp *etop.UpdatePermissionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdatePermission"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePermissionEndpoint{UpdatePermissionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePermission(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceSaleEndpoint struct {
	*etop.UpdateReferenceSaleRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceSale(ctx context.Context, req *etop.UpdateReferenceSaleRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceSale"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceSaleEndpoint{UpdateReferenceSaleRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceSale(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceUserEndpoint struct {
	*etop.UpdateReferenceUserRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceUser(ctx context.Context, req *etop.UpdateReferenceUserRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceUserEndpoint{UpdateReferenceUserRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceUser(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpgradeAccessTokenEndpoint struct {
	*etop.UpgradeAccessTokenRequest
	Result  *etop.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpgradeAccessToken(ctx context.Context, req *etop.UpgradeAccessTokenRequest) (resp *etop.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpgradeAccessToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpgradeAccessTokenEndpoint{UpgradeAccessTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpgradeAccessToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyEmailUsingTokenEndpoint struct {
	*etop.VerifyEmailUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) VerifyEmailUsingToken(ctx context.Context, req *etop.VerifyEmailUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyEmailUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyEmailUsingTokenEndpoint{VerifyEmailUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyEmailUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyPhoneUsingTokenEndpoint struct {
	*etop.VerifyPhoneUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) VerifyPhoneUsingToken(ctx context.Context, req *etop.VerifyPhoneUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyPhoneUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyPhoneUsingTokenEndpoint{VerifyPhoneUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyPhoneUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
