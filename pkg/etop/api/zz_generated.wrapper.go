// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package api

import (
	"context"
	"strings"
	"time"

	api "etop.vn/api/top/int/etop"
	cm "etop.vn/api/top/types/common"
	identitymodel "etop.vn/backend/com/main/identity/model"
	common "etop.vn/backend/pkg/common"
	cmwrapper "etop.vn/backend/pkg/common/apifw/wrapper"
	bus "etop.vn/backend/pkg/common/bus"
	auth "etop.vn/backend/pkg/etop/authorize/auth"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type GetPublicPartnerInfoEndpoint struct {
	*cm.IDRequest
	Result  *api.PublicAccountInfo
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartnerInfo(ctx context.Context, req *cm.IDRequest) (resp *api.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartnerInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnerInfoEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartnerInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicPartnersEndpoint struct {
	*cm.IDsRequest
	Result  *api.PublicAccountsResponse
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartners(ctx context.Context, req *cm.IDsRequest) (resp *api.PublicAccountsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnersEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateURLSlugEndpoint struct {
	*api.UpdateURLSlugRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAccountService) UpdateURLSlug(ctx context.Context, req *api.UpdateURLSlugRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/UpdateURLSlug"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateURLSlugEndpoint{UpdateURLSlugRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateURLSlug(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapAccountRelationshipService(s *AccountRelationshipService) api.AccountRelationshipService {
	return wrapAccountRelationshipService{s: s}
}

type wrapAccountRelationshipService struct {
	s *AccountRelationshipService
}

type AccountRelationshipCreateInvitationEndpoint struct {
	*api.CreateInvitationRequest
	Result  *api.Invitation
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) CreateInvitation(ctx context.Context, req *api.CreateInvitationRequest) (resp *api.Invitation, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/CreateInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipCreateInvitationEndpoint{CreateInvitationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/invitation:create", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/invitation:create", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipDeleteInvitationEndpoint struct {
	*api.DeleteInvitationRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) DeleteInvitation(ctx context.Context, req *api.DeleteInvitationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/DeleteInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipDeleteInvitationEndpoint{DeleteInvitationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/invitation:delete", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/invitation:delete", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipGetInvitationsEndpoint struct {
	*api.GetInvitationsRequest
	Result  *api.InvitationsResponse
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) GetInvitations(ctx context.Context, req *api.GetInvitationsRequest) (resp *api.InvitationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/GetInvitations"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipGetInvitationsEndpoint{GetInvitationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/invitation:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/invitation:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInvitations(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipGetRelationshipsEndpoint struct {
	*api.GetRelationshipsRequest
	Result  *api.RelationshipsResponse
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) GetRelationships(ctx context.Context, req *api.GetRelationshipsRequest) (resp *api.RelationshipsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/GetRelationships"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipGetRelationshipsEndpoint{GetRelationshipsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/relationship:view", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/relationship:view", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetRelationships(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipRemoveUserEndpoint struct {
	*api.RemoveUserRequest
	Result  *cm.UpdatedResponse
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) RemoveUser(ctx context.Context, req *api.RemoveUserRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/RemoveUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipRemoveUserEndpoint{RemoveUserRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/user:remove", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/user:remove", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveUser(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipUpdatePermissionEndpoint struct {
	*api.UpdateAccountUserPermissionRequest
	Result  *api.Relationship
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) UpdatePermission(ctx context.Context, req *api.UpdateAccountUserPermissionRequest) (resp *api.Relationship, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/UpdatePermission"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipUpdatePermissionEndpoint{UpdateAccountUserPermissionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/permission:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/permission:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePermission(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type AccountRelationshipUpdateRelationshipEndpoint struct {
	*api.UpdateRelationshipRequest
	Result  *api.Relationship
	Context claims.ShopClaim
}

func (s wrapAccountRelationshipService) UpdateRelationship(ctx context.Context, req *api.UpdateRelationshipRequest) (resp *api.Relationship, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.AccountRelationship/UpdateRelationship"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireShop: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AccountRelationshipUpdateRelationshipEndpoint{UpdateRelationshipRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	isTest := 0
	if query.Context.Shop != nil {
		isTest = query.Context.Shop.IsTest
	}
	authorization := auth.New()
	// Do not check permission for 3rd party requests
	if session.Claim.AuthPartnerID == 0 && !authorization.Check(query.Context.Roles, "relationship/relationship:update", isTest) {
		return nil, common.Error(common.PermissionDenied, "", nil)
	}
	query.Context.Actions = strings.Split("relationship/relationship:update", "|")
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateRelationship(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapAddressService(s *AddressService) api.AddressService {
	return wrapAddressService{s: s}
}

type wrapAddressService struct {
	s *AddressService
}

type CreateAddressEndpoint struct {
	*api.CreateAddressRequest
	Result  *api.Address
	Context claims.UserClaim
}

func (s wrapAddressService) CreateAddress(ctx context.Context, req *api.CreateAddressRequest) (resp *api.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/CreateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAddressEndpoint{CreateAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAddressesEndpoint struct {
	*cm.Empty
	Result     *api.GetAddressResponse
	Context    claims.UserClaim
	CtxPartner *identitymodel.Partner
}

func (s wrapAddressService) GetAddresses(ctx context.Context, req *cm.Empty) (resp *api.GetAddressResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/GetAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAddressesEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAddressService) RemoveAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/RemoveAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveAddressEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAddressEndpoint struct {
	*api.UpdateAddressRequest
	Result  *api.Address
	Context claims.UserClaim
}

func (s wrapAddressService) UpdateAddress(ctx context.Context, req *api.UpdateAddressRequest) (resp *api.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/UpdateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAddressEndpoint{UpdateAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapBankService(s *BankService) api.BankService {
	return wrapBankService{s: s}
}

type wrapBankService struct {
	s *BankService
}

type GetBanksEndpoint struct {
	*cm.Empty
	Result  *api.GetBanksResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBanks(ctx context.Context, req *cm.Empty) (resp *api.GetBanksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBanks"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBanksEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBanks(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBranchesByBankProvinceEndpoint struct {
	*api.GetBranchesByBankProvinceResquest
	Result  *api.GetBranchesByBankProvinceResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBranchesByBankProvince(ctx context.Context, req *api.GetBranchesByBankProvinceResquest) (resp *api.GetBranchesByBankProvinceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBranchesByBankProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBranchesByBankProvinceEndpoint{GetBranchesByBankProvinceResquest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBranchesByBankProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesByBankEndpoint struct {
	*api.GetProvincesByBankResquest
	Result  *api.GetBankProvincesResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetProvincesByBank(ctx context.Context, req *api.GetProvincesByBankResquest) (resp *api.GetBankProvincesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetProvincesByBank"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProvincesByBankEndpoint{GetProvincesByBankResquest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvincesByBank(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapLocationService(s *LocationService) api.LocationService {
	return wrapLocationService{s: s}
}

type wrapLocationService struct {
	s *LocationService
}

type GetDistrictsEndpoint struct {
	*cm.Empty
	Result  *api.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistricts(ctx context.Context, req *cm.Empty) (resp *api.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistricts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetDistrictsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistricts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetDistrictsByProvinceEndpoint struct {
	*api.GetDistrictsByProvinceRequest
	Result  *api.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistrictsByProvince(ctx context.Context, req *api.GetDistrictsByProvinceRequest) (resp *api.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistrictsByProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetDistrictsByProvinceEndpoint{GetDistrictsByProvinceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistrictsByProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesEndpoint struct {
	*cm.Empty
	Result  *api.GetProvincesResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetProvinces(ctx context.Context, req *cm.Empty) (resp *api.GetProvincesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/GetProvinces"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetProvincesEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvinces(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsEndpoint struct {
	*cm.Empty
	Result  *api.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWards(ctx context.Context, req *cm.Empty) (resp *api.GetWardsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWards"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetWardsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWards(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsByDistrictEndpoint struct {
	*api.GetWardsByDistrictRequest
	Result  *api.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWardsByDistrict(ctx context.Context, req *api.GetWardsByDistrictRequest) (resp *api.GetWardsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWardsByDistrict"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &GetWardsByDistrictEndpoint{GetWardsByDistrictRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWardsByDistrict(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ParseLocationEndpoint struct {
	*api.ParseLocationRequest
	Result  *api.ParseLocationResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) ParseLocation(ctx context.Context, req *api.ParseLocationRequest) (resp *api.ParseLocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/ParseLocation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ParseLocationEndpoint{ParseLocationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ParseLocation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapUserService(s *UserService) api.UserService {
	return wrapUserService{s: s}
}

type wrapUserService struct {
	s *UserService
}

type ChangePasswordEndpoint struct {
	*api.ChangePasswordRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapUserService) ChangePassword(ctx context.Context, req *api.ChangePasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ChangePasswordEndpoint{ChangePasswordRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ChangePasswordUsingTokenEndpoint struct {
	*api.ChangePasswordUsingTokenRequest
	Result  *cm.Empty
	Context claims.EmptyClaim
}

func (s wrapUserService) ChangePasswordUsingToken(ctx context.Context, req *api.ChangePasswordUsingTokenRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePasswordUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &ChangePasswordUsingTokenEndpoint{ChangePasswordUsingTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePasswordUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CheckUserRegistrationEndpoint struct {
	*api.GetUserByPhoneRequest
	Result  *api.GetUserByPhoneResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) CheckUserRegistration(ctx context.Context, req *api.GetUserByPhoneRequest) (resp *api.GetUserByPhoneResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/CheckUserRegistration"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &CheckUserRegistrationEndpoint{GetUserByPhoneRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	// Verify captcha token
	if err := middleware.VerifyCaptcha(ctx, req.RecaptchaToken); err != nil {
		return nil, err
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.CheckUserRegistration(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type InitSessionEndpoint struct {
	*cm.Empty
	Result  *api.LoginResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) InitSession(ctx context.Context, req *cm.Empty) (resp *api.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/InitSession"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &InitSessionEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.InitSession(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LoginEndpoint struct {
	*api.LoginRequest
	Result  *api.LoginResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Login(ctx context.Context, req *api.LoginRequest) (resp *api.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/Login"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &LoginEndpoint{LoginRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Login(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterEndpoint struct {
	*api.CreateUserRequest
	Result  *api.RegisterResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Register(ctx context.Context, req *api.CreateUserRequest) (resp *api.RegisterResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/Register"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &RegisterEndpoint{CreateUserRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Register(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterUsingTokenEndpoint struct {
	*api.CreateUserRequest
	Result  *api.RegisterResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) RegisterUsingToken(ctx context.Context, req *api.CreateUserRequest) (resp *api.RegisterResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/RegisterUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &RegisterUsingTokenEndpoint{CreateUserRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RegisterUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ResetPasswordEndpoint struct {
	*api.ResetPasswordRequest
	Result  *api.ResetPasswordResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) ResetPassword(ctx context.Context, req *api.ResetPasswordRequest) (resp *api.ResetPasswordResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &ResetPasswordEndpoint{ResetPasswordRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	// Verify captcha token
	if req.RecaptchaToken != "" || req.RequireCaptcha() {
		if err := middleware.VerifyCaptcha(ctx, req.RecaptchaToken); err != nil {
			return nil, err
		}
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ResetPassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendEmailVerificationEndpoint struct {
	*api.SendEmailVerificationRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendEmailVerification(ctx context.Context, req *api.SendEmailVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendEmailVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendEmailVerificationEndpoint{SendEmailVerificationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendEmailVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendPhoneVerificationEndpoint struct {
	*api.SendPhoneVerificationRequest
	Result  *cm.MessageResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) SendPhoneVerification(ctx context.Context, req *api.SendPhoneVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendPhoneVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &SendPhoneVerificationEndpoint{SendPhoneVerificationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendPhoneVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendSTokenEmailEndpoint struct {
	*api.SendSTokenEmailRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendSTokenEmail(ctx context.Context, req *api.SendSTokenEmailRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendSTokenEmail"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendSTokenEmailEndpoint{SendSTokenEmailRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendSTokenEmail(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SessionInfoEndpoint struct {
	*cm.Empty
	Result  *api.LoginResponse
	Context claims.UserClaim
}

func (s wrapUserService) SessionInfo(ctx context.Context, req *cm.Empty) (resp *api.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SessionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SessionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.SessionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SwitchAccountEndpoint struct {
	*api.SwitchAccountRequest
	Result  *api.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) SwitchAccount(ctx context.Context, req *api.SwitchAccountRequest) (resp *api.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SwitchAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SwitchAccountEndpoint{SwitchAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.SwitchAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePermissionEndpoint struct {
	*api.UpdatePermissionRequest
	Result  *api.UpdatePermissionResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdatePermission(ctx context.Context, req *api.UpdatePermissionRequest) (resp *api.UpdatePermissionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdatePermission"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePermissionEndpoint{UpdatePermissionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePermission(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceSaleEndpoint struct {
	*api.UpdateReferenceSaleRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceSale(ctx context.Context, req *api.UpdateReferenceSaleRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceSale"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceSaleEndpoint{UpdateReferenceSaleRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceSale(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceUserEndpoint struct {
	*api.UpdateReferenceUserRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceUser(ctx context.Context, req *api.UpdateReferenceUserRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceUserEndpoint{UpdateReferenceUserRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceUser(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpgradeAccessTokenEndpoint struct {
	*api.UpgradeAccessTokenRequest
	Result  *api.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpgradeAccessToken(ctx context.Context, req *api.UpgradeAccessTokenRequest) (resp *api.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpgradeAccessToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpgradeAccessTokenEndpoint{UpgradeAccessTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpgradeAccessToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyEmailUsingTokenEndpoint struct {
	*api.VerifyEmailUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) VerifyEmailUsingToken(ctx context.Context, req *api.VerifyEmailUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyEmailUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyEmailUsingTokenEndpoint{VerifyEmailUsingTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyEmailUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyPhoneResetPasswordUsingTokenEndpoint struct {
	*api.VerifyPhoneResetPasswordUsingTokenRequest
	Result  *api.VerifyPhoneResetPasswordUsingTokenResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) VerifyPhoneResetPasswordUsingToken(ctx context.Context, req *api.VerifyPhoneResetPasswordUsingTokenRequest) (resp *api.VerifyPhoneResetPasswordUsingTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyPhoneResetPasswordUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VerifyPhoneResetPasswordUsingTokenEndpoint{VerifyPhoneResetPasswordUsingTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyPhoneResetPasswordUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyPhoneUsingTokenEndpoint struct {
	*api.VerifyPhoneUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) VerifyPhoneUsingToken(ctx context.Context, req *api.VerifyPhoneUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyPhoneUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VerifyPhoneUsingTokenEndpoint{VerifyPhoneUsingTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyPhoneUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapUserRelationshipService(s *UserRelationshipService) api.UserRelationshipService {
	return wrapUserRelationshipService{s: s}
}

type wrapUserRelationshipService struct {
	s *UserRelationshipService
}

type UserRelationshipAcceptInvitationEndpoint struct {
	*api.AcceptInvitationRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserRelationshipService) AcceptInvitation(ctx context.Context, req *api.AcceptInvitationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.UserRelationship/AcceptInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UserRelationshipAcceptInvitationEndpoint{AcceptInvitationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.AcceptInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UserRelationshipGetInvitationByTokenEndpoint struct {
	*api.GetInvitationByTokenRequest
	Result  *api.Invitation
	Context claims.EmptyClaim
}

func (s wrapUserRelationshipService) GetInvitationByToken(ctx context.Context, req *api.GetInvitationByTokenRequest) (resp *api.Invitation, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.UserRelationship/GetInvitationByToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &UserRelationshipGetInvitationByTokenEndpoint{GetInvitationByTokenRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInvitationByToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UserRelationshipGetInvitationsEndpoint struct {
	*api.GetInvitationsRequest
	Result  *api.InvitationsResponse
	Context claims.UserClaim
}

func (s wrapUserRelationshipService) GetInvitations(ctx context.Context, req *api.GetInvitationsRequest) (resp *api.InvitationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.UserRelationship/GetInvitations"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UserRelationshipGetInvitationsEndpoint{GetInvitationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetInvitations(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UserRelationshipLeaveAccountEndpoint struct {
	*api.UserRelationshipLeaveAccountRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserRelationshipService) LeaveAccount(ctx context.Context, req *api.UserRelationshipLeaveAccountRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.UserRelationship/LeaveAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UserRelationshipLeaveAccountEndpoint{UserRelationshipLeaveAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.LeaveAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UserRelationshipRejectInvitationEndpoint struct {
	*api.RejectInvitationRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserRelationshipService) RejectInvitation(ctx context.Context, req *api.RejectInvitationRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.UserRelationship/RejectInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UserRelationshipRejectInvitationEndpoint{RejectInvitationRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	ctx = bus.NewRootContext(ctx)
	err = s.s.RejectInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
