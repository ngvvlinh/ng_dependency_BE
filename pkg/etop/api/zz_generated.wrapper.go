// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package api

import (
	"context"
	"time"

	cm "etop.vn/backend/pb/common"
	api "etop.vn/backend/pb/etop"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	model "etop.vn/backend/pkg/etop/model"
)

func NewAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type GetPublicPartnerInfoEndpoint struct {
	*cm.IDRequest
	Result  *api.PublicAccountInfo
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartnerInfo(ctx context.Context, req *cm.IDRequest) (resp *api.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartnerInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnerInfoEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartnerInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetPublicPartnersEndpoint struct {
	*cm.IDsRequest
	Result  *api.PublicAccountsResponse
	Context claims.EmptyClaim
}

func (s wrapAccountService) GetPublicPartners(ctx context.Context, req *cm.IDsRequest) (resp *api.PublicAccountsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartners"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnersEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetPublicPartners(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateURLSlugEndpoint struct {
	*api.UpdateURLSlugRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAccountService) UpdateURLSlug(ctx context.Context, req *api.UpdateURLSlugRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/UpdateURLSlug"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateURLSlugEndpoint{UpdateURLSlugRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateURLSlug(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewAddressService(s *AddressService) api.AddressService {
	return wrapAddressService{s: s}
}

type wrapAddressService struct {
	s *AddressService
}

type CreateAddressEndpoint struct {
	*api.CreateAddressRequest
	Result  *api.Address
	Context claims.UserClaim
}

func (s wrapAddressService) CreateAddress(ctx context.Context, req *api.CreateAddressRequest) (resp *api.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/CreateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAddressEndpoint{CreateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAddressesEndpoint struct {
	*cm.Empty
	Result     *api.GetAddressResponse
	Context    claims.UserClaim
	CtxPartner *model.Partner
}

func (s wrapAddressService) GetAddresses(ctx context.Context, req *cm.Empty) (resp *api.GetAddressResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/GetAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAddressesEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapAddressService) RemoveAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/RemoveAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveAddressEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAddressEndpoint struct {
	*api.UpdateAddressRequest
	Result  *api.Address
	Context claims.UserClaim
}

func (s wrapAddressService) UpdateAddress(ctx context.Context, req *api.UpdateAddressRequest) (resp *api.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/UpdateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAddressEndpoint{UpdateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewBankService(s *BankService) api.BankService {
	return wrapBankService{s: s}
}

type wrapBankService struct {
	s *BankService
}

type GetBanksEndpoint struct {
	*cm.Empty
	Result  *api.GetBanksResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBanks(ctx context.Context, req *cm.Empty) (resp *api.GetBanksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBanks"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBanksEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBanks(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBranchesByBankProvinceEndpoint struct {
	*api.GetBranchesByBankProvinceResquest
	Result  *api.GetBranchesByBankProvinceResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetBranchesByBankProvince(ctx context.Context, req *api.GetBranchesByBankProvinceResquest) (resp *api.GetBranchesByBankProvinceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBranchesByBankProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBranchesByBankProvinceEndpoint{GetBranchesByBankProvinceResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetBranchesByBankProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesByBankEndpoint struct {
	*api.GetProvincesByBankResquest
	Result  *api.GetBankProvincesResponse
	Context claims.UserClaim
}

func (s wrapBankService) GetProvincesByBank(ctx context.Context, req *api.GetProvincesByBankResquest) (resp *api.GetBankProvincesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetProvincesByBank"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProvincesByBankEndpoint{GetProvincesByBankResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvincesByBank(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewLocationService(s *LocationService) api.LocationService {
	return wrapLocationService{s: s}
}

type wrapLocationService struct {
	s *LocationService
}

type GetDistrictsEndpoint struct {
	*cm.Empty
	Result  *api.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistricts(ctx context.Context, req *cm.Empty) (resp *api.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistricts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetDistrictsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistricts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetDistrictsByProvinceEndpoint struct {
	*api.GetDistrictsByProvinceRequest
	Result  *api.GetDistrictsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetDistrictsByProvince(ctx context.Context, req *api.GetDistrictsByProvinceRequest) (resp *api.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistrictsByProvince"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetDistrictsByProvinceEndpoint{GetDistrictsByProvinceRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetDistrictsByProvince(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProvincesEndpoint struct {
	*cm.Empty
	Result  *api.GetProvincesResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetProvinces(ctx context.Context, req *cm.Empty) (resp *api.GetProvincesResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetProvinces"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetProvincesEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProvinces(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsEndpoint struct {
	*cm.Empty
	Result  *api.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWards(ctx context.Context, req *cm.Empty) (resp *api.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWards"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetWardsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWards(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWardsByDistrictEndpoint struct {
	*api.GetWardsByDistrictRequest
	Result  *api.GetWardsResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) GetWardsByDistrict(ctx context.Context, req *api.GetWardsByDistrictRequest) (resp *api.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWardsByDistrict"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &GetWardsByDistrictEndpoint{GetWardsByDistrictRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWardsByDistrict(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ParseLocationEndpoint struct {
	*api.ParseLocationRequest
	Result  *api.ParseLocationResponse
	Context claims.EmptyClaim
}

func (s wrapLocationService) ParseLocation(ctx context.Context, req *api.ParseLocationRequest) (resp *api.ParseLocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/ParseLocation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ParseLocationEndpoint{ParseLocationRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = s.s.ParseLocation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewRelationshipService(s *RelationshipService) api.RelationshipService {
	return wrapRelationshipService{s: s}
}

type wrapRelationshipService struct {
	s *RelationshipService
}

type AnswerInvitationEndpoint struct {
	*api.AnswerInvitationRequest
	Result  *api.UserAccountInfo
	Context claims.UserClaim
}

func (s wrapRelationshipService) AnswerInvitation(ctx context.Context, req *api.AnswerInvitationRequest) (resp *api.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/AnswerInvitation"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AnswerInvitationEndpoint{AnswerInvitationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.AnswerInvitation(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetUsersInCurrentAccountsEndpoint struct {
	*api.GetUsersInCurrentAccountsRequest
	Result  *api.ProtectedUsersResponse
	Context claims.UserClaim
}

func (s wrapRelationshipService) GetUsersInCurrentAccounts(ctx context.Context, req *api.GetUsersInCurrentAccountsRequest) (resp *api.ProtectedUsersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/GetUsersInCurrentAccounts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetUsersInCurrentAccountsEndpoint{GetUsersInCurrentAccountsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetUsersInCurrentAccounts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type InviteUserToAccountEndpoint struct {
	*api.InviteUserToAccountRequest
	Result  *api.UserAccountInfo
	Context claims.UserClaim
}

func (s wrapRelationshipService) InviteUserToAccount(ctx context.Context, req *api.InviteUserToAccountRequest) (resp *api.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/InviteUserToAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &InviteUserToAccountEndpoint{InviteUserToAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.InviteUserToAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LeaveAccountEndpoint struct {
	*api.LeaveAccountRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapRelationshipService) LeaveAccount(ctx context.Context, req *api.LeaveAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/LeaveAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LeaveAccountEndpoint{LeaveAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.LeaveAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveUserFromCurrentAccountEndpoint struct {
	*api.RemoveUserFromCurrentAccountRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapRelationshipService) RemoveUserFromCurrentAccount(ctx context.Context, req *api.RemoveUserFromCurrentAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/RemoveUserFromCurrentAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveUserFromCurrentAccountEndpoint{RemoveUserFromCurrentAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveUserFromCurrentAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func NewUserService(s *UserService) api.UserService {
	return wrapUserService{s: s}
}

type wrapUserService struct {
	s *UserService
}

type ChangePasswordEndpoint struct {
	*api.ChangePasswordRequest
	Result  *cm.Empty
	Context claims.UserClaim
}

func (s wrapUserService) ChangePassword(ctx context.Context, req *api.ChangePasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ChangePasswordEndpoint{ChangePasswordRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ChangePasswordUsingTokenEndpoint struct {
	*api.ChangePasswordUsingTokenRequest
	Result  *cm.Empty
	Context claims.EmptyClaim
}

func (s wrapUserService) ChangePasswordUsingToken(ctx context.Context, req *api.ChangePasswordUsingTokenRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePasswordUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &ChangePasswordUsingTokenEndpoint{ChangePasswordUsingTokenRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ChangePasswordUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LoginEndpoint struct {
	*api.LoginRequest
	Result  *api.LoginResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Login(ctx context.Context, req *api.LoginRequest) (resp *api.LoginResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Login"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &LoginEndpoint{LoginRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Login(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterEndpoint struct {
	*api.CreateUserRequest
	Result  *api.RegisterResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) Register(ctx context.Context, req *api.CreateUserRequest) (resp *api.RegisterResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Register"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &RegisterEndpoint{CreateUserRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.Register(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ResetPasswordEndpoint struct {
	*api.ResetPasswordRequest
	Result  *cm.MessageResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) ResetPassword(ctx context.Context, req *api.ResetPasswordRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &ResetPasswordEndpoint{ResetPasswordRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.ResetPassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendEmailVerificationEndpoint struct {
	*api.SendEmailVerificationRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendEmailVerification(ctx context.Context, req *api.SendEmailVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendEmailVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendEmailVerificationEndpoint{SendEmailVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendEmailVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendPhoneVerificationEndpoint struct {
	*api.SendPhoneVerificationRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendPhoneVerification(ctx context.Context, req *api.SendPhoneVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendPhoneVerification"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendPhoneVerificationEndpoint{SendPhoneVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendPhoneVerification(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SendSTokenEmailEndpoint struct {
	*api.SendSTokenEmailRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) SendSTokenEmail(ctx context.Context, req *api.SendSTokenEmailRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendSTokenEmail"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendSTokenEmailEndpoint{SendSTokenEmailRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SendSTokenEmail(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SessionInfoEndpoint struct {
	*cm.Empty
	Result  *api.LoginResponse
	Context claims.UserClaim
}

func (s wrapUserService) SessionInfo(ctx context.Context, req *cm.Empty) (resp *api.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SessionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SessionInfoEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SessionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SwitchAccountEndpoint struct {
	*api.SwitchAccountRequest
	Result  *api.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) SwitchAccount(ctx context.Context, req *api.SwitchAccountRequest) (resp *api.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SwitchAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SwitchAccountEndpoint{SwitchAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.SwitchAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdatePermissionEndpoint struct {
	*api.UpdatePermissionRequest
	Result  *api.UpdatePermissionResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdatePermission(ctx context.Context, req *api.UpdatePermissionRequest) (resp *api.UpdatePermissionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdatePermission"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePermissionEndpoint{UpdatePermissionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdatePermission(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceSaleEndpoint struct {
	*api.UpdateReferenceSaleRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceSale(ctx context.Context, req *api.UpdateReferenceSaleRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceSale"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceSaleEndpoint{UpdateReferenceSaleRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceSale(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateReferenceUserEndpoint struct {
	*api.UpdateReferenceUserRequest
	Result  *cm.UpdatedResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpdateReferenceUser(ctx context.Context, req *api.UpdateReferenceUserRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdateReferenceUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferenceUserEndpoint{UpdateReferenceUserRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateReferenceUser(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpgradeAccessTokenEndpoint struct {
	*api.UpgradeAccessTokenRequest
	Result  *api.AccessTokenResponse
	Context claims.UserClaim
}

func (s wrapUserService) UpgradeAccessToken(ctx context.Context, req *api.UpgradeAccessTokenRequest) (resp *api.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpgradeAccessToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpgradeAccessTokenEndpoint{UpgradeAccessTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpgradeAccessToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyEmailUsingTokenEndpoint struct {
	*api.VerifyEmailUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) VerifyEmailUsingToken(ctx context.Context, req *api.VerifyEmailUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyEmailUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyEmailUsingTokenEndpoint{VerifyEmailUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyEmailUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VerifyPhoneUsingTokenEndpoint struct {
	*api.VerifyPhoneUsingTokenRequest
	Result  *cm.MessageResponse
	Context claims.UserClaim
}

func (s wrapUserService) VerifyPhoneUsingToken(ctx context.Context, req *api.VerifyPhoneUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyPhoneUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyPhoneUsingTokenEndpoint{VerifyPhoneUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VerifyPhoneUsingToken(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
