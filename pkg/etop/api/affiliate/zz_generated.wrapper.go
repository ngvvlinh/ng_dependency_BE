// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package affiliate

import (
	"context"
	"time"

	api "etop.vn/api/top/int/affiliate"
	etop "etop.vn/api/top/int/etop"
	cm "etop.vn/api/top/types/common"
	common "etop.vn/backend/pkg/common"
	cmwrapper "etop.vn/backend/pkg/common/apifw/wrapper"
	bus "etop.vn/backend/pkg/common/bus"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type DeleteAffiliateEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.AffiliateClaim
}

func (s wrapAccountService) DeleteAffiliate(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Account/DeleteAffiliate"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteAffiliateEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Affiliate = session.Affiliate
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteAffiliate(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RegisterAffiliateEndpoint struct {
	*api.RegisterAffiliateRequest
	Result  *etop.Affiliate
	Context claims.UserClaim
}

func (s wrapAccountService) RegisterAffiliate(ctx context.Context, req *api.RegisterAffiliateRequest) (resp *etop.Affiliate, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Account/RegisterAffiliate"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth: true,
		RequireUser: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterAffiliateEndpoint{RegisterAffiliateRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.RegisterAffiliate(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAffiliateEndpoint struct {
	*api.UpdateAffiliateRequest
	Result  *etop.Affiliate
	Context claims.AffiliateClaim
}

func (s wrapAccountService) UpdateAffiliate(ctx context.Context, req *api.UpdateAffiliateRequest) (resp *etop.Affiliate, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Account/UpdateAffiliate"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAffiliateEndpoint{UpdateAffiliateRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Affiliate = session.Affiliate
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAffiliate(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAffiliateBankAccountEndpoint struct {
	*api.UpdateAffiliateBankAccountRequest
	Result  *etop.Affiliate
	Context claims.AffiliateClaim
}

func (s wrapAccountService) UpdateAffiliateBankAccount(ctx context.Context, req *api.UpdateAffiliateBankAccountRequest) (resp *etop.Affiliate, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Account/UpdateAffiliateBankAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAffiliateBankAccountEndpoint{UpdateAffiliateBankAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Affiliate = session.Affiliate
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAffiliateBankAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
