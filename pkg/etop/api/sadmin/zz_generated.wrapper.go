// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package admin

import (
	"context"
	"time"

	etop "o.o/api/top/int/etop"
	api "o.o/api/top/int/sadmin"
	cm "o.o/api/top/types/common"
	common "o.o/backend/pkg/common"
	cmwrapper "o.o/backend/pkg/common/apifw/wrapper"
	bus "o.o/backend/pkg/common/bus"
	claims "o.o/backend/pkg/etop/authorize/claims"
	middleware "o.o/backend/pkg/etop/authorize/middleware"
)

func WrapMiscService(s func() *MiscService) func() api.MiscService {
	return func() api.MiscService { return wrapMiscService{s: s} }
}

type wrapMiscService struct {
	s func() *MiscService
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = s.s().VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapUserService(s func() *UserService) func() api.UserService {
	return func() api.UserService { return wrapUserService{s: s} }
}

type wrapUserService struct {
	s func() *UserService
}

type CreateUserEndpoint struct {
	*api.SAdminCreateUserRequest
	Result  *etop.RegisterResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) CreateUser(ctx context.Context, req *api.SAdminCreateUserRequest) (resp *etop.RegisterResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/CreateUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateUserEndpoint{SAdminCreateUserRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateUser(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type LoginAsAccountEndpoint struct {
	*api.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context claims.EmptyClaim
}

func (s wrapUserService) LoginAsAccount(ctx context.Context, req *api.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/LoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LoginAsAccountEndpoint{LoginAsAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = s.s().LoginAsAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ResetPasswordEndpoint struct {
	*api.SAdminResetPasswordRequest
	Result  *cm.Empty
	Context claims.EmptyClaim
}

func (s wrapUserService) ResetPassword(ctx context.Context, req *api.SAdminResetPasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ResetPasswordEndpoint{SAdminResetPasswordRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = s.s().ResetPassword(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
