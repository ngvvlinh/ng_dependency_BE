// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package admin

import (
	"context"
	"time"

	cm "etop.vn/api/pb/common"
	etop "etop.vn/api/pb/etop"
	admin "etop.vn/api/pb/etop/admin"
	order "etop.vn/api/pb/etop/order"
	api "etop.vn/api/root/int/admin"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type CreatePartnerEndpoint struct {
	*admin.CreatePartnerRequest
	Result  *etop.Partner
	Context claims.AdminClaim
}

func (s wrapAccountService) CreatePartner(ctx context.Context, req *admin.CreatePartnerRequest) (resp *etop.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/CreatePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePartnerEndpoint{CreatePartnerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreatePartner(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GenerateAPIKeyEndpoint struct {
	*admin.GenerateAPIKeyRequest
	Result  *admin.GenerateAPIKeyResponse
	Context claims.AdminClaim
}

func (s wrapAccountService) GenerateAPIKey(ctx context.Context, req *admin.GenerateAPIKeyRequest) (resp *admin.GenerateAPIKeyResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/GenerateAPIKey"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GenerateAPIKeyEndpoint{GenerateAPIKeyRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GenerateAPIKey(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCreditService(s *CreditService) api.CreditService {
	return wrapCreditService{s: s}
}

type wrapCreditService struct {
	s *CreditService
}

type ConfirmCreditEndpoint struct {
	*admin.ConfirmCreditRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) ConfirmCredit(ctx context.Context, req *admin.ConfirmCreditRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/ConfirmCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmCreditEndpoint{ConfirmCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCreditEndpoint struct {
	*admin.CreateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) CreateCredit(ctx context.Context, req *admin.CreateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/CreateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCreditEndpoint{CreateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCreditEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) DeleteCredit(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/DeleteCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCreditEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditEndpoint struct {
	*admin.GetCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredit(ctx context.Context, req *admin.GetCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditEndpoint{GetCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditsEndpoint struct {
	*admin.GetCreditsRequest
	Result  *etop.CreditsResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredits(ctx context.Context, req *admin.GetCreditsRequest) (resp *etop.CreditsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredits"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditsEndpoint{GetCreditsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCredits(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCreditEndpoint struct {
	*admin.UpdateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) UpdateCredit(ctx context.Context, req *admin.UpdateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/UpdateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCreditEndpoint{UpdateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s *FulfillmentService) api.FulfillmentService {
	return wrapFulfillmentService{s: s}
}

type wrapFulfillmentService struct {
	s *FulfillmentService
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.Fulfillment
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsEndpoint struct {
	*admin.GetFulfillmentsRequest
	Result  *order.FulfillmentsResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillments(ctx context.Context, req *admin.GetFulfillmentsRequest) (resp *order.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentEndpoint struct {
	*admin.UpdateFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillment(ctx context.Context, req *admin.UpdateFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentEndpoint{UpdateFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type AdminLoginAsAccountEndpoint struct {
	*admin.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context claims.AdminClaim
}

func (s wrapMiscService) AdminLoginAsAccount(ctx context.Context, req *admin.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/AdminLoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdminLoginAsAccountEndpoint{LoginAsAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.AdminLoginAsAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "admin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMoneyTransactionService(s *MoneyTransactionService) api.MoneyTransactionService {
	return wrapMoneyTransactionService{s: s}
}

type wrapMoneyTransactionService struct {
	s *MoneyTransactionService
}

type ConfirmMoneyTransactionEndpoint struct {
	*admin.ConfirmMoneyTransactionRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransaction(ctx context.Context, req *admin.ConfirmMoneyTransactionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionEndpoint{ConfirmMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingEtopEndpoint struct {
	*admin.ConfirmMoneyTransactionShippingEtopRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingEtop(ctx context.Context, req *admin.ConfirmMoneyTransactionShippingEtopRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingEtopEndpoint{ConfirmMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingExternalsEndpoint struct {
	*cm.IDsRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingExternals(ctx context.Context, req *cm.IDsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDsRequest
	Result  *order.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) CreateMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDsRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateMoneyTransactionShippingEtopEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopsEndpoint struct {
	*admin.GetMoneyTransactionShippingEtopsRequest
	Result  *order.MoneyTransactionShippingEtopsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtops(ctx context.Context, req *admin.GetMoneyTransactionShippingEtopsRequest) (resp *order.MoneyTransactionShippingEtopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopsEndpoint{GetMoneyTransactionShippingEtopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingEtops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalsEndpoint struct {
	*admin.GetMoneyTransactionShippingExternalsRequest
	Result  *order.MoneyTransactionShippingExternalsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternals(ctx context.Context, req *admin.GetMoneyTransactionShippingExternalsRequest) (resp *order.MoneyTransactionShippingExternalsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalsEndpoint{GetMoneyTransactionShippingExternalsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionsEndpoint struct {
	*admin.GetMoneyTransactionsRequest
	Result  *order.MoneyTransactionsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *admin.GetMoneyTransactionsRequest) (resp *order.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveMoneyTransactionShippingExternalLinesEndpoint struct {
	*admin.RemoveMoneyTransactionShippingExternalLinesRequest
	Result  *order.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, req *admin.RemoveMoneyTransactionShippingExternalLinesRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveMoneyTransactionShippingExternalLinesEndpoint{RemoveMoneyTransactionShippingExternalLinesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveMoneyTransactionShippingExternalLines(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionEndpoint struct {
	*admin.UpdateMoneyTransactionRequest
	Result  *order.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransaction(ctx context.Context, req *admin.UpdateMoneyTransactionRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionEndpoint{UpdateMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingEtopEndpoint struct {
	*admin.UpdateMoneyTransactionShippingEtopRequest
	Result  *order.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingEtop(ctx context.Context, req *admin.UpdateMoneyTransactionShippingEtopRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingEtopEndpoint{UpdateMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingExternalEndpoint struct {
	*admin.UpdateMoneyTransactionShippingExternalRequest
	Result  *order.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingExternal(ctx context.Context, req *admin.UpdateMoneyTransactionShippingExternalRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingExternalEndpoint{UpdateMoneyTransactionShippingExternalRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapNotificationService(s *NotificationService) api.NotificationService {
	return wrapNotificationService{s: s}
}

type wrapNotificationService struct {
	s *NotificationService
}

type CreateNotificationsEndpoint struct {
	*admin.CreateNotificationsRequest
	Result  *admin.CreateNotificationsResponse
	Context claims.AdminClaim
}

func (s wrapNotificationService) CreateNotifications(ctx context.Context, req *admin.CreateNotificationsRequest) (resp *admin.CreateNotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Notification/CreateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateNotificationsEndpoint{CreateNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s *OrderService) api.OrderService {
	return wrapOrderService{s: s}
}

type wrapOrderService struct {
	s *OrderService
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result  *order.Order
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersEndpoint struct {
	*admin.GetOrdersRequest
	Result  *order.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrders(ctx context.Context, req *admin.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *order.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShopService(s *ShopService) api.ShopService {
	return wrapShopService{s: s}
}

type wrapShopService struct {
	s *ShopService
}

type GetShopEndpoint struct {
	*cm.IDRequest
	Result  *etop.Shop
	Context claims.AdminClaim
}

func (s wrapShopService) GetShop(ctx context.Context, req *cm.IDRequest) (resp *etop.Shop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopsEndpoint struct {
	*admin.GetShopsRequest
	Result  *admin.GetShopsResponse
	Context claims.AdminClaim
}

func (s wrapShopService) GetShops(ctx context.Context, req *admin.GetShopsRequest) (resp *admin.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsEndpoint{GetShopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
