// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package admin

import (
	"context"
	"time"

	api "etop.vn/api/top/int/admin"
	etop "etop.vn/api/top/int/etop"
	inttypes "etop.vn/api/top/int/types"
	cm "etop.vn/api/top/types/common"
	common "etop.vn/backend/pkg/common"
	cmwrapper "etop.vn/backend/pkg/common/apifw/wrapper"
	bus "etop.vn/backend/pkg/common/bus"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s *AccountService) api.AccountService {
	return wrapAccountService{s: s}
}

type wrapAccountService struct {
	s *AccountService
}

type CreatePartnerEndpoint struct {
	*api.CreatePartnerRequest
	Result  *etop.Partner
	Context claims.AdminClaim
}

func (s wrapAccountService) CreatePartner(ctx context.Context, req *api.CreatePartnerRequest) (resp *etop.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/CreatePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePartnerEndpoint{CreatePartnerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreatePartner(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GenerateAPIKeyEndpoint struct {
	*api.GenerateAPIKeyRequest
	Result  *api.GenerateAPIKeyResponse
	Context claims.AdminClaim
}

func (s wrapAccountService) GenerateAPIKey(ctx context.Context, req *api.GenerateAPIKeyRequest) (resp *api.GenerateAPIKeyResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/GenerateAPIKey"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GenerateAPIKeyEndpoint{GenerateAPIKeyRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GenerateAPIKey(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapConnectionService(s *ConnectionService) api.ConnectionService {
	return wrapConnectionService{s: s}
}

type wrapConnectionService struct {
	s *ConnectionService
}

type ConfirmConnectionEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) ConfirmConnection(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/ConfirmConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmConnectionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateTopshipConnectionEndpoint struct {
	*inttypes.CreateTopshipConnectionRequest
	Result  *inttypes.Connection
	Context claims.AdminClaim
}

func (s wrapConnectionService) CreateTopshipConnection(ctx context.Context, req *inttypes.CreateTopshipConnectionRequest) (resp *inttypes.Connection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/CreateTopshipConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateTopshipConnectionEndpoint{CreateTopshipConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateTopshipConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DisableConnectionEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) DisableConnection(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/DisableConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DisableConnectionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DisableConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetConnectionsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetConnectionsResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) GetConnections(ctx context.Context, req *cm.Empty) (resp *inttypes.GetConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/GetConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetConnectionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCreditService(s *CreditService) api.CreditService {
	return wrapCreditService{s: s}
}

type wrapCreditService struct {
	s *CreditService
}

type ConfirmCreditEndpoint struct {
	*api.ConfirmCreditRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) ConfirmCredit(ctx context.Context, req *api.ConfirmCreditRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/ConfirmCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmCreditEndpoint{ConfirmCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCreditEndpoint struct {
	*api.CreateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) CreateCredit(ctx context.Context, req *api.CreateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/CreateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCreditEndpoint{CreateCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCreditEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) DeleteCredit(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/DeleteCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCreditEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditEndpoint struct {
	*api.GetCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredit(ctx context.Context, req *api.GetCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditEndpoint{GetCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditsEndpoint struct {
	*api.GetCreditsRequest
	Result  *etop.CreditsResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredits(ctx context.Context, req *api.GetCreditsRequest) (resp *etop.CreditsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredits"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditsEndpoint{GetCreditsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCredits(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCreditEndpoint struct {
	*api.UpdateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) UpdateCredit(ctx context.Context, req *api.UpdateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/UpdateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCreditEndpoint{UpdateCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s *FulfillmentService) api.FulfillmentService {
	return wrapFulfillmentService{s: s}
}

type wrapFulfillmentService struct {
	s *FulfillmentService
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.Fulfillment
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsEndpoint struct {
	*api.GetFulfillmentsRequest
	Result  *inttypes.FulfillmentsResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillments(ctx context.Context, req *api.GetFulfillmentsRequest) (resp *inttypes.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentEndpoint struct {
	*api.UpdateFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillment(ctx context.Context, req *api.UpdateFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentEndpoint{UpdateFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentShippingFeeEndpoint struct {
	*api.UpdateFulfillmentShippingFeeRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentShippingFee(ctx context.Context, req *api.UpdateFulfillmentShippingFeeRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillmentShippingFee"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentShippingFeeEndpoint{UpdateFulfillmentShippingFeeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillmentShippingFee(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentShippingStateEndpoint struct {
	*api.UpdateFulfillmentShippingStateRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentShippingState(ctx context.Context, req *api.UpdateFulfillmentShippingStateRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillmentShippingState"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentShippingStateEndpoint{UpdateFulfillmentShippingStateRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateFulfillmentShippingState(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type AdminLoginAsAccountEndpoint struct {
	*api.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context claims.AdminClaim
}

func (s wrapMiscService) AdminLoginAsAccount(ctx context.Context, req *api.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/AdminLoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdminLoginAsAccountEndpoint{LoginAsAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.AdminLoginAsAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMoneyTransactionService(s *MoneyTransactionService) api.MoneyTransactionService {
	return wrapMoneyTransactionService{s: s}
}

type wrapMoneyTransactionService struct {
	s *MoneyTransactionService
}

type ConfirmMoneyTransactionEndpoint struct {
	*api.ConfirmMoneyTransactionRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransaction(ctx context.Context, req *api.ConfirmMoneyTransactionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionEndpoint{ConfirmMoneyTransactionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingEtopEndpoint struct {
	*api.ConfirmMoneyTransactionShippingEtopRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingEtop(ctx context.Context, req *api.ConfirmMoneyTransactionShippingEtopRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingEtopEndpoint{ConfirmMoneyTransactionShippingEtopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingExternalsEndpoint struct {
	*cm.IDsRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingExternals(ctx context.Context, req *cm.IDsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDsRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) CreateMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDsRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateMoneyTransactionShippingEtopEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopsEndpoint struct {
	*api.GetMoneyTransactionShippingEtopsRequest
	Result  *inttypes.MoneyTransactionShippingEtopsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtops(ctx context.Context, req *api.GetMoneyTransactionShippingEtopsRequest) (resp *inttypes.MoneyTransactionShippingEtopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopsEndpoint{GetMoneyTransactionShippingEtopsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingEtops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalsEndpoint struct {
	*api.GetMoneyTransactionShippingExternalsRequest
	Result  *inttypes.MoneyTransactionShippingExternalsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternals(ctx context.Context, req *api.GetMoneyTransactionShippingExternalsRequest) (resp *inttypes.MoneyTransactionShippingExternalsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalsEndpoint{GetMoneyTransactionShippingExternalsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionsEndpoint struct {
	*api.GetMoneyTransactionsRequest
	Result  *inttypes.MoneyTransactionsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *api.GetMoneyTransactionsRequest) (resp *inttypes.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetMoneyTransactions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveMoneyTransactionShippingExternalLinesEndpoint struct {
	*api.RemoveMoneyTransactionShippingExternalLinesRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, req *api.RemoveMoneyTransactionShippingExternalLinesRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveMoneyTransactionShippingExternalLinesEndpoint{RemoveMoneyTransactionShippingExternalLinesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveMoneyTransactionShippingExternalLines(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionEndpoint struct {
	*api.UpdateMoneyTransactionRequest
	Result  *inttypes.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransaction(ctx context.Context, req *api.UpdateMoneyTransactionRequest) (resp *inttypes.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionEndpoint{UpdateMoneyTransactionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingEtopEndpoint struct {
	*api.UpdateMoneyTransactionShippingEtopRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingEtop(ctx context.Context, req *api.UpdateMoneyTransactionShippingEtopRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingEtopEndpoint{UpdateMoneyTransactionShippingEtopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingExternalEndpoint struct {
	*api.UpdateMoneyTransactionShippingExternalRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingExternal(ctx context.Context, req *api.UpdateMoneyTransactionShippingExternalRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingExternalEndpoint{UpdateMoneyTransactionShippingExternalRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapNotificationService(s *NotificationService) api.NotificationService {
	return wrapNotificationService{s: s}
}

type wrapNotificationService struct {
	s *NotificationService
}

type CreateNotificationsEndpoint struct {
	*api.CreateNotificationsRequest
	Result  *api.CreateNotificationsResponse
	Context claims.AdminClaim
}

func (s wrapNotificationService) CreateNotifications(ctx context.Context, req *api.CreateNotificationsRequest) (resp *api.CreateNotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Notification/CreateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateNotificationsEndpoint{CreateNotificationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s *OrderService) api.OrderService {
	return wrapOrderService{s: s}
}

type wrapOrderService struct {
	s *OrderService
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.Order
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersEndpoint struct {
	*api.GetOrdersRequest
	Result  *inttypes.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrders(ctx context.Context, req *api.GetOrdersRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *inttypes.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShopService(s *ShopService) api.ShopService {
	return wrapShopService{s: s}
}

type wrapShopService struct {
	s *ShopService
}

type GetShopEndpoint struct {
	*cm.IDRequest
	Result  *etop.Shop
	Context claims.AdminClaim
}

func (s wrapShopService) GetShop(ctx context.Context, req *cm.IDRequest) (resp *etop.Shop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopsEndpoint struct {
	*api.GetShopsRequest
	Result  *api.GetShopsResponse
	Context claims.AdminClaim
}

func (s wrapShopService) GetShops(ctx context.Context, req *api.GetShopsRequest) (resp *api.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsEndpoint{GetShopsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
