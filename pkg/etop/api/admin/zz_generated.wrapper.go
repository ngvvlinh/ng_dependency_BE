// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package admin

import (
	"context"
	"time"

	api "o.o/api/top/int/admin"
	etop "o.o/api/top/int/etop"
	inttypes "o.o/api/top/int/types"
	cm "o.o/api/top/types/common"
	common "o.o/backend/pkg/common"
	cmwrapper "o.o/backend/pkg/common/apifw/wrapper"
	bus "o.o/backend/pkg/common/bus"
	claims "o.o/backend/pkg/etop/authorize/claims"
	middleware "o.o/backend/pkg/etop/authorize/middleware"
)

func WrapAccountService(s func() *AccountService) func() api.AccountService {
	return func() api.AccountService { return wrapAccountService{s: s} }
}

type wrapAccountService struct {
	s func() *AccountService
}

type CreatePartnerEndpoint struct {
	*api.CreatePartnerRequest
	Result  *etop.Partner
	Context claims.AdminClaim
}

func (s wrapAccountService) CreatePartner(ctx context.Context, req *api.CreatePartnerRequest) (resp *etop.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/CreatePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePartnerEndpoint{CreatePartnerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreatePartner(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GenerateAPIKeyEndpoint struct {
	*api.GenerateAPIKeyRequest
	Result  *api.GenerateAPIKeyResponse
	Context claims.AdminClaim
}

func (s wrapAccountService) GenerateAPIKey(ctx context.Context, req *api.GenerateAPIKeyRequest) (resp *api.GenerateAPIKeyResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/GenerateAPIKey"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GenerateAPIKeyEndpoint{GenerateAPIKeyRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GenerateAPIKey(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapConnectionService(s func() *ConnectionService) func() api.ConnectionService {
	return func() api.ConnectionService { return wrapConnectionService{s: s} }
}

type wrapConnectionService struct {
	s func() *ConnectionService
}

type ConfirmConnectionEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) ConfirmConnection(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/ConfirmConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmConnectionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ConfirmConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateBuiltinConnectionEndpoint struct {
	*inttypes.CreateBuiltinConnectionRequest
	Result  *inttypes.Connection
	Context claims.AdminClaim
}

func (s wrapConnectionService) CreateBuiltinConnection(ctx context.Context, req *inttypes.CreateBuiltinConnectionRequest) (resp *inttypes.Connection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/CreateBuiltinConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateBuiltinConnectionEndpoint{CreateBuiltinConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateBuiltinConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DisableConnectionEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) DisableConnection(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/DisableConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DisableConnectionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DisableConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetBuiltinShopConnectionsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetShopConnectionsResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) GetBuiltinShopConnections(ctx context.Context, req *cm.Empty) (resp *inttypes.GetShopConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/GetBuiltinShopConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBuiltinShopConnectionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetBuiltinShopConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetConnectionServicesEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.GetConnectionServicesResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) GetConnectionServices(ctx context.Context, req *cm.IDRequest) (resp *inttypes.GetConnectionServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/GetConnectionServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetConnectionServicesEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetConnectionServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetConnectionsEndpoint struct {
	*inttypes.GetConnectionsRequest
	Result  *inttypes.GetConnectionsResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) GetConnections(ctx context.Context, req *inttypes.GetConnectionsRequest) (resp *inttypes.GetConnectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/GetConnections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetConnectionsEndpoint{GetConnectionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetConnections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateBuiltinShopConnectionEndpoint struct {
	*inttypes.UpdateShopConnectionRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapConnectionService) UpdateBuiltinShopConnection(ctx context.Context, req *inttypes.UpdateShopConnectionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Connection/UpdateBuiltinShopConnection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateBuiltinShopConnectionEndpoint{UpdateShopConnectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateBuiltinShopConnection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCreditService(s func() *CreditService) func() api.CreditService {
	return func() api.CreditService { return wrapCreditService{s: s} }
}

type wrapCreditService struct {
	s func() *CreditService
}

type ConfirmCreditEndpoint struct {
	*api.ConfirmCreditRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) ConfirmCredit(ctx context.Context, req *api.ConfirmCreditRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/ConfirmCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmCreditEndpoint{ConfirmCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ConfirmCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCreditEndpoint struct {
	*api.CreateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) CreateCredit(ctx context.Context, req *api.CreateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/CreateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCreditEndpoint{CreateCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCreditEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) DeleteCredit(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/DeleteCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCreditEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditEndpoint struct {
	*api.GetCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredit(ctx context.Context, req *api.GetCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditEndpoint{GetCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCreditsEndpoint struct {
	*api.GetCreditsRequest
	Result  *etop.CreditsResponse
	Context claims.AdminClaim
}

func (s wrapCreditService) GetCredits(ctx context.Context, req *api.GetCreditsRequest) (resp *etop.CreditsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredits"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditsEndpoint{GetCreditsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetCredits(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCreditEndpoint struct {
	*api.UpdateCreditRequest
	Result  *etop.Credit
	Context claims.AdminClaim
}

func (s wrapCreditService) UpdateCredit(ctx context.Context, req *api.UpdateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/UpdateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCreditEndpoint{UpdateCreditRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateCredit(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s func() *FulfillmentService) func() api.FulfillmentService {
	return func() api.FulfillmentService { return wrapFulfillmentService{s: s} }
}

type wrapFulfillmentService struct {
	s func() *FulfillmentService
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.Fulfillment
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentsEndpoint struct {
	*api.GetFulfillmentsRequest
	Result  *inttypes.FulfillmentsResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) GetFulfillments(ctx context.Context, req *api.GetFulfillmentsRequest) (resp *inttypes.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentEndpoint struct {
	*api.UpdateFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillment(ctx context.Context, req *api.UpdateFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentEndpoint{UpdateFulfillmentRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentShippingFeeEndpoint struct {
	*api.UpdateFulfillmentShippingFeeRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentShippingFee(ctx context.Context, req *api.UpdateFulfillmentShippingFeeRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillmentShippingFee"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentShippingFeeEndpoint{UpdateFulfillmentShippingFeeRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateFulfillmentShippingFee(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateFulfillmentShippingStateEndpoint struct {
	*api.UpdateFulfillmentShippingStateRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapFulfillmentService) UpdateFulfillmentShippingState(ctx context.Context, req *api.UpdateFulfillmentShippingStateRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillmentShippingState"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentShippingStateEndpoint{UpdateFulfillmentShippingStateRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateFulfillmentShippingState(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapLocationService(s func() *LocationService) func() api.LocationService {
	return func() api.LocationService { return wrapLocationService{s: s} }
}

type wrapLocationService struct {
	s func() *LocationService
}

type CreateCustomRegionEndpoint struct {
	*api.CreateCustomRegionRequest
	Result  *api.CustomRegion
	Context claims.AdminClaim
}

func (s wrapLocationService) CreateCustomRegion(ctx context.Context, req *api.CreateCustomRegionRequest) (resp *api.CustomRegion, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Location/CreateCustomRegion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomRegionEndpoint{CreateCustomRegionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateCustomRegion(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomRegionEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapLocationService) DeleteCustomRegion(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Location/DeleteCustomRegion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomRegionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteCustomRegion(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomRegionEndpoint struct {
	*cm.IDRequest
	Result  *api.CustomRegion
	Context claims.AdminClaim
}

func (s wrapLocationService) GetCustomRegion(ctx context.Context, req *cm.IDRequest) (resp *api.CustomRegion, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Location/GetCustomRegion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomRegionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetCustomRegion(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomRegionsEndpoint struct {
	*cm.Empty
	Result  *api.GetCustomRegionsResponse
	Context claims.AdminClaim
}

func (s wrapLocationService) GetCustomRegions(ctx context.Context, req *cm.Empty) (resp *api.GetCustomRegionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Location/GetCustomRegions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomRegionsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetCustomRegions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomRegionEndpoint struct {
	*api.CustomRegion
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapLocationService) UpdateCustomRegion(ctx context.Context, req *api.CustomRegion) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Location/UpdateCustomRegion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomRegionEndpoint{CustomRegion: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateCustomRegion(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s func() *MiscService) func() api.MiscService {
	return func() api.MiscService { return wrapMiscService{s: s} }
}

type wrapMiscService struct {
	s func() *MiscService
}

type AdminLoginAsAccountEndpoint struct {
	*api.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context claims.AdminClaim
}

func (s wrapMiscService) AdminLoginAsAccount(ctx context.Context, req *api.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/AdminLoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdminLoginAsAccountEndpoint{LoginAsAccountRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().AdminLoginAsAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		// ignore invalid authentication token
		if common.ErrorCode(err) != common.Unauthenticated {
			return nil, err
		}
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s().VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMoneyTransactionService(s func() *MoneyTransactionService) func() api.MoneyTransactionService {
	return func() api.MoneyTransactionService { return wrapMoneyTransactionService{s: s} }
}

type wrapMoneyTransactionService struct {
	s func() *MoneyTransactionService
}

type ConfirmMoneyTransactionEndpoint struct {
	*api.ConfirmMoneyTransactionRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransaction(ctx context.Context, req *api.ConfirmMoneyTransactionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionEndpoint{ConfirmMoneyTransactionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ConfirmMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingEtopEndpoint struct {
	*api.ConfirmMoneyTransactionShippingEtopRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingEtop(ctx context.Context, req *api.ConfirmMoneyTransactionShippingEtopRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingEtopEndpoint{ConfirmMoneyTransactionShippingEtopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ConfirmMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ConfirmMoneyTransactionShippingExternalsEndpoint struct {
	*cm.IDsRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) ConfirmMoneyTransactionShippingExternals(ctx context.Context, req *cm.IDsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ConfirmMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDsRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) CreateMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDsRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateMoneyTransactionShippingEtopEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) DeleteMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingEtopsEndpoint struct {
	*api.GetMoneyTransactionShippingEtopsRequest
	Result  *inttypes.MoneyTransactionShippingEtopsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingEtops(ctx context.Context, req *api.GetMoneyTransactionShippingEtopsRequest) (resp *inttypes.MoneyTransactionShippingEtopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopsEndpoint{GetMoneyTransactionShippingEtopsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransactionShippingEtops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionShippingExternalsEndpoint struct {
	*api.GetMoneyTransactionShippingExternalsRequest
	Result  *inttypes.MoneyTransactionShippingExternalsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactionShippingExternals(ctx context.Context, req *api.GetMoneyTransactionShippingExternalsRequest) (resp *inttypes.MoneyTransactionShippingExternalsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalsEndpoint{GetMoneyTransactionShippingExternalsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransactionShippingExternals(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetMoneyTransactionsEndpoint struct {
	*api.GetMoneyTransactionsRequest
	Result  *inttypes.MoneyTransactionsResponse
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *api.GetMoneyTransactionsRequest) (resp *inttypes.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetMoneyTransactions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveMoneyTransactionShippingExternalLinesEndpoint struct {
	*api.RemoveMoneyTransactionShippingExternalLinesRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, req *api.RemoveMoneyTransactionShippingExternalLinesRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveMoneyTransactionShippingExternalLinesEndpoint{RemoveMoneyTransactionShippingExternalLinesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().RemoveMoneyTransactionShippingExternalLines(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionEndpoint struct {
	*api.UpdateMoneyTransactionRequest
	Result  *inttypes.MoneyTransaction
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransaction(ctx context.Context, req *api.UpdateMoneyTransactionRequest) (resp *inttypes.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionEndpoint{UpdateMoneyTransactionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateMoneyTransaction(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingEtopEndpoint struct {
	*api.UpdateMoneyTransactionShippingEtopRequest
	Result  *inttypes.MoneyTransactionShippingEtop
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingEtop(ctx context.Context, req *api.UpdateMoneyTransactionShippingEtopRequest) (resp *inttypes.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingEtopEndpoint{UpdateMoneyTransactionShippingEtopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateMoneyTransactionShippingEtop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateMoneyTransactionShippingExternalEndpoint struct {
	*api.UpdateMoneyTransactionShippingExternalRequest
	Result  *inttypes.MoneyTransactionShippingExternal
	Context claims.AdminClaim
}

func (s wrapMoneyTransactionService) UpdateMoneyTransactionShippingExternal(ctx context.Context, req *api.UpdateMoneyTransactionShippingExternalRequest) (resp *inttypes.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingExternalEndpoint{UpdateMoneyTransactionShippingExternalRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateMoneyTransactionShippingExternal(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapNotificationService(s func() *NotificationService) func() api.NotificationService {
	return func() api.NotificationService { return wrapNotificationService{s: s} }
}

type wrapNotificationService struct {
	s func() *NotificationService
}

type CreateNotificationsEndpoint struct {
	*api.CreateNotificationsRequest
	Result  *api.CreateNotificationsResponse
	Context claims.AdminClaim
}

func (s wrapNotificationService) CreateNotifications(ctx context.Context, req *api.CreateNotificationsRequest) (resp *api.CreateNotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Notification/CreateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateNotificationsEndpoint{CreateNotificationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateNotifications(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s func() *OrderService) func() api.OrderService {
	return func() api.OrderService { return wrapOrderService{s: s} }
}

type wrapOrderService struct {
	s func() *OrderService
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result  *inttypes.Order
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *inttypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersEndpoint struct {
	*api.GetOrdersRequest
	Result  *inttypes.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrders(ctx context.Context, req *api.GetOrdersRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *inttypes.OrdersResponse
	Context claims.AdminClaim
}

func (s wrapOrderService) GetOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *inttypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetOrdersByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShipmentPriceService(s func() *ShipmentPriceService) func() api.ShipmentPriceService {
	return func() api.ShipmentPriceService { return wrapShipmentPriceService{s: s} }
}

type wrapShipmentPriceService struct {
	s func() *ShipmentPriceService
}

type CreateShipmentPriceEndpoint struct {
	*api.CreateShipmentPriceRequest
	Result  *api.ShipmentPrice
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) CreateShipmentPrice(ctx context.Context, req *api.CreateShipmentPriceRequest) (resp *api.ShipmentPrice, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/CreateShipmentPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipmentPriceEndpoint{CreateShipmentPriceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateShipmentPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShipmentPriceListEndpoint struct {
	*api.CreateShipmentPriceListRequest
	Result  *api.ShipmentPriceList
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) CreateShipmentPriceList(ctx context.Context, req *api.CreateShipmentPriceListRequest) (resp *api.ShipmentPriceList, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/CreateShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipmentPriceListEndpoint{CreateShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShipmentServiceEndpoint struct {
	*api.CreateShipmentServiceRequest
	Result  *api.ShipmentService
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) CreateShipmentService(ctx context.Context, req *api.CreateShipmentServiceRequest) (resp *api.ShipmentService, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/CreateShipmentService"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipmentServiceEndpoint{CreateShipmentServiceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateShipmentService(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateShopShipmentPriceListEndpoint struct {
	*api.CreateShopShipmentPriceList
	Result  *api.ShopShipmentPriceList
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) CreateShopShipmentPriceList(ctx context.Context, req *api.CreateShopShipmentPriceList) (resp *api.ShopShipmentPriceList, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/CreateShopShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShopShipmentPriceListEndpoint{CreateShopShipmentPriceList: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateShopShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShipmentPriceEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) DeleteShipmentPrice(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/DeleteShipmentPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShipmentPriceEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteShipmentPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShipmentPriceListEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) DeleteShipmentPriceList(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/DeleteShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShipmentPriceListEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShipmentServiceEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) DeleteShipmentService(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/DeleteShipmentService"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShipmentServiceEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteShipmentService(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteShopShipmentPriceListEndpoint struct {
	*api.GetShopShipmentPriceListRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) DeleteShopShipmentPriceList(ctx context.Context, req *api.GetShopShipmentPriceListRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/DeleteShopShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShopShipmentPriceListEndpoint{GetShopShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteShopShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentPriceEndpoint struct {
	*cm.IDRequest
	Result  *api.ShipmentPrice
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentPrice(ctx context.Context, req *cm.IDRequest) (resp *api.ShipmentPrice, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentPriceEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentPriceListEndpoint struct {
	*cm.IDRequest
	Result  *api.ShipmentPriceList
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentPriceList(ctx context.Context, req *cm.IDRequest) (resp *api.ShipmentPriceList, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentPriceListEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentPriceListsEndpoint struct {
	*api.GetShipmentPriceListsRequest
	Result  *api.GetShipmentPriceListsResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentPriceLists(ctx context.Context, req *api.GetShipmentPriceListsRequest) (resp *api.GetShipmentPriceListsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentPriceLists"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentPriceListsEndpoint{GetShipmentPriceListsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentPriceLists(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentPricesEndpoint struct {
	*api.GetShipmentPricesRequest
	Result  *api.GetShipmentPricesResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentPrices(ctx context.Context, req *api.GetShipmentPricesRequest) (resp *api.GetShipmentPricesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentPrices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentPricesEndpoint{GetShipmentPricesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentPrices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentServiceEndpoint struct {
	*cm.IDRequest
	Result  *api.ShipmentService
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentService(ctx context.Context, req *cm.IDRequest) (resp *api.ShipmentService, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentService"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentServiceEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentService(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShipmentServicesEndpoint struct {
	*cm.Empty
	Result  *api.GetShipmentServicesResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShipmentServices(ctx context.Context, req *cm.Empty) (resp *api.GetShipmentServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShipmentServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipmentServicesEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShipmentServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShippingServicesEndpoint struct {
	*api.GetShippingServicesRequest
	Result  *inttypes.GetShippingServicesResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShippingServices(ctx context.Context, req *api.GetShippingServicesRequest) (resp *inttypes.GetShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShippingServicesEndpoint{GetShippingServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopShipmentPriceListEndpoint struct {
	*api.GetShopShipmentPriceListRequest
	Result  *api.ShopShipmentPriceList
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShopShipmentPriceList(ctx context.Context, req *api.GetShopShipmentPriceListRequest) (resp *api.ShopShipmentPriceList, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShopShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopShipmentPriceListEndpoint{GetShopShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShopShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopShipmentPriceListsEndpoint struct {
	*api.GetShopShipmentPriceListsRequest
	Result  *api.GetShopShipmentPriceListsResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) GetShopShipmentPriceLists(ctx context.Context, req *api.GetShopShipmentPriceListsRequest) (resp *api.GetShopShipmentPriceListsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/GetShopShipmentPriceLists"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopShipmentPriceListsEndpoint{GetShopShipmentPriceListsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShopShipmentPriceLists(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type SetDefaultShipmentPriceListEndpoint struct {
	*api.ActiveShipmentPriceListRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) SetDefaultShipmentPriceList(ctx context.Context, req *api.ActiveShipmentPriceListRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/SetDefaultShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultShipmentPriceListEndpoint{ActiveShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().SetDefaultShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentPriceEndpoint struct {
	*api.UpdateShipmentPriceRequest
	Result  *api.ShipmentPrice
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentPrice(ctx context.Context, req *api.UpdateShipmentPriceRequest) (resp *api.ShipmentPrice, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentPrice"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentPriceEndpoint{UpdateShipmentPriceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentPrice(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentPriceListEndpoint struct {
	*api.UpdateShipmentPriceListRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentPriceList(ctx context.Context, req *api.UpdateShipmentPriceListRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentPriceListEndpoint{UpdateShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentPricesPriorityPointEndpoint struct {
	*api.UpdateShipmentPricesPriorityPointRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentPricesPriorityPoint(ctx context.Context, req *api.UpdateShipmentPricesPriorityPointRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentPricesPriorityPoint"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentPricesPriorityPointEndpoint{UpdateShipmentPricesPriorityPointRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentPricesPriorityPoint(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentServiceEndpoint struct {
	*api.UpdateShipmentServiceRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentService(ctx context.Context, req *api.UpdateShipmentServiceRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentService"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentServiceEndpoint{UpdateShipmentServiceRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentService(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentServicesAvailableLocationsEndpoint struct {
	*api.UpdateShipmentServicesAvailableLocationsRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentServicesAvailableLocations(ctx context.Context, req *api.UpdateShipmentServicesAvailableLocationsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentServicesAvailableLocations"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentServicesAvailableLocationsEndpoint{UpdateShipmentServicesAvailableLocationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentServicesAvailableLocations(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShipmentServicesBlacklistLocationsEndpoint struct {
	*api.UpdateShipmentServicesBlacklistLocationsRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShipmentServicesBlacklistLocations(ctx context.Context, req *api.UpdateShipmentServicesBlacklistLocationsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShipmentServicesBlacklistLocations"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipmentServicesBlacklistLocationsEndpoint{UpdateShipmentServicesBlacklistLocationsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShipmentServicesBlacklistLocations(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateShopShipmentPriceListEndpoint struct {
	*api.UpdateShopShipmentPriceListRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapShipmentPriceService) UpdateShopShipmentPriceList(ctx context.Context, req *api.UpdateShopShipmentPriceListRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.ShipmentPrice/UpdateShopShipmentPriceList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShopShipmentPriceListEndpoint{UpdateShopShipmentPriceListRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateShopShipmentPriceList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShopService(s func() *ShopService) func() api.ShopService {
	return func() api.ShopService { return wrapShopService{s: s} }
}

type wrapShopService struct {
	s func() *ShopService
}

type GetShopEndpoint struct {
	*cm.IDRequest
	Result  *etop.Shop
	Context claims.AdminClaim
}

func (s wrapShopService) GetShop(ctx context.Context, req *cm.IDRequest) (resp *etop.Shop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopsEndpoint struct {
	*api.GetShopsRequest
	Result  *api.GetShopsResponse
	Context claims.AdminClaim
}

func (s wrapShopService) GetShops(ctx context.Context, req *api.GetShopsRequest) (resp *api.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsEndpoint{GetShopsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShops(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShopsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *api.GetShopsResponse
	Context claims.AdminClaim
}

func (s wrapShopService) GetShopsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *api.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShopsByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsByIDsEndpoint{IDsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetShopsByIDs(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapSubscriptionService(s func() *SubscriptionService) func() api.SubscriptionService {
	return func() api.SubscriptionService { return wrapSubscriptionService{s: s} }
}

type wrapSubscriptionService struct {
	s func() *SubscriptionService
}

type ActivateSubscriptionEndpoint struct {
	*inttypes.SubscriptionIDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) ActivateSubscription(ctx context.Context, req *inttypes.SubscriptionIDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/ActivateSubscription"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ActivateSubscriptionEndpoint{SubscriptionIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ActivateSubscription(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CancelSubscriptionEndpoint struct {
	*inttypes.SubscriptionIDRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) CancelSubscription(ctx context.Context, req *inttypes.SubscriptionIDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/CancelSubscription"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelSubscriptionEndpoint{SubscriptionIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CancelSubscription(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateSubscriptionEndpoint struct {
	*inttypes.CreateSubscriptionRequest
	Result  *inttypes.Subscription
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) CreateSubscription(ctx context.Context, req *inttypes.CreateSubscriptionRequest) (resp *inttypes.Subscription, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/CreateSubscription"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSubscriptionEndpoint{CreateSubscriptionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateSubscription(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateSubscriptionBillEndpoint struct {
	*inttypes.CreateSubscriptionBillRequest
	Result  *inttypes.SubscriptionBill
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) CreateSubscriptionBill(ctx context.Context, req *inttypes.CreateSubscriptionBillRequest) (resp *inttypes.SubscriptionBill, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/CreateSubscriptionBill"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSubscriptionBillEndpoint{CreateSubscriptionBillRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateSubscriptionBill(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateSubscriptionPlanEndpoint struct {
	*inttypes.CreateSubrPlanRequest
	Result  *inttypes.SubscriptionPlan
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) CreateSubscriptionPlan(ctx context.Context, req *inttypes.CreateSubrPlanRequest) (resp *inttypes.SubscriptionPlan, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/CreateSubscriptionPlan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSubscriptionPlanEndpoint{CreateSubrPlanRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateSubscriptionPlan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateSubscriptionProductEndpoint struct {
	*inttypes.CreateSubrProductRequest
	Result  *inttypes.SubscriptionProduct
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) CreateSubscriptionProduct(ctx context.Context, req *inttypes.CreateSubrProductRequest) (resp *inttypes.SubscriptionProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/CreateSubscriptionProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateSubscriptionProductEndpoint{CreateSubrProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().CreateSubscriptionProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSubscriptionEndpoint struct {
	*inttypes.SubscriptionIDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) DeleteSubscription(ctx context.Context, req *inttypes.SubscriptionIDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/DeleteSubscription"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSubscriptionEndpoint{SubscriptionIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteSubscription(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSubscriptionBillEndpoint struct {
	*inttypes.SubscriptionIDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) DeleteSubscriptionBill(ctx context.Context, req *inttypes.SubscriptionIDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/DeleteSubscriptionBill"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSubscriptionBillEndpoint{SubscriptionIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteSubscriptionBill(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSubscriptionPlanEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) DeleteSubscriptionPlan(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/DeleteSubscriptionPlan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSubscriptionPlanEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteSubscriptionPlan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteSubscriptionProductEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) DeleteSubscriptionProduct(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/DeleteSubscriptionProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteSubscriptionProductEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().DeleteSubscriptionProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSubscriptionEndpoint struct {
	*inttypes.SubscriptionIDRequest
	Result  *inttypes.Subscription
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) GetSubscription(ctx context.Context, req *inttypes.SubscriptionIDRequest) (resp *inttypes.Subscription, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/GetSubscription"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSubscriptionEndpoint{SubscriptionIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetSubscription(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSubscriptionBillsEndpoint struct {
	*inttypes.GetSubscriptionBillsRequest
	Result  *inttypes.GetSubscriptionBillsResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) GetSubscriptionBills(ctx context.Context, req *inttypes.GetSubscriptionBillsRequest) (resp *inttypes.GetSubscriptionBillsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/GetSubscriptionBills"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSubscriptionBillsEndpoint{GetSubscriptionBillsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetSubscriptionBills(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSubscriptionPlansEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetSubrPlansResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) GetSubscriptionPlans(ctx context.Context, req *cm.Empty) (resp *inttypes.GetSubrPlansResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/GetSubscriptionPlans"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSubscriptionPlansEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetSubscriptionPlans(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSubscriptionProductsEndpoint struct {
	*cm.Empty
	Result  *inttypes.GetSubrProductsResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) GetSubscriptionProducts(ctx context.Context, req *cm.Empty) (resp *inttypes.GetSubrProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/GetSubscriptionProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSubscriptionProductsEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetSubscriptionProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetSubscriptionsEndpoint struct {
	*inttypes.GetSubscriptionsRequest
	Result  *inttypes.GetSubscriptionsResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) GetSubscriptions(ctx context.Context, req *inttypes.GetSubscriptionsRequest) (resp *inttypes.GetSubscriptionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/GetSubscriptions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetSubscriptionsEndpoint{GetSubscriptionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().GetSubscriptions(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ManualPaymentSubscriptionBillEndpoint struct {
	*inttypes.ManualPaymentSubscriptionBillRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) ManualPaymentSubscriptionBill(ctx context.Context, req *inttypes.ManualPaymentSubscriptionBillRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/ManualPaymentSubscriptionBill"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ManualPaymentSubscriptionBillEndpoint{ManualPaymentSubscriptionBillRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().ManualPaymentSubscriptionBill(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateSubscriptionInfoEndpoint struct {
	*inttypes.UpdateSubscriptionInfoRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) UpdateSubscriptionInfo(ctx context.Context, req *inttypes.UpdateSubscriptionInfoRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/UpdateSubscriptionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateSubscriptionInfoEndpoint{UpdateSubscriptionInfoRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateSubscriptionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateSubscriptionPlanEndpoint struct {
	*inttypes.UpdateSubrPlanRequest
	Result  *cm.UpdatedResponse
	Context claims.AdminClaim
}

func (s wrapSubscriptionService) UpdateSubscriptionPlan(ctx context.Context, req *inttypes.UpdateSubrPlanRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Subscription/UpdateSubscriptionPlan"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	ctx, err = middleware.StartSession(ctx, sessionQuery)
	if err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateSubscriptionPlanEndpoint{UpdateSubrPlanRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s().UpdateSubscriptionPlan(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
