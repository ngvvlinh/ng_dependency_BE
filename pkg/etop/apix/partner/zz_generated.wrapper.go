// +build !generator

// Code generated by generator wrapper. DO NOT EDIT.

package partner

import (
	"context"
	"time"

	api "etop.vn/api/top/external/partner"
	externaltypes "etop.vn/api/top/external/types"
	etop "etop.vn/api/top/int/etop"
	cm "etop.vn/api/top/types/common"
	common "etop.vn/backend/pkg/common"
	cmwrapper "etop.vn/backend/pkg/common/apifw/wrapper"
	bus "etop.vn/backend/pkg/common/bus"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
)

func WrapCustomerService(s *CustomerService) api.CustomerService {
	return wrapCustomerService{s: s}
}

type wrapCustomerService struct {
	s *CustomerService
}

type CreateCustomerEndpoint struct {
	*externaltypes.CreateCustomerRequest
	Result  *externaltypes.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) CreateCustomer(ctx context.Context, req *externaltypes.CreateCustomerRequest) (resp *externaltypes.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Customer/CreateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCustomerEndpoint{CreateCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCustomerEndpoint struct {
	*externaltypes.DeleteCustomerRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapCustomerService) DeleteCustomer(ctx context.Context, req *externaltypes.DeleteCustomerRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Customer/DeleteCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCustomerEndpoint{DeleteCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCustomerEndpoint struct {
	*externaltypes.GetCustomerRequest
	Result  *externaltypes.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) GetCustomer(ctx context.Context, req *externaltypes.GetCustomerRequest) (resp *externaltypes.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Customer/GetCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCustomerEndpoint{GetCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListCustomersEndpoint struct {
	*externaltypes.ListCustomersRequest
	Result  *externaltypes.CustomersResponse
	Context claims.ShopClaim
}

func (s wrapCustomerService) ListCustomers(ctx context.Context, req *externaltypes.ListCustomersRequest) (resp *externaltypes.CustomersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Customer/ListCustomers"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListCustomersEndpoint{ListCustomersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListCustomers(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCustomerEndpoint struct {
	*externaltypes.UpdateCustomerRequest
	Result  *externaltypes.Customer
	Context claims.ShopClaim
}

func (s wrapCustomerService) UpdateCustomer(ctx context.Context, req *externaltypes.UpdateCustomerRequest) (resp *externaltypes.Customer, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Customer/UpdateCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCustomerEndpoint{UpdateCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerAddressService(s *CustomerAddressService) api.CustomerAddressService {
	return wrapCustomerAddressService{s: s}
}

type wrapCustomerAddressService struct {
	s *CustomerAddressService
}

type CreateAddressEndpoint struct {
	*externaltypes.CreateCustomerAddressRequest
	Result  *externaltypes.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerAddressService) CreateAddress(ctx context.Context, req *externaltypes.CreateCustomerAddressRequest) (resp *externaltypes.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerAddress/CreateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAddressEndpoint{CreateCustomerAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapCustomerAddressService) DeleteAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerAddress/DeleteAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteAddressEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetAddressEndpoint struct {
	*externaltypes.OrderIDRequest
	Result  *externaltypes.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerAddressService) GetAddress(ctx context.Context, req *externaltypes.OrderIDRequest) (resp *externaltypes.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerAddress/GetAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAddressEndpoint{OrderIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListAddressesEndpoint struct {
	*externaltypes.ListCustomerAddressesRequest
	Result  *externaltypes.CustomerAddressesResponse
	Context claims.ShopClaim
}

func (s wrapCustomerAddressService) ListAddresses(ctx context.Context, req *externaltypes.ListCustomerAddressesRequest) (resp *externaltypes.CustomerAddressesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerAddress/ListAddresses"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListAddressesEndpoint{ListCustomerAddressesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListAddresses(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateAddressEndpoint struct {
	*externaltypes.UpdateCustomerAddressRequest
	Result  *externaltypes.CustomerAddress
	Context claims.ShopClaim
}

func (s wrapCustomerAddressService) UpdateAddress(ctx context.Context, req *externaltypes.UpdateCustomerAddressRequest) (resp *externaltypes.CustomerAddress, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerAddress/UpdateAddress"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAddressEndpoint{UpdateCustomerAddressRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateAddress(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapCustomerGroupService(s *CustomerGroupService) api.CustomerGroupService {
	return wrapCustomerGroupService{s: s}
}

type wrapCustomerGroupService struct {
	s *CustomerGroupService
}

type AddCustomerEndpoint struct {
	*externaltypes.AddCustomerRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) AddCustomer(ctx context.Context, req *externaltypes.AddCustomerRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/AddCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddCustomerEndpoint{AddCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateGroupEndpoint struct {
	*externaltypes.CreateCustomerGroupRequest
	Result  *externaltypes.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) CreateGroup(ctx context.Context, req *externaltypes.CreateCustomerGroupRequest) (resp *externaltypes.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/CreateGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateGroupEndpoint{CreateCustomerGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteGroupEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) DeleteGroup(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/DeleteGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteGroupEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetGroupEndpoint struct {
	*cm.IDRequest
	Result  *externaltypes.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) GetGroup(ctx context.Context, req *cm.IDRequest) (resp *externaltypes.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/GetGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetGroupEndpoint{IDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListGroupsEndpoint struct {
	*externaltypes.ListCustomerGroupsRequest
	Result  *externaltypes.CustomerGroupsResponse
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) ListGroups(ctx context.Context, req *externaltypes.ListCustomerGroupsRequest) (resp *externaltypes.CustomerGroupsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/ListGroups"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListGroupsEndpoint{ListCustomerGroupsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListGroups(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveCustomerEndpoint struct {
	*externaltypes.RemoveCustomerRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) RemoveCustomer(ctx context.Context, req *externaltypes.RemoveCustomerRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/RemoveCustomer"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveCustomerEndpoint{RemoveCustomerRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveCustomer(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateGroupEndpoint struct {
	*externaltypes.UpdateCustomerGroupRequest
	Result  *externaltypes.CustomerGroup
	Context claims.ShopClaim
}

func (s wrapCustomerGroupService) UpdateGroup(ctx context.Context, req *externaltypes.UpdateCustomerGroupRequest) (resp *externaltypes.CustomerGroup, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.CustomerGroup/UpdateGroup"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateGroupEndpoint{UpdateCustomerGroupRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateGroup(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapFulfillmentService(s *FulfillmentService) api.FulfillmentService {
	return wrapFulfillmentService{s: s}
}

type wrapFulfillmentService struct {
	s *FulfillmentService
}

type FulfillmentGetFulfillmentEndpoint struct {
	*externaltypes.FulfillmentIDRequest
	Result  *externaltypes.Fulfillment
	Context claims.ShopClaim
}

func (s wrapFulfillmentService) GetFulfillment(ctx context.Context, req *externaltypes.FulfillmentIDRequest) (resp *externaltypes.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &FulfillmentGetFulfillmentEndpoint{FulfillmentIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type FulfillmentListFulfillmentsEndpoint struct {
	*externaltypes.ListFulfillmentsRequest
	Result  *externaltypes.FulfillmentsResponse
	Context claims.ShopClaim
}

func (s wrapFulfillmentService) ListFulfillments(ctx context.Context, req *externaltypes.ListFulfillmentsRequest) (resp *externaltypes.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Fulfillment/ListFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &FulfillmentListFulfillmentsEndpoint{ListFulfillmentsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListFulfillments(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapHistoryService(s *HistoryService) api.HistoryService {
	return wrapHistoryService{s: s}
}

type wrapHistoryService struct {
	s *HistoryService
}

type GetChangesEndpoint struct {
	*cm.Empty
	Result  *externaltypes.Callback
	Context claims.PartnerClaim
}

func (s wrapHistoryService) GetChanges(ctx context.Context, req *cm.Empty) (resp *externaltypes.Callback, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.History/GetChanges"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetChangesEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetChanges(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapInventoryService(s *InventoryService) api.InventoryService {
	return wrapInventoryService{s: s}
}

type wrapInventoryService struct {
	s *InventoryService
}

type ListInventoryLevelsEndpoint struct {
	*externaltypes.ListInventoryLevelsRequest
	Result  *externaltypes.InventoryLevelsResponse
	Context claims.ShopClaim
}

func (s wrapInventoryService) ListInventoryLevels(ctx context.Context, req *externaltypes.ListInventoryLevelsRequest) (resp *externaltypes.InventoryLevelsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Inventory/ListInventoryLevels"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListInventoryLevelsEndpoint{ListInventoryLevelsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListInventoryLevels(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapMiscService(s *MiscService) api.MiscService {
	return wrapMiscService{s: s}
}

type wrapMiscService struct {
	s *MiscService
}

type CurrentAccountEndpoint struct {
	*cm.Empty
	Result  *externaltypes.Partner
	Context claims.PartnerClaim
}

func (s wrapMiscService) CurrentAccount(ctx context.Context, req *cm.Empty) (resp *externaltypes.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Misc/CurrentAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CurrentAccountEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CurrentAccount(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetLocationListEndpoint struct {
	*cm.Empty
	Result  *externaltypes.LocationResponse
	Context claims.PartnerClaim
}

func (s wrapMiscService) GetLocationList(ctx context.Context, req *cm.Empty) (resp *externaltypes.LocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Misc/GetLocationList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLocationListEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetLocationList(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context claims.EmptyClaim
}

func (s wrapMiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context: ctx,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	ctx = bus.NewRootContext(ctx)
	err = s.s.VersionInfo(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapOrderService(s *OrderService) api.OrderService {
	return wrapOrderService{s: s}
}

type wrapOrderService struct {
	s *OrderService
}

type OrderCancelOrderEndpoint struct {
	*externaltypes.CancelOrderRequest
	Result  *externaltypes.OrderAndFulfillments
	Context claims.ShopClaim
}

func (s wrapOrderService) CancelOrder(ctx context.Context, req *externaltypes.CancelOrderRequest) (resp *externaltypes.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Order/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &OrderCancelOrderEndpoint{CancelOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type OrderConfirmOrderEndpoint struct {
	*externaltypes.ConfirmOrderRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapOrderService) ConfirmOrder(ctx context.Context, req *externaltypes.ConfirmOrderRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Order/ConfirmOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &OrderConfirmOrderEndpoint{ConfirmOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ConfirmOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type OrderCreateOrderEndpoint struct {
	*externaltypes.CreateOrderRequest
	Result  *externaltypes.Order
	Context claims.ShopClaim
}

func (s wrapOrderService) CreateOrder(ctx context.Context, req *externaltypes.CreateOrderRequest) (resp *externaltypes.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Order/CreateOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &OrderCreateOrderEndpoint{CreateOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type OrderGetOrderEndpoint struct {
	*externaltypes.OrderIDRequest
	Result  *externaltypes.OrderAndFulfillments
	Context claims.ShopClaim
}

func (s wrapOrderService) GetOrder(ctx context.Context, req *externaltypes.OrderIDRequest) (resp *externaltypes.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &OrderGetOrderEndpoint{OrderIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type OrderListOrdersEndpoint struct {
	*externaltypes.ListOrdersRequest
	Result  *externaltypes.OrdersResponse
	Context claims.ShopClaim
}

func (s wrapOrderService) ListOrders(ctx context.Context, req *externaltypes.ListOrdersRequest) (resp *externaltypes.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Order/ListOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &OrderListOrdersEndpoint{ListOrdersRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListOrders(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductService(s *ProductService) api.ProductService {
	return wrapProductService{s: s}
}

type wrapProductService struct {
	s *ProductService
}

type CreateProductEndpoint struct {
	*externaltypes.CreateProductRequest
	Result  *externaltypes.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) CreateProduct(ctx context.Context, req *externaltypes.CreateProductRequest) (resp *externaltypes.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Product/CreateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductEndpoint{CreateProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteProductEndpoint struct {
	*externaltypes.GetProductRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapProductService) DeleteProduct(ctx context.Context, req *externaltypes.GetProductRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Product/DeleteProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteProductEndpoint{GetProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetProductEndpoint struct {
	*externaltypes.GetProductRequest
	Result  *externaltypes.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) GetProduct(ctx context.Context, req *externaltypes.GetProductRequest) (resp *externaltypes.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Product/GetProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductEndpoint{GetProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListProductsEndpoint struct {
	*externaltypes.ListProductsRequest
	Result  *externaltypes.ShopProductsResponse
	Context claims.ShopClaim
}

func (s wrapProductService) ListProducts(ctx context.Context, req *externaltypes.ListProductsRequest) (resp *externaltypes.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Product/ListProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListProductsEndpoint{ListProductsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListProducts(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateProductEndpoint struct {
	*externaltypes.UpdateProductRequest
	Result  *externaltypes.ShopProduct
	Context claims.ShopClaim
}

func (s wrapProductService) UpdateProduct(ctx context.Context, req *externaltypes.UpdateProductRequest) (resp *externaltypes.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Product/UpdateProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductEndpoint{UpdateProductRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapProductCollectionService(s *ProductCollectionService) api.ProductCollectionService {
	return wrapProductCollectionService{s: s}
}

type wrapProductCollectionService struct {
	s *ProductCollectionService
}

type AddProductEndpoint struct {
	*externaltypes.AddProductCollectionRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) AddProduct(ctx context.Context, req *externaltypes.AddProductCollectionRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/AddProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddProductEndpoint{AddProductCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.AddProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateCollectionEndpoint struct {
	*externaltypes.CreateCollectionRequest
	Result  *externaltypes.ProductCollection
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) CreateCollection(ctx context.Context, req *externaltypes.CreateCollectionRequest) (resp *externaltypes.ProductCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/CreateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCollectionEndpoint{CreateCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteCollectionEndpoint struct {
	*externaltypes.GetCollectionRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) DeleteCollection(ctx context.Context, req *externaltypes.GetCollectionRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/DeleteCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCollectionEndpoint{GetCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetCollectionEndpoint struct {
	*externaltypes.GetCollectionRequest
	Result  *externaltypes.ProductCollection
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) GetCollection(ctx context.Context, req *externaltypes.GetCollectionRequest) (resp *externaltypes.ProductCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/GetCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionEndpoint{GetCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListCollectionsEndpoint struct {
	*externaltypes.ListCollectionsRequest
	Result  *externaltypes.ProductCollectionsResponse
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) ListCollections(ctx context.Context, req *externaltypes.ListCollectionsRequest) (resp *externaltypes.ProductCollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/ListCollections"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListCollectionsEndpoint{ListCollectionsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListCollections(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type RemoveProductEndpoint struct {
	*externaltypes.RemoveProductCollectionRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) RemoveProduct(ctx context.Context, req *externaltypes.RemoveProductCollectionRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/RemoveProduct"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductEndpoint{RemoveProductCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.RemoveProduct(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateCollectionEndpoint struct {
	*externaltypes.UpdateCollectionRequest
	Result  *externaltypes.ProductCollection
	Context claims.ShopClaim
}

func (s wrapProductCollectionService) UpdateCollection(ctx context.Context, req *externaltypes.UpdateCollectionRequest) (resp *externaltypes.ProductCollection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.ProductCollection/UpdateCollection"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCollectionEndpoint{UpdateCollectionRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateCollection(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShippingService(s *ShippingService) api.ShippingService {
	return wrapShippingService{s: s}
}

type wrapShippingService struct {
	s *ShippingService
}

type CancelOrderEndpoint struct {
	*externaltypes.CancelOrderRequest
	Result  *externaltypes.OrderAndFulfillments
	Context claims.ShopClaim
}

func (s wrapShippingService) CancelOrder(ctx context.Context, req *externaltypes.CancelOrderRequest) (resp *externaltypes.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelOrderEndpoint{CancelOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CancelOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CreateAndConfirmOrderEndpoint struct {
	*externaltypes.CreateOrderRequest
	Result  *externaltypes.OrderAndFulfillments
	Context claims.ShopClaim
}

func (s wrapShippingService) CreateAndConfirmOrder(ctx context.Context, req *externaltypes.CreateOrderRequest) (resp *externaltypes.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/CreateAndConfirmOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAndConfirmOrderEndpoint{CreateOrderRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateAndConfirmOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetFulfillmentEndpoint struct {
	*externaltypes.FulfillmentIDRequest
	Result  *externaltypes.Fulfillment
	Context claims.ShopClaim
}

func (s wrapShippingService) GetFulfillment(ctx context.Context, req *externaltypes.FulfillmentIDRequest) (resp *externaltypes.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{FulfillmentIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetFulfillment(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetOrderEndpoint struct {
	*externaltypes.OrderIDRequest
	Result  *externaltypes.OrderAndFulfillments
	Context claims.ShopClaim
}

func (s wrapShippingService) GetOrder(ctx context.Context, req *externaltypes.OrderIDRequest) (resp *externaltypes.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{OrderIDRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetOrder(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetShippingServicesEndpoint struct {
	*externaltypes.GetShippingServicesRequest
	Result  *externaltypes.GetShippingServicesResponse
	Context claims.ShopClaim
}

func (s wrapShippingService) GetShippingServices(ctx context.Context, req *externaltypes.GetShippingServicesRequest) (resp *externaltypes.GetShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShippingServicesEndpoint{GetShippingServicesRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetShippingServices(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapShopService(s *ShopService) api.ShopService {
	return wrapShopService{s: s}
}

type wrapShopService struct {
	s *ShopService
}

type AuthorizeShopEndpoint struct {
	*api.AuthorizeShopRequest
	Result  *api.AuthorizeShopResponse
	Context claims.PartnerClaim
}

func (s wrapShopService) AuthorizeShop(ctx context.Context, req *api.AuthorizeShopRequest) (resp *api.AuthorizeShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shop/AuthorizeShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AuthorizeShopEndpoint{AuthorizeShopRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.AuthorizeShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type CurrentShopEndpoint struct {
	*cm.Empty
	Result  *etop.PublicAccountInfo
	Context claims.ShopClaim
}

func (s wrapShopService) CurrentShop(ctx context.Context, req *cm.Empty) (resp *etop.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shop/CurrentShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CurrentShopEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CurrentShop(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapVariantService(s *VariantService) api.VariantService {
	return wrapVariantService{s: s}
}

type wrapVariantService struct {
	s *VariantService
}

type CreateVariantEndpoint struct {
	*externaltypes.CreateVariantRequest
	Result  *externaltypes.ShopVariant
	Context claims.ShopClaim
}

func (s wrapVariantService) CreateVariant(ctx context.Context, req *externaltypes.CreateVariantRequest) (resp *externaltypes.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Variant/CreateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateVariantEndpoint{CreateVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteVariantEndpoint struct {
	*externaltypes.GetVariantRequest
	Result  *cm.Empty
	Context claims.ShopClaim
}

func (s wrapVariantService) DeleteVariant(ctx context.Context, req *externaltypes.GetVariantRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Variant/DeleteVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteVariantEndpoint{GetVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetVariantEndpoint struct {
	*externaltypes.GetVariantRequest
	Result  *externaltypes.ShopVariant
	Context claims.ShopClaim
}

func (s wrapVariantService) GetVariant(ctx context.Context, req *externaltypes.GetVariantRequest) (resp *externaltypes.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Variant/GetVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetVariantEndpoint{GetVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type ListVariantsEndpoint struct {
	*externaltypes.ListVariantsRequest
	Result  *externaltypes.ShopVariantsResponse
	Context claims.ShopClaim
}

func (s wrapVariantService) ListVariants(ctx context.Context, req *externaltypes.ListVariantsRequest) (resp *externaltypes.ShopVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Variant/ListVariants"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ListVariantsEndpoint{ListVariantsRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.ListVariants(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type UpdateVariantEndpoint struct {
	*externaltypes.UpdateVariantRequest
	Result  *externaltypes.ShopVariant
	Context claims.ShopClaim
}

func (s wrapVariantService) UpdateVariant(ctx context.Context, req *externaltypes.UpdateVariantRequest) (resp *externaltypes.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Variant/UpdateVariant"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantEndpoint{UpdateVariantRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.UpdateVariant(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

func WrapWebhookService(s *WebhookService) api.WebhookService {
	return wrapWebhookService{s: s}
}

type wrapWebhookService struct {
	s *WebhookService
}

type CreateWebhookEndpoint struct {
	*externaltypes.CreateWebhookRequest
	Result  *externaltypes.Webhook
	Context claims.PartnerClaim
}

func (s wrapWebhookService) CreateWebhook(ctx context.Context, req *externaltypes.CreateWebhookRequest) (resp *externaltypes.Webhook, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/CreateWebhook"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateWebhookEndpoint{CreateWebhookRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.CreateWebhook(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type DeleteWebhookEndpoint struct {
	*externaltypes.DeleteWebhookRequest
	Result  *externaltypes.WebhooksResponse
	Context claims.PartnerClaim
}

func (s wrapWebhookService) DeleteWebhook(ctx context.Context, req *externaltypes.DeleteWebhookRequest) (resp *externaltypes.WebhooksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/DeleteWebhook"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteWebhookEndpoint{DeleteWebhookRequest: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.DeleteWebhook(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}

type GetWebhooksEndpoint struct {
	*cm.Empty
	Result  *externaltypes.WebhooksResponse
	Context claims.PartnerClaim
}

func (s wrapWebhookService) GetWebhooks(ctx context.Context, req *cm.Empty) (resp *externaltypes.WebhooksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/GetWebhooks"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWebhooksEndpoint{Empty: req}
	if session != nil {
		query.Context.Claim = session.Claim
	}
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = s.s.GetWebhooks(ctx, query)
	resp = query.Result
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, common.Error(common.Internal, "", nil).Log("nil response")
	}
	errs = cmwrapper.HasErrors(resp)
	return resp, nil
}
