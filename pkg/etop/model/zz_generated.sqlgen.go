// +build !generator

// Code generated by generator sqlgen. DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	time "time"

	cmsql "o.o/backend/pkg/common/sql/cmsql"
	migration "o.o/backend/pkg/common/sql/migration"
	core "o.o/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

type Codes []*Code

const __sqlCode_Table = "code"
const __sqlCode_ListCols = "\"code\",\"type\",\"created_at\""
const __sqlCode_ListColsOnConflict = "\"code\" = EXCLUDED.\"code\",\"type\" = EXCLUDED.\"type\",\"created_at\" = EXCLUDED.\"created_at\""
const __sqlCode_Insert = "INSERT INTO \"code\" (" + __sqlCode_ListCols + ") VALUES"
const __sqlCode_Select = "SELECT " + __sqlCode_ListCols + " FROM \"code\""
const __sqlCode_Select_history = "SELECT " + __sqlCode_ListCols + " FROM history.\"code\""
const __sqlCode_UpdateAll = "UPDATE \"code\" SET (" + __sqlCode_ListCols + ")"
const __sqlCode_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT code_pkey DO UPDATE SET"

func (m *Code) SQLTableName() string  { return "code" }
func (m *Codes) SQLTableName() string { return "code" }
func (m *Code) SQLListCols() string   { return __sqlCode_ListCols }

func (m *Code) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlCode_ListCols + " FROM \"code\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Code) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "code"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"code": {
			ColumnName:       "code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"type": {
			ColumnName:       "type",
			ColumnType:       "CodeType",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "code", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Code)(nil))
}

func (m *Code) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.Code),
		core.String(m.Type),
		core.Now(m.CreatedAt, now, create),
	}
}

func (m *Code) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.Code),
		(*core.String)(&m.Type),
		(*core.Time)(&m.CreatedAt),
	}
}

func (m *Code) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Codes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Codes, 0, 128)
	for rows.Next() {
		m := new(Code)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Code) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select)
	return nil
}

func (_ *Codes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select)
	return nil
}

func (m *Code) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Codes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Code) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlCode_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlCode_ListColsOnConflict)
	return nil
}

func (ms Codes) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlCode_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlCode_ListColsOnConflict)
	return nil
}

func (m *Code) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("code")
	w.WriteRawString(" SET ")
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.Type))
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Code) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type CodeHistory map[string]interface{}
type CodeHistories []map[string]interface{}

func (m *CodeHistory) SQLTableName() string  { return "history.\"code\"" }
func (m CodeHistories) SQLTableName() string { return "history.\"code\"" }

func (m *CodeHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select_history)
	return nil
}

func (m CodeHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select_history)
	return nil
}

func (m CodeHistory) Code() core.Interface      { return core.Interface{m["code"]} }
func (m CodeHistory) Type() core.Interface      { return core.Interface{m["type"]} }
func (m CodeHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }

func (m *CodeHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(CodeHistory, 3)
	res["code"] = data[0]
	res["type"] = data[1]
	res["created_at"] = data[2]
	*m = res
	return nil
}

func (ms *CodeHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(CodeHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(CodeHistory)
		m["code"] = data[0]
		m["type"] = data[1]
		m["created_at"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type ExportAttempts []*ExportAttempt

const __sqlExportAttempt_Table = "export_attempt"
const __sqlExportAttempt_ListCols = "\"id\",\"user_id\",\"account_id\",\"export_type\",\"filename\",\"stored_file\",\"download_url\",\"request_query\",\"mime_type\",\"status\",\"errors\",\"error\",\"n_total\",\"n_exported\",\"n_error\",\"created_at\",\"deleted_at\",\"started_at\",\"done_at\",\"expires_at\""
const __sqlExportAttempt_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"user_id\" = EXCLUDED.\"user_id\",\"account_id\" = EXCLUDED.\"account_id\",\"export_type\" = EXCLUDED.\"export_type\",\"filename\" = EXCLUDED.\"filename\",\"stored_file\" = EXCLUDED.\"stored_file\",\"download_url\" = EXCLUDED.\"download_url\",\"request_query\" = EXCLUDED.\"request_query\",\"mime_type\" = EXCLUDED.\"mime_type\",\"status\" = EXCLUDED.\"status\",\"errors\" = EXCLUDED.\"errors\",\"error\" = EXCLUDED.\"error\",\"n_total\" = EXCLUDED.\"n_total\",\"n_exported\" = EXCLUDED.\"n_exported\",\"n_error\" = EXCLUDED.\"n_error\",\"created_at\" = EXCLUDED.\"created_at\",\"deleted_at\" = EXCLUDED.\"deleted_at\",\"started_at\" = EXCLUDED.\"started_at\",\"done_at\" = EXCLUDED.\"done_at\",\"expires_at\" = EXCLUDED.\"expires_at\""
const __sqlExportAttempt_Insert = "INSERT INTO \"export_attempt\" (" + __sqlExportAttempt_ListCols + ") VALUES"
const __sqlExportAttempt_Select = "SELECT " + __sqlExportAttempt_ListCols + " FROM \"export_attempt\""
const __sqlExportAttempt_Select_history = "SELECT " + __sqlExportAttempt_ListCols + " FROM history.\"export_attempt\""
const __sqlExportAttempt_UpdateAll = "UPDATE \"export_attempt\" SET (" + __sqlExportAttempt_ListCols + ")"
const __sqlExportAttempt_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT export_attempt_pkey DO UPDATE SET"

func (m *ExportAttempt) SQLTableName() string  { return "export_attempt" }
func (m *ExportAttempts) SQLTableName() string { return "export_attempt" }
func (m *ExportAttempt) SQLListCols() string   { return __sqlExportAttempt_ListCols }

func (m *ExportAttempt) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlExportAttempt_ListCols + " FROM \"export_attempt\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ExportAttempt) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "export_attempt"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"user_id": {
			ColumnName:       "user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"export_type": {
			ColumnName:       "export_type",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"filename": {
			ColumnName:       "filename",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"stored_file": {
			ColumnName:       "stored_file",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"download_url": {
			ColumnName:       "download_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"request_query": {
			ColumnName:       "request_query",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"mime_type": {
			ColumnName:       "mime_type",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status4.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "S", "N"},
		},
		"errors": {
			ColumnName:       "errors",
			ColumnType:       "[]*Error",
			ColumnDBType:     "[]*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"error": {
			ColumnName:       "error",
			ColumnType:       "*Error",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_total": {
			ColumnName:       "n_total",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_exported": {
			ColumnName:       "n_exported",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_error": {
			ColumnName:       "n_error",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"deleted_at": {
			ColumnName:       "deleted_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"started_at": {
			ColumnName:       "started_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"done_at": {
			ColumnName:       "done_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"expires_at": {
			ColumnName:       "expires_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "export_attempt", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ExportAttempt)(nil))
}

func (m *ExportAttempt) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.ID),
		m.UserID,
		m.AccountID,
		core.String(m.ExportType),
		core.String(m.FileName),
		core.String(m.StoredFile),
		core.String(m.DownloadURL),
		core.String(m.RequestQuery),
		core.String(m.MimeType),
		m.Status,
		core.JSON{m.Errors},
		core.JSON{m.Error},
		core.Int(m.NTotal),
		core.Int(m.NExported),
		core.Int(m.NError),
		core.Now(m.CreatedAt, now, create),
		core.Time(m.DeletedAt),
		core.Time(m.StartedAt),
		core.Time(m.DoneAt),
		core.Time(m.ExpiresAt),
	}
}

func (m *ExportAttempt) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		&m.UserID,
		&m.AccountID,
		(*core.String)(&m.ExportType),
		(*core.String)(&m.FileName),
		(*core.String)(&m.StoredFile),
		(*core.String)(&m.DownloadURL),
		(*core.String)(&m.RequestQuery),
		(*core.String)(&m.MimeType),
		&m.Status,
		core.JSON{&m.Errors},
		core.JSON{&m.Error},
		(*core.Int)(&m.NTotal),
		(*core.Int)(&m.NExported),
		(*core.Int)(&m.NError),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.DeletedAt),
		(*core.Time)(&m.StartedAt),
		(*core.Time)(&m.DoneAt),
		(*core.Time)(&m.ExpiresAt),
	}
}

func (m *ExportAttempt) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ExportAttempts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ExportAttempts, 0, 128)
	for rows.Next() {
		m := new(ExportAttempt)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ExportAttempt) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select)
	return nil
}

func (_ *ExportAttempts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select)
	return nil
}

func (m *ExportAttempt) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ExportAttempts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(20)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ExportAttempt) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlExportAttempt_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlExportAttempt_ListColsOnConflict)
	return nil
}

func (ms ExportAttempts) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlExportAttempt_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlExportAttempt_ListColsOnConflict)
	return nil
}

func (m *ExportAttempt) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("export_attempt")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.ExportType != "" {
		flag = true
		w.WriteName("export_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExportType)
	}
	if m.FileName != "" {
		flag = true
		w.WriteName("filename")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FileName)
	}
	if m.StoredFile != "" {
		flag = true
		w.WriteName("stored_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StoredFile)
	}
	if m.DownloadURL != "" {
		flag = true
		w.WriteName("download_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DownloadURL)
	}
	if m.RequestQuery != "" {
		flag = true
		w.WriteName("request_query")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RequestQuery)
	}
	if m.MimeType != "" {
		flag = true
		w.WriteName("mime_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.MimeType)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.Errors != nil {
		flag = true
		w.WriteName("errors")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Errors})
	}
	if m.Error != nil {
		flag = true
		w.WriteName("error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Error})
	}
	if m.NTotal != 0 {
		flag = true
		w.WriteName("n_total")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NTotal)
	}
	if m.NExported != 0 {
		flag = true
		w.WriteName("n_exported")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NExported)
	}
	if m.NError != 0 {
		flag = true
		w.WriteName("n_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NError)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !m.StartedAt.IsZero() {
		flag = true
		w.WriteName("started_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StartedAt)
	}
	if !m.DoneAt.IsZero() {
		flag = true
		w.WriteName("done_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DoneAt)
	}
	if !m.ExpiresAt.IsZero() {
		flag = true
		w.WriteName("expires_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExpiresAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ExportAttempt) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ExportAttemptHistory map[string]interface{}
type ExportAttemptHistories []map[string]interface{}

func (m *ExportAttemptHistory) SQLTableName() string  { return "history.\"export_attempt\"" }
func (m ExportAttemptHistories) SQLTableName() string { return "history.\"export_attempt\"" }

func (m *ExportAttemptHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select_history)
	return nil
}

func (m ExportAttemptHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select_history)
	return nil
}

func (m ExportAttemptHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m ExportAttemptHistory) UserID() core.Interface      { return core.Interface{m["user_id"]} }
func (m ExportAttemptHistory) AccountID() core.Interface   { return core.Interface{m["account_id"]} }
func (m ExportAttemptHistory) ExportType() core.Interface  { return core.Interface{m["export_type"]} }
func (m ExportAttemptHistory) FileName() core.Interface    { return core.Interface{m["filename"]} }
func (m ExportAttemptHistory) StoredFile() core.Interface  { return core.Interface{m["stored_file"]} }
func (m ExportAttemptHistory) DownloadURL() core.Interface { return core.Interface{m["download_url"]} }
func (m ExportAttemptHistory) RequestQuery() core.Interface {
	return core.Interface{m["request_query"]}
}
func (m ExportAttemptHistory) MimeType() core.Interface  { return core.Interface{m["mime_type"]} }
func (m ExportAttemptHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m ExportAttemptHistory) Errors() core.Interface    { return core.Interface{m["errors"]} }
func (m ExportAttemptHistory) Error() core.Interface     { return core.Interface{m["error"]} }
func (m ExportAttemptHistory) NTotal() core.Interface    { return core.Interface{m["n_total"]} }
func (m ExportAttemptHistory) NExported() core.Interface { return core.Interface{m["n_exported"]} }
func (m ExportAttemptHistory) NError() core.Interface    { return core.Interface{m["n_error"]} }
func (m ExportAttemptHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m ExportAttemptHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }
func (m ExportAttemptHistory) StartedAt() core.Interface { return core.Interface{m["started_at"]} }
func (m ExportAttemptHistory) DoneAt() core.Interface    { return core.Interface{m["done_at"]} }
func (m ExportAttemptHistory) ExpiresAt() core.Interface { return core.Interface{m["expires_at"]} }

func (m *ExportAttemptHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ExportAttemptHistory, 20)
	res["id"] = data[0]
	res["user_id"] = data[1]
	res["account_id"] = data[2]
	res["export_type"] = data[3]
	res["filename"] = data[4]
	res["stored_file"] = data[5]
	res["download_url"] = data[6]
	res["request_query"] = data[7]
	res["mime_type"] = data[8]
	res["status"] = data[9]
	res["errors"] = data[10]
	res["error"] = data[11]
	res["n_total"] = data[12]
	res["n_exported"] = data[13]
	res["n_error"] = data[14]
	res["created_at"] = data[15]
	res["deleted_at"] = data[16]
	res["started_at"] = data[17]
	res["done_at"] = data[18]
	res["expires_at"] = data[19]
	*m = res
	return nil
}

func (ms *ExportAttemptHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	res := make(ExportAttemptHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ExportAttemptHistory)
		m["id"] = data[0]
		m["user_id"] = data[1]
		m["account_id"] = data[2]
		m["export_type"] = data[3]
		m["filename"] = data[4]
		m["stored_file"] = data[5]
		m["download_url"] = data[6]
		m["request_query"] = data[7]
		m["mime_type"] = data[8]
		m["status"] = data[9]
		m["errors"] = data[10]
		m["error"] = data[11]
		m["n_total"] = data[12]
		m["n_exported"] = data[13]
		m["n_error"] = data[14]
		m["created_at"] = data[15]
		m["deleted_at"] = data[16]
		m["started_at"] = data[17]
		m["done_at"] = data[18]
		m["expires_at"] = data[19]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type ImportAttempts []*ImportAttempt

const __sqlImportAttempt_Table = "import_attempt"
const __sqlImportAttempt_ListCols = "\"id\",\"user_id\",\"account_id\",\"original_file\",\"stored_file\",\"type\",\"n_created\",\"n_updated\",\"n_error\",\"status\",\"error_type\",\"errors\",\"duration_ms\",\"created_at\""
const __sqlImportAttempt_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"user_id\" = EXCLUDED.\"user_id\",\"account_id\" = EXCLUDED.\"account_id\",\"original_file\" = EXCLUDED.\"original_file\",\"stored_file\" = EXCLUDED.\"stored_file\",\"type\" = EXCLUDED.\"type\",\"n_created\" = EXCLUDED.\"n_created\",\"n_updated\" = EXCLUDED.\"n_updated\",\"n_error\" = EXCLUDED.\"n_error\",\"status\" = EXCLUDED.\"status\",\"error_type\" = EXCLUDED.\"error_type\",\"errors\" = EXCLUDED.\"errors\",\"duration_ms\" = EXCLUDED.\"duration_ms\",\"created_at\" = EXCLUDED.\"created_at\""
const __sqlImportAttempt_Insert = "INSERT INTO \"import_attempt\" (" + __sqlImportAttempt_ListCols + ") VALUES"
const __sqlImportAttempt_Select = "SELECT " + __sqlImportAttempt_ListCols + " FROM \"import_attempt\""
const __sqlImportAttempt_Select_history = "SELECT " + __sqlImportAttempt_ListCols + " FROM history.\"import_attempt\""
const __sqlImportAttempt_UpdateAll = "UPDATE \"import_attempt\" SET (" + __sqlImportAttempt_ListCols + ")"
const __sqlImportAttempt_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT import_attempt_pkey DO UPDATE SET"

func (m *ImportAttempt) SQLTableName() string  { return "import_attempt" }
func (m *ImportAttempts) SQLTableName() string { return "import_attempt" }
func (m *ImportAttempt) SQLListCols() string   { return __sqlImportAttempt_ListCols }

func (m *ImportAttempt) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlImportAttempt_ListCols + " FROM \"import_attempt\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ImportAttempt) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "import_attempt"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"user_id": {
			ColumnName:       "user_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"account_id": {
			ColumnName:       "account_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"original_file": {
			ColumnName:       "original_file",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"stored_file": {
			ColumnName:       "stored_file",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"type": {
			ColumnName:       "type",
			ColumnType:       "ImportType",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_created": {
			ColumnName:       "n_created",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_updated": {
			ColumnName:       "n_updated",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"n_error": {
			ColumnName:       "n_error",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "status4.Status",
			ColumnDBType:     "enum",
			ColumnTag:        "",
			ColumnEnumValues: []string{"Z", "P", "S", "N"},
		},
		"error_type": {
			ColumnName:       "error_type",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"errors": {
			ColumnName:       "errors",
			ColumnType:       "[]*Error",
			ColumnDBType:     "[]*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"duration_ms": {
			ColumnName:       "duration_ms",
			ColumnType:       "int",
			ColumnDBType:     "int",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "import_attempt", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ImportAttempt)(nil))
}

func (m *ImportAttempt) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.UserID,
		m.AccountID,
		core.String(m.OriginalFile),
		core.String(m.StoredFile),
		core.String(m.Type),
		core.Int(m.NCreated),
		core.Int(m.NUpdated),
		core.Int(m.NError),
		m.Status,
		core.String(m.ErrorType),
		core.JSON{m.Errors},
		core.Int(m.DurationMs),
		core.Now(m.CreatedAt, now, create),
	}
}

func (m *ImportAttempt) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.UserID,
		&m.AccountID,
		(*core.String)(&m.OriginalFile),
		(*core.String)(&m.StoredFile),
		(*core.String)(&m.Type),
		(*core.Int)(&m.NCreated),
		(*core.Int)(&m.NUpdated),
		(*core.Int)(&m.NError),
		&m.Status,
		(*core.String)(&m.ErrorType),
		core.JSON{&m.Errors},
		(*core.Int)(&m.DurationMs),
		(*core.Time)(&m.CreatedAt),
	}
}

func (m *ImportAttempt) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ImportAttempts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ImportAttempts, 0, 128)
	for rows.Next() {
		m := new(ImportAttempt)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ImportAttempt) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select)
	return nil
}

func (_ *ImportAttempts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select)
	return nil
}

func (m *ImportAttempt) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ImportAttempts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(14)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ImportAttempt) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlImportAttempt_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlImportAttempt_ListColsOnConflict)
	return nil
}

func (ms ImportAttempts) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlImportAttempt_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlImportAttempt_ListColsOnConflict)
	return nil
}

func (m *ImportAttempt) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("import_attempt")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.OriginalFile != "" {
		flag = true
		w.WriteName("original_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OriginalFile)
	}
	if m.StoredFile != "" {
		flag = true
		w.WriteName("stored_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StoredFile)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.Type))
	}
	if m.NCreated != 0 {
		flag = true
		w.WriteName("n_created")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NCreated)
	}
	if m.NUpdated != 0 {
		flag = true
		w.WriteName("n_updated")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NUpdated)
	}
	if m.NError != 0 {
		flag = true
		w.WriteName("n_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NError)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.ErrorType != "" {
		flag = true
		w.WriteName("error_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ErrorType)
	}
	if m.Errors != nil {
		flag = true
		w.WriteName("errors")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Errors})
	}
	if m.DurationMs != 0 {
		flag = true
		w.WriteName("duration_ms")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DurationMs)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ImportAttempt) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ImportAttemptHistory map[string]interface{}
type ImportAttemptHistories []map[string]interface{}

func (m *ImportAttemptHistory) SQLTableName() string  { return "history.\"import_attempt\"" }
func (m ImportAttemptHistories) SQLTableName() string { return "history.\"import_attempt\"" }

func (m *ImportAttemptHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select_history)
	return nil
}

func (m ImportAttemptHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select_history)
	return nil
}

func (m ImportAttemptHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m ImportAttemptHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m ImportAttemptHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m ImportAttemptHistory) OriginalFile() core.Interface {
	return core.Interface{m["original_file"]}
}
func (m ImportAttemptHistory) StoredFile() core.Interface { return core.Interface{m["stored_file"]} }
func (m ImportAttemptHistory) Type() core.Interface       { return core.Interface{m["type"]} }
func (m ImportAttemptHistory) NCreated() core.Interface   { return core.Interface{m["n_created"]} }
func (m ImportAttemptHistory) NUpdated() core.Interface   { return core.Interface{m["n_updated"]} }
func (m ImportAttemptHistory) NError() core.Interface     { return core.Interface{m["n_error"]} }
func (m ImportAttemptHistory) Status() core.Interface     { return core.Interface{m["status"]} }
func (m ImportAttemptHistory) ErrorType() core.Interface  { return core.Interface{m["error_type"]} }
func (m ImportAttemptHistory) Errors() core.Interface     { return core.Interface{m["errors"]} }
func (m ImportAttemptHistory) DurationMs() core.Interface { return core.Interface{m["duration_ms"]} }
func (m ImportAttemptHistory) CreatedAt() core.Interface  { return core.Interface{m["created_at"]} }

func (m *ImportAttemptHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ImportAttemptHistory, 14)
	res["id"] = data[0]
	res["user_id"] = data[1]
	res["account_id"] = data[2]
	res["original_file"] = data[3]
	res["stored_file"] = data[4]
	res["type"] = data[5]
	res["n_created"] = data[6]
	res["n_updated"] = data[7]
	res["n_error"] = data[8]
	res["status"] = data[9]
	res["error_type"] = data[10]
	res["errors"] = data[11]
	res["duration_ms"] = data[12]
	res["created_at"] = data[13]
	*m = res
	return nil
}

func (ms *ImportAttemptHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	res := make(ImportAttemptHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ImportAttemptHistory)
		m["id"] = data[0]
		m["user_id"] = data[1]
		m["account_id"] = data[2]
		m["original_file"] = data[3]
		m["stored_file"] = data[4]
		m["type"] = data[5]
		m["n_created"] = data[6]
		m["n_updated"] = data[7]
		m["n_error"] = data[8]
		m["status"] = data[9]
		m["error_type"] = data[10]
		m["errors"] = data[11]
		m["duration_ms"] = data[12]
		m["created_at"] = data[13]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type ShippingSources []*ShippingSource

const __sqlShippingSource_Table = "shipping_source"
const __sqlShippingSource_ListCols = "\"id\",\"name\",\"username\",\"type\",\"created_at\",\"updated_at\""
const __sqlShippingSource_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"name\" = EXCLUDED.\"name\",\"username\" = EXCLUDED.\"username\",\"type\" = EXCLUDED.\"type\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlShippingSource_Insert = "INSERT INTO \"shipping_source\" (" + __sqlShippingSource_ListCols + ") VALUES"
const __sqlShippingSource_Select = "SELECT " + __sqlShippingSource_ListCols + " FROM \"shipping_source\""
const __sqlShippingSource_Select_history = "SELECT " + __sqlShippingSource_ListCols + " FROM history.\"shipping_source\""
const __sqlShippingSource_UpdateAll = "UPDATE \"shipping_source\" SET (" + __sqlShippingSource_ListCols + ")"
const __sqlShippingSource_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shipping_source_pkey DO UPDATE SET"

func (m *ShippingSource) SQLTableName() string  { return "shipping_source" }
func (m *ShippingSources) SQLTableName() string { return "shipping_source" }
func (m *ShippingSource) SQLListCols() string   { return __sqlShippingSource_ListCols }

func (m *ShippingSource) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShippingSource_ListCols + " FROM \"shipping_source\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ShippingSource) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "shipping_source"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"name": {
			ColumnName:       "name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"username": {
			ColumnName:       "username",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"type": {
			ColumnName:       "type",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "shipping_source", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShippingSource)(nil))
}

func (m *ShippingSource) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Name),
		core.String(m.Username),
		core.String(m.Type),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *ShippingSource) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		(*core.String)(&m.Username),
		(*core.String)(&m.Type),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *ShippingSource) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShippingSources) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShippingSources, 0, 128)
	for rows.Next() {
		m := new(ShippingSource)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShippingSource) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select)
	return nil
}

func (_ *ShippingSources) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select)
	return nil
}

func (m *ShippingSource) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShippingSources) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(6)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShippingSource) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShippingSource_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShippingSource_ListColsOnConflict)
	return nil
}

func (ms ShippingSources) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShippingSource_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShippingSource_ListColsOnConflict)
	return nil
}

func (m *ShippingSource) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shipping_source")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Username != "" {
		flag = true
		w.WriteName("username")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Username)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if true { // always update time
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShippingSource) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShippingSourceHistory map[string]interface{}
type ShippingSourceHistories []map[string]interface{}

func (m *ShippingSourceHistory) SQLTableName() string  { return "history.\"shipping_source\"" }
func (m ShippingSourceHistories) SQLTableName() string { return "history.\"shipping_source\"" }

func (m *ShippingSourceHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select_history)
	return nil
}

func (m ShippingSourceHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select_history)
	return nil
}

func (m ShippingSourceHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m ShippingSourceHistory) Name() core.Interface      { return core.Interface{m["name"]} }
func (m ShippingSourceHistory) Username() core.Interface  { return core.Interface{m["username"]} }
func (m ShippingSourceHistory) Type() core.Interface      { return core.Interface{m["type"]} }
func (m ShippingSourceHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m ShippingSourceHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *ShippingSourceHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShippingSourceHistory, 6)
	res["id"] = data[0]
	res["name"] = data[1]
	res["username"] = data[2]
	res["type"] = data[3]
	res["created_at"] = data[4]
	res["updated_at"] = data[5]
	*m = res
	return nil
}

func (ms *ShippingSourceHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	res := make(ShippingSourceHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShippingSourceHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["username"] = data[2]
		m["type"] = data[3]
		m["created_at"] = data[4]
		m["updated_at"] = data[5]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type ShippingSourceInternals []*ShippingSourceInternal

const __sqlShippingSourceInternal_Table = "shipping_source_internal"
const __sqlShippingSourceInternal_ListCols = "\"id\",\"created_at\",\"updated_at\",\"last_sync_at\",\"access_token\",\"expires_at\",\"secret\""
const __sqlShippingSourceInternal_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\",\"last_sync_at\" = EXCLUDED.\"last_sync_at\",\"access_token\" = EXCLUDED.\"access_token\",\"expires_at\" = EXCLUDED.\"expires_at\",\"secret\" = EXCLUDED.\"secret\""
const __sqlShippingSourceInternal_Insert = "INSERT INTO \"shipping_source_internal\" (" + __sqlShippingSourceInternal_ListCols + ") VALUES"
const __sqlShippingSourceInternal_Select = "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM \"shipping_source_internal\""
const __sqlShippingSourceInternal_Select_history = "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM history.\"shipping_source_internal\""
const __sqlShippingSourceInternal_UpdateAll = "UPDATE \"shipping_source_internal\" SET (" + __sqlShippingSourceInternal_ListCols + ")"
const __sqlShippingSourceInternal_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT shipping_source_internal_pkey DO UPDATE SET"

func (m *ShippingSourceInternal) SQLTableName() string  { return "shipping_source_internal" }
func (m *ShippingSourceInternals) SQLTableName() string { return "shipping_source_internal" }
func (m *ShippingSourceInternal) SQLListCols() string   { return __sqlShippingSourceInternal_ListCols }

func (m *ShippingSourceInternal) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM \"shipping_source_internal\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *ShippingSourceInternal) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "shipping_source_internal"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"last_sync_at": {
			ColumnName:       "last_sync_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"access_token": {
			ColumnName:       "access_token",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"expires_at": {
			ColumnName:       "expires_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"secret": {
			ColumnName:       "secret",
			ColumnType:       "*ShippingSourceSecret",
			ColumnDBType:     "*struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "shipping_source_internal", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShippingSourceInternal)(nil))
}

func (m *ShippingSourceInternal) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.LastSyncAt),
		core.String(m.AccessToken),
		core.Time(m.ExpiresAt),
		core.JSON{m.Secret},
	}
}

func (m *ShippingSourceInternal) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.LastSyncAt),
		(*core.String)(&m.AccessToken),
		(*core.Time)(&m.ExpiresAt),
		core.JSON{&m.Secret},
	}
}

func (m *ShippingSourceInternal) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShippingSourceInternals) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShippingSourceInternals, 0, 128)
	for rows.Next() {
		m := new(ShippingSourceInternal)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShippingSourceInternal) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select)
	return nil
}

func (_ *ShippingSourceInternals) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select)
	return nil
}

func (m *ShippingSourceInternal) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShippingSourceInternals) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(7)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShippingSourceInternal) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlShippingSourceInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShippingSourceInternal_ListColsOnConflict)
	return nil
}

func (ms ShippingSourceInternals) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlShippingSourceInternal_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlShippingSourceInternal_ListColsOnConflict)
	return nil
}

func (m *ShippingSourceInternal) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shipping_source_internal")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if true { // always update time
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.LastSyncAt.IsZero() {
		flag = true
		w.WriteName("last_sync_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.LastSyncAt)
	}
	if m.AccessToken != "" {
		flag = true
		w.WriteName("access_token")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccessToken)
	}
	if !m.ExpiresAt.IsZero() {
		flag = true
		w.WriteName("expires_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExpiresAt)
	}
	if m.Secret != nil {
		flag = true
		w.WriteName("secret")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Secret})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShippingSourceInternal) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShippingSourceInternalHistory map[string]interface{}
type ShippingSourceInternalHistories []map[string]interface{}

func (m *ShippingSourceInternalHistory) SQLTableName() string {
	return "history.\"shipping_source_internal\""
}
func (m ShippingSourceInternalHistories) SQLTableName() string {
	return "history.\"shipping_source_internal\""
}

func (m *ShippingSourceInternalHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select_history)
	return nil
}

func (m ShippingSourceInternalHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select_history)
	return nil
}

func (m ShippingSourceInternalHistory) ID() core.Interface { return core.Interface{m["id"]} }
func (m ShippingSourceInternalHistory) CreatedAt() core.Interface {
	return core.Interface{m["created_at"]}
}
func (m ShippingSourceInternalHistory) UpdatedAt() core.Interface {
	return core.Interface{m["updated_at"]}
}
func (m ShippingSourceInternalHistory) LastSyncAt() core.Interface {
	return core.Interface{m["last_sync_at"]}
}
func (m ShippingSourceInternalHistory) AccessToken() core.Interface {
	return core.Interface{m["access_token"]}
}
func (m ShippingSourceInternalHistory) ExpiresAt() core.Interface {
	return core.Interface{m["expires_at"]}
}
func (m ShippingSourceInternalHistory) Secret() core.Interface { return core.Interface{m["secret"]} }

func (m *ShippingSourceInternalHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShippingSourceInternalHistory, 7)
	res["id"] = data[0]
	res["created_at"] = data[1]
	res["updated_at"] = data[2]
	res["last_sync_at"] = data[3]
	res["access_token"] = data[4]
	res["expires_at"] = data[5]
	res["secret"] = data[6]
	*m = res
	return nil
}

func (ms *ShippingSourceInternalHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	res := make(ShippingSourceInternalHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShippingSourceInternalHistory)
		m["id"] = data[0]
		m["created_at"] = data[1]
		m["updated_at"] = data[2]
		m["last_sync_at"] = data[3]
		m["access_token"] = data[4]
		m["expires_at"] = data[5]
		m["secret"] = data[6]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
