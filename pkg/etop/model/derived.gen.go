// Code generated by goderive DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	"time"

	"etop.vn/backend/pkg/common/cmsql"
	sq "etop.vn/backend/pkg/common/sq"
	core "etop.vn/backend/pkg/common/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

// Type ImportAttempt represents table import_attempt
func sqlgenImportAttempt(_ *ImportAttempt) bool { return true }

type ImportAttempts []*ImportAttempt

const __sqlImportAttempt_Table = "import_attempt"
const __sqlImportAttempt_ListCols = "\"id\",\"user_id\",\"account_id\",\"original_file\",\"stored_file\",\"type\",\"n_created\",\"n_updated\",\"n_error\",\"status\",\"error_type\",\"errors\",\"duration_ms\",\"created_at\""
const __sqlImportAttempt_Insert = "INSERT INTO \"import_attempt\" (" + __sqlImportAttempt_ListCols + ") VALUES"
const __sqlImportAttempt_Select = "SELECT " + __sqlImportAttempt_ListCols + " FROM \"import_attempt\""
const __sqlImportAttempt_Select_history = "SELECT " + __sqlImportAttempt_ListCols + " FROM history.\"import_attempt\""
const __sqlImportAttempt_UpdateAll = "UPDATE \"import_attempt\" SET (" + __sqlImportAttempt_ListCols + ")"

func (m *ImportAttempt) SQLTableName() string  { return "import_attempt" }
func (m *ImportAttempts) SQLTableName() string { return "import_attempt" }
func (m *ImportAttempt) SQLListCols() string   { return __sqlImportAttempt_ListCols }

func (m *ImportAttempt) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlImportAttempt_ListCols + " FROM \"import_attempt\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ImportAttempt)(nil))
}

func (m *ImportAttempt) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.UserID,
		m.AccountID,
		core.String(m.OriginalFile),
		core.String(m.StoredFile),
		core.String(m.Type),
		core.Int(m.NCreated),
		core.Int(m.NUpdated),
		core.Int(m.NError),
		m.Status,
		core.String(m.ErrorType),
		core.JSON{m.Errors},
		core.Int(m.DurationMs),
		core.Now(m.CreatedAt, now, create),
	}
}

func (m *ImportAttempt) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.UserID,
		&m.AccountID,
		(*core.String)(&m.OriginalFile),
		(*core.String)(&m.StoredFile),
		(*core.String)(&m.Type),
		(*core.Int)(&m.NCreated),
		(*core.Int)(&m.NUpdated),
		(*core.Int)(&m.NError),
		&m.Status,
		(*core.String)(&m.ErrorType),
		core.JSON{&m.Errors},
		(*core.Int)(&m.DurationMs),
		(*core.Time)(&m.CreatedAt),
	}
}

func (m *ImportAttempt) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ImportAttempts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ImportAttempts, 0, 128)
	for rows.Next() {
		m := new(ImportAttempt)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ImportAttempt) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select)
	return nil
}

func (_ *ImportAttempts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select)
	return nil
}

func (m *ImportAttempt) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ImportAttempts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(14)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ImportAttempt) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("import_attempt")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.OriginalFile != "" {
		flag = true
		w.WriteName("original_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OriginalFile)
	}
	if m.StoredFile != "" {
		flag = true
		w.WriteName("stored_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StoredFile)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.Type))
	}
	if m.NCreated != 0 {
		flag = true
		w.WriteName("n_created")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NCreated)
	}
	if m.NUpdated != 0 {
		flag = true
		w.WriteName("n_updated")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NUpdated)
	}
	if m.NError != 0 {
		flag = true
		w.WriteName("n_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NError)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.ErrorType != "" {
		flag = true
		w.WriteName("error_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ErrorType)
	}
	if m.Errors != nil {
		flag = true
		w.WriteName("errors")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Errors})
	}
	if m.DurationMs != 0 {
		flag = true
		w.WriteName("duration_ms")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DurationMs)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ImportAttempt) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(14)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ImportAttemptHistory map[string]interface{}
type ImportAttemptHistories []map[string]interface{}

func (m *ImportAttemptHistory) SQLTableName() string  { return "history.\"import_attempt\"" }
func (m ImportAttemptHistories) SQLTableName() string { return "history.\"import_attempt\"" }

func (m *ImportAttemptHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select_history)
	return nil
}

func (m ImportAttemptHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlImportAttempt_Select_history)
	return nil
}

func (m ImportAttemptHistory) ID() core.Interface           { return core.Interface{m["id"]} }
func (m ImportAttemptHistory) UserID() core.Interface       { return core.Interface{m["user_id"]} }
func (m ImportAttemptHistory) AccountID() core.Interface    { return core.Interface{m["account_id"]} }
func (m ImportAttemptHistory) OriginalFile() core.Interface { return core.Interface{m["original_file"]} }
func (m ImportAttemptHistory) StoredFile() core.Interface   { return core.Interface{m["stored_file"]} }
func (m ImportAttemptHistory) Type() core.Interface         { return core.Interface{m["type"]} }
func (m ImportAttemptHistory) NCreated() core.Interface     { return core.Interface{m["n_created"]} }
func (m ImportAttemptHistory) NUpdated() core.Interface     { return core.Interface{m["n_updated"]} }
func (m ImportAttemptHistory) NError() core.Interface       { return core.Interface{m["n_error"]} }
func (m ImportAttemptHistory) Status() core.Interface       { return core.Interface{m["status"]} }
func (m ImportAttemptHistory) ErrorType() core.Interface    { return core.Interface{m["error_type"]} }
func (m ImportAttemptHistory) Errors() core.Interface       { return core.Interface{m["errors"]} }
func (m ImportAttemptHistory) DurationMs() core.Interface   { return core.Interface{m["duration_ms"]} }
func (m ImportAttemptHistory) CreatedAt() core.Interface    { return core.Interface{m["created_at"]} }

func (m *ImportAttemptHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ImportAttemptHistory, 14)
	res["id"] = data[0]
	res["user_id"] = data[1]
	res["account_id"] = data[2]
	res["original_file"] = data[3]
	res["stored_file"] = data[4]
	res["type"] = data[5]
	res["n_created"] = data[6]
	res["n_updated"] = data[7]
	res["n_error"] = data[8]
	res["status"] = data[9]
	res["error_type"] = data[10]
	res["errors"] = data[11]
	res["duration_ms"] = data[12]
	res["created_at"] = data[13]
	*m = res
	return nil
}

func (ms *ImportAttemptHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 14)
	args := make([]interface{}, 14)
	for i := 0; i < 14; i++ {
		args[i] = &data[i]
	}
	res := make(ImportAttemptHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ImportAttemptHistory)
		m["id"] = data[0]
		m["user_id"] = data[1]
		m["account_id"] = data[2]
		m["original_file"] = data[3]
		m["stored_file"] = data[4]
		m["type"] = data[5]
		m["n_created"] = data[6]
		m["n_updated"] = data[7]
		m["n_error"] = data[8]
		m["status"] = data[9]
		m["error_type"] = data[10]
		m["errors"] = data[11]
		m["duration_ms"] = data[12]
		m["created_at"] = data[13]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type ExportAttempt represents table export_attempt
func sqlgenExportAttempt(_ *ExportAttempt) bool { return true }

type ExportAttempts []*ExportAttempt

const __sqlExportAttempt_Table = "export_attempt"
const __sqlExportAttempt_ListCols = "\"id\",\"user_id\",\"account_id\",\"export_type\",\"filename\",\"stored_file\",\"download_url\",\"request_query\",\"mime_type\",\"status\",\"errors\",\"error\",\"n_total\",\"n_exported\",\"n_error\",\"created_at\",\"deleted_at\",\"started_at\",\"done_at\",\"expires_at\""
const __sqlExportAttempt_Insert = "INSERT INTO \"export_attempt\" (" + __sqlExportAttempt_ListCols + ") VALUES"
const __sqlExportAttempt_Select = "SELECT " + __sqlExportAttempt_ListCols + " FROM \"export_attempt\""
const __sqlExportAttempt_Select_history = "SELECT " + __sqlExportAttempt_ListCols + " FROM history.\"export_attempt\""
const __sqlExportAttempt_UpdateAll = "UPDATE \"export_attempt\" SET (" + __sqlExportAttempt_ListCols + ")"

func (m *ExportAttempt) SQLTableName() string  { return "export_attempt" }
func (m *ExportAttempts) SQLTableName() string { return "export_attempt" }
func (m *ExportAttempt) SQLListCols() string   { return __sqlExportAttempt_ListCols }

func (m *ExportAttempt) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlExportAttempt_ListCols + " FROM \"export_attempt\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ExportAttempt)(nil))
}

func (m *ExportAttempt) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.ID),
		m.UserID,
		m.AccountID,
		core.String(m.ExportType),
		core.String(m.FileName),
		core.String(m.StoredFile),
		core.String(m.DownloadURL),
		core.String(m.RequestQuery),
		core.String(m.MimeType),
		m.Status,
		core.JSON{m.Errors},
		core.JSON{m.Error},
		core.Int(m.NTotal),
		core.Int(m.NExported),
		core.Int(m.NError),
		core.Now(m.CreatedAt, now, create),
		core.Time(m.DeletedAt),
		core.Time(m.StartedAt),
		core.Time(m.DoneAt),
		core.Time(m.ExpiresAt),
	}
}

func (m *ExportAttempt) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		&m.UserID,
		&m.AccountID,
		(*core.String)(&m.ExportType),
		(*core.String)(&m.FileName),
		(*core.String)(&m.StoredFile),
		(*core.String)(&m.DownloadURL),
		(*core.String)(&m.RequestQuery),
		(*core.String)(&m.MimeType),
		&m.Status,
		core.JSON{&m.Errors},
		core.JSON{&m.Error},
		(*core.Int)(&m.NTotal),
		(*core.Int)(&m.NExported),
		(*core.Int)(&m.NError),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.DeletedAt),
		(*core.Time)(&m.StartedAt),
		(*core.Time)(&m.DoneAt),
		(*core.Time)(&m.ExpiresAt),
	}
}

func (m *ExportAttempt) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ExportAttempts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ExportAttempts, 0, 128)
	for rows.Next() {
		m := new(ExportAttempt)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ExportAttempt) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select)
	return nil
}

func (_ *ExportAttempts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select)
	return nil
}

func (m *ExportAttempt) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ExportAttempts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(20)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ExportAttempt) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("export_attempt")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.ExportType != "" {
		flag = true
		w.WriteName("export_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExportType)
	}
	if m.FileName != "" {
		flag = true
		w.WriteName("filename")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FileName)
	}
	if m.StoredFile != "" {
		flag = true
		w.WriteName("stored_file")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StoredFile)
	}
	if m.DownloadURL != "" {
		flag = true
		w.WriteName("download_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DownloadURL)
	}
	if m.RequestQuery != "" {
		flag = true
		w.WriteName("request_query")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RequestQuery)
	}
	if m.MimeType != "" {
		flag = true
		w.WriteName("mime_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.MimeType)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.Errors != nil {
		flag = true
		w.WriteName("errors")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Errors})
	}
	if m.Error != nil {
		flag = true
		w.WriteName("error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Error})
	}
	if m.NTotal != 0 {
		flag = true
		w.WriteName("n_total")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NTotal)
	}
	if m.NExported != 0 {
		flag = true
		w.WriteName("n_exported")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NExported)
	}
	if m.NError != 0 {
		flag = true
		w.WriteName("n_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NError)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !m.StartedAt.IsZero() {
		flag = true
		w.WriteName("started_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.StartedAt)
	}
	if !m.DoneAt.IsZero() {
		flag = true
		w.WriteName("done_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DoneAt)
	}
	if !m.ExpiresAt.IsZero() {
		flag = true
		w.WriteName("expires_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExpiresAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ExportAttempt) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(20)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ExportAttemptHistory map[string]interface{}
type ExportAttemptHistories []map[string]interface{}

func (m *ExportAttemptHistory) SQLTableName() string  { return "history.\"export_attempt\"" }
func (m ExportAttemptHistories) SQLTableName() string { return "history.\"export_attempt\"" }

func (m *ExportAttemptHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select_history)
	return nil
}

func (m ExportAttemptHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlExportAttempt_Select_history)
	return nil
}

func (m ExportAttemptHistory) ID() core.Interface           { return core.Interface{m["id"]} }
func (m ExportAttemptHistory) UserID() core.Interface       { return core.Interface{m["user_id"]} }
func (m ExportAttemptHistory) AccountID() core.Interface    { return core.Interface{m["account_id"]} }
func (m ExportAttemptHistory) ExportType() core.Interface   { return core.Interface{m["export_type"]} }
func (m ExportAttemptHistory) FileName() core.Interface     { return core.Interface{m["filename"]} }
func (m ExportAttemptHistory) StoredFile() core.Interface   { return core.Interface{m["stored_file"]} }
func (m ExportAttemptHistory) DownloadURL() core.Interface  { return core.Interface{m["download_url"]} }
func (m ExportAttemptHistory) RequestQuery() core.Interface { return core.Interface{m["request_query"]} }
func (m ExportAttemptHistory) MimeType() core.Interface     { return core.Interface{m["mime_type"]} }
func (m ExportAttemptHistory) Status() core.Interface       { return core.Interface{m["status"]} }
func (m ExportAttemptHistory) Errors() core.Interface       { return core.Interface{m["errors"]} }
func (m ExportAttemptHistory) Error() core.Interface        { return core.Interface{m["error"]} }
func (m ExportAttemptHistory) NTotal() core.Interface       { return core.Interface{m["n_total"]} }
func (m ExportAttemptHistory) NExported() core.Interface    { return core.Interface{m["n_exported"]} }
func (m ExportAttemptHistory) NError() core.Interface       { return core.Interface{m["n_error"]} }
func (m ExportAttemptHistory) CreatedAt() core.Interface    { return core.Interface{m["created_at"]} }
func (m ExportAttemptHistory) DeletedAt() core.Interface    { return core.Interface{m["deleted_at"]} }
func (m ExportAttemptHistory) StartedAt() core.Interface    { return core.Interface{m["started_at"]} }
func (m ExportAttemptHistory) DoneAt() core.Interface       { return core.Interface{m["done_at"]} }
func (m ExportAttemptHistory) ExpiresAt() core.Interface    { return core.Interface{m["expires_at"]} }

func (m *ExportAttemptHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ExportAttemptHistory, 20)
	res["id"] = data[0]
	res["user_id"] = data[1]
	res["account_id"] = data[2]
	res["export_type"] = data[3]
	res["filename"] = data[4]
	res["stored_file"] = data[5]
	res["download_url"] = data[6]
	res["request_query"] = data[7]
	res["mime_type"] = data[8]
	res["status"] = data[9]
	res["errors"] = data[10]
	res["error"] = data[11]
	res["n_total"] = data[12]
	res["n_exported"] = data[13]
	res["n_error"] = data[14]
	res["created_at"] = data[15]
	res["deleted_at"] = data[16]
	res["started_at"] = data[17]
	res["done_at"] = data[18]
	res["expires_at"] = data[19]
	*m = res
	return nil
}

func (ms *ExportAttemptHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 20)
	args := make([]interface{}, 20)
	for i := 0; i < 20; i++ {
		args[i] = &data[i]
	}
	res := make(ExportAttemptHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ExportAttemptHistory)
		m["id"] = data[0]
		m["user_id"] = data[1]
		m["account_id"] = data[2]
		m["export_type"] = data[3]
		m["filename"] = data[4]
		m["stored_file"] = data[5]
		m["download_url"] = data[6]
		m["request_query"] = data[7]
		m["mime_type"] = data[8]
		m["status"] = data[9]
		m["errors"] = data[10]
		m["error"] = data[11]
		m["n_total"] = data[12]
		m["n_exported"] = data[13]
		m["n_error"] = data[14]
		m["created_at"] = data[15]
		m["deleted_at"] = data[16]
		m["started_at"] = data[17]
		m["done_at"] = data[18]
		m["expires_at"] = data[19]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Account represents table account
func sqlgenAccount(_ *Account) bool { return true }

type Accounts []*Account

const __sqlAccount_Table = "account"
const __sqlAccount_ListCols = "\"id\",\"owner_id\",\"name\",\"type\",\"image_url\",\"url_slug\""
const __sqlAccount_Insert = "INSERT INTO \"account\" (" + __sqlAccount_ListCols + ") VALUES"
const __sqlAccount_Select = "SELECT " + __sqlAccount_ListCols + " FROM \"account\""
const __sqlAccount_Select_history = "SELECT " + __sqlAccount_ListCols + " FROM history.\"account\""
const __sqlAccount_UpdateAll = "UPDATE \"account\" SET (" + __sqlAccount_ListCols + ")"

func (m *Account) SQLTableName() string  { return "account" }
func (m *Accounts) SQLTableName() string { return "account" }
func (m *Account) SQLListCols() string   { return __sqlAccount_ListCols }

func (m *Account) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccount_ListCols + " FROM \"account\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Account)(nil))
}

func (m *Account) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		m.ID,
		m.OwnerID,
		core.String(m.Name),
		m.Type,
		core.String(m.ImageURL),
		core.String(m.URLSlug),
	}
}

func (m *Account) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		(*core.String)(&m.Name),
		&m.Type,
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.URLSlug),
	}
}

func (m *Account) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Accounts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Accounts, 0, 128)
	for rows.Next() {
		m := new(Account)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Account) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (_ *Accounts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select)
	return nil
}

func (m *Account) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Accounts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(6)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Account) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Type != 0 {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.URLSlug != "" {
		flag = true
		w.WriteName("url_slug")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.URLSlug)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Account) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountHistory map[string]interface{}
type AccountHistories []map[string]interface{}

func (m *AccountHistory) SQLTableName() string  { return "history.\"account\"" }
func (m AccountHistories) SQLTableName() string { return "history.\"account\"" }

func (m *AccountHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccount_Select_history)
	return nil
}

func (m AccountHistory) ID() core.Interface       { return core.Interface{m["id"]} }
func (m AccountHistory) OwnerID() core.Interface  { return core.Interface{m["owner_id"]} }
func (m AccountHistory) Name() core.Interface     { return core.Interface{m["name"]} }
func (m AccountHistory) Type() core.Interface     { return core.Interface{m["type"]} }
func (m AccountHistory) ImageURL() core.Interface { return core.Interface{m["image_url"]} }
func (m AccountHistory) URLSlug() core.Interface  { return core.Interface{m["url_slug"]} }

func (m *AccountHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountHistory, 6)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["name"] = data[2]
	res["type"] = data[3]
	res["image_url"] = data[4]
	res["url_slug"] = data[5]
	*m = res
	return nil
}

func (ms *AccountHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	res := make(AccountHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["name"] = data[2]
		m["type"] = data[3]
		m["image_url"] = data[4]
		m["url_slug"] = data[5]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Shop represents table shop
func sqlgenShop(_ *Shop) bool { return true }

type Shops []*Shop

const __sqlShop_Table = "shop"
const __sqlShop_ListCols = "\"id\",\"name\",\"owner_id\",\"is_test\",\"address_id\",\"ship_to_address_id\",\"ship_from_address_id\",\"phone\",\"bank_account\",\"website_url\",\"image_url\",\"email\",\"code\",\"auto_create_ffm\",\"order_source_id\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"recognized_hosts\",\"ghn_note_code\",\"try_on\",\"company_info\",\"money_transaction_rrule\",\"survey_info\",\"shipping_service_select_strategy\",\"inventory_overstock\""
const __sqlShop_Insert = "INSERT INTO \"shop\" (" + __sqlShop_ListCols + ") VALUES"
const __sqlShop_Select = "SELECT " + __sqlShop_ListCols + " FROM \"shop\""
const __sqlShop_Select_history = "SELECT " + __sqlShop_ListCols + " FROM history.\"shop\""
const __sqlShop_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShop_ListCols + ")"

func (m *Shop) SQLTableName() string  { return "shop" }
func (m *Shops) SQLTableName() string { return "shop" }
func (m *Shop) SQLListCols() string   { return __sqlShop_ListCols }

func (m *Shop) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShop_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Shop)(nil))
}

func (m *Shop) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Name),
		m.OwnerID,
		core.Int(m.IsTest),
		m.AddressID,
		m.ShipToAddressID,
		m.ShipFromAddressID,
		core.String(m.Phone),
		core.JSON{m.BankAccount},
		core.String(m.WebsiteURL),
		core.String(m.ImageURL),
		core.String(m.Email),
		core.String(m.Code),
		core.Bool(m.AutoCreateFFM),
		m.OrderSourceID,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.RecognizedHosts, opts},
		m.GhnNoteCode,
		m.TryOn,
		core.JSON{m.CompanyInfo},
		core.String(m.MoneyTransactionRRule),
		core.JSON{m.SurveyInfo},
		core.JSON{m.ShippingServiceSelectStrategy},
		m.InventoryOverstock,
	}
}

func (m *Shop) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		&m.OwnerID,
		(*core.Int)(&m.IsTest),
		&m.AddressID,
		&m.ShipToAddressID,
		&m.ShipFromAddressID,
		(*core.String)(&m.Phone),
		core.JSON{&m.BankAccount},
		(*core.String)(&m.WebsiteURL),
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.Email),
		(*core.String)(&m.Code),
		(*core.Bool)(&m.AutoCreateFFM),
		&m.OrderSourceID,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.RecognizedHosts, opts},
		&m.GhnNoteCode,
		&m.TryOn,
		core.JSON{&m.CompanyInfo},
		(*core.String)(&m.MoneyTransactionRRule),
		core.JSON{&m.SurveyInfo},
		core.JSON{&m.ShippingServiceSelectStrategy},
		&m.InventoryOverstock,
	}
}

func (m *Shop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Shops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Shops, 0, 128)
	for rows.Next() {
		m := new(Shop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Shop) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (_ *Shops) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select)
	return nil
}

func (m *Shop) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(27)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Shops) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(27)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Shop) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.AddressID != 0 {
		flag = true
		w.WriteName("address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AddressID)
	}
	if m.ShipToAddressID != 0 {
		flag = true
		w.WriteName("ship_to_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipToAddressID)
	}
	if m.ShipFromAddressID != 0 {
		flag = true
		w.WriteName("ship_from_address_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShipFromAddressID)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.BankAccount != nil {
		flag = true
		w.WriteName("bank_account")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.BankAccount})
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.AutoCreateFFM {
		flag = true
		w.WriteName("auto_create_ffm")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AutoCreateFFM)
	}
	if m.OrderSourceID != 0 {
		flag = true
		w.WriteName("order_source_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OrderSourceID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.GhnNoteCode != 0 {
		flag = true
		w.WriteName("ghn_note_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.GhnNoteCode)
	}
	if m.TryOn != 0 {
		flag = true
		w.WriteName("try_on")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TryOn)
	}
	if m.CompanyInfo != nil {
		flag = true
		w.WriteName("company_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.CompanyInfo})
	}
	if m.MoneyTransactionRRule != "" {
		flag = true
		w.WriteName("money_transaction_rrule")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.MoneyTransactionRRule)
	}
	if m.SurveyInfo != nil {
		flag = true
		w.WriteName("survey_info")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.SurveyInfo})
	}
	if m.ShippingServiceSelectStrategy != nil {
		flag = true
		w.WriteName("shipping_service_select_strategy")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ShippingServiceSelectStrategy})
	}
	if m.InventoryOverstock.Valid {
		flag = true
		w.WriteName("inventory_overstock")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InventoryOverstock)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Shop) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(27)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopHistory map[string]interface{}
type ShopHistories []map[string]interface{}

func (m *ShopHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShop_Select_history)
	return nil
}

func (m ShopHistory) ID() core.Interface              { return core.Interface{m["id"]} }
func (m ShopHistory) Name() core.Interface            { return core.Interface{m["name"]} }
func (m ShopHistory) OwnerID() core.Interface         { return core.Interface{m["owner_id"]} }
func (m ShopHistory) IsTest() core.Interface          { return core.Interface{m["is_test"]} }
func (m ShopHistory) AddressID() core.Interface       { return core.Interface{m["address_id"]} }
func (m ShopHistory) ShipToAddressID() core.Interface { return core.Interface{m["ship_to_address_id"]} }
func (m ShopHistory) ShipFromAddressID() core.Interface {
	return core.Interface{m["ship_from_address_id"]}
}
func (m ShopHistory) Phone() core.Interface           { return core.Interface{m["phone"]} }
func (m ShopHistory) BankAccount() core.Interface     { return core.Interface{m["bank_account"]} }
func (m ShopHistory) WebsiteURL() core.Interface      { return core.Interface{m["website_url"]} }
func (m ShopHistory) ImageURL() core.Interface        { return core.Interface{m["image_url"]} }
func (m ShopHistory) Email() core.Interface           { return core.Interface{m["email"]} }
func (m ShopHistory) Code() core.Interface            { return core.Interface{m["code"]} }
func (m ShopHistory) AutoCreateFFM() core.Interface   { return core.Interface{m["auto_create_ffm"]} }
func (m ShopHistory) OrderSourceID() core.Interface   { return core.Interface{m["order_source_id"]} }
func (m ShopHistory) Status() core.Interface          { return core.Interface{m["status"]} }
func (m ShopHistory) CreatedAt() core.Interface       { return core.Interface{m["created_at"]} }
func (m ShopHistory) UpdatedAt() core.Interface       { return core.Interface{m["updated_at"]} }
func (m ShopHistory) DeletedAt() core.Interface       { return core.Interface{m["deleted_at"]} }
func (m ShopHistory) RecognizedHosts() core.Interface { return core.Interface{m["recognized_hosts"]} }
func (m ShopHistory) GhnNoteCode() core.Interface     { return core.Interface{m["ghn_note_code"]} }
func (m ShopHistory) TryOn() core.Interface           { return core.Interface{m["try_on"]} }
func (m ShopHistory) CompanyInfo() core.Interface     { return core.Interface{m["company_info"]} }
func (m ShopHistory) MoneyTransactionRRule() core.Interface {
	return core.Interface{m["money_transaction_rrule"]}
}
func (m ShopHistory) SurveyInfo() core.Interface { return core.Interface{m["survey_info"]} }
func (m ShopHistory) ShippingServiceSelectStrategy() core.Interface {
	return core.Interface{m["shipping_service_select_strategy"]}
}
func (m ShopHistory) InventoryOverstock() core.Interface {
	return core.Interface{m["inventory_overstock"]}
}

func (m *ShopHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 27)
	args := make([]interface{}, 27)
	for i := 0; i < 27; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopHistory, 27)
	res["id"] = data[0]
	res["name"] = data[1]
	res["owner_id"] = data[2]
	res["is_test"] = data[3]
	res["address_id"] = data[4]
	res["ship_to_address_id"] = data[5]
	res["ship_from_address_id"] = data[6]
	res["phone"] = data[7]
	res["bank_account"] = data[8]
	res["website_url"] = data[9]
	res["image_url"] = data[10]
	res["email"] = data[11]
	res["code"] = data[12]
	res["auto_create_ffm"] = data[13]
	res["order_source_id"] = data[14]
	res["status"] = data[15]
	res["created_at"] = data[16]
	res["updated_at"] = data[17]
	res["deleted_at"] = data[18]
	res["recognized_hosts"] = data[19]
	res["ghn_note_code"] = data[20]
	res["try_on"] = data[21]
	res["company_info"] = data[22]
	res["money_transaction_rrule"] = data[23]
	res["survey_info"] = data[24]
	res["shipping_service_select_strategy"] = data[25]
	res["inventory_overstock"] = data[26]
	*m = res
	return nil
}

func (ms *ShopHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 27)
	args := make([]interface{}, 27)
	for i := 0; i < 27; i++ {
		args[i] = &data[i]
	}
	res := make(ShopHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["owner_id"] = data[2]
		m["is_test"] = data[3]
		m["address_id"] = data[4]
		m["ship_to_address_id"] = data[5]
		m["ship_from_address_id"] = data[6]
		m["phone"] = data[7]
		m["bank_account"] = data[8]
		m["website_url"] = data[9]
		m["image_url"] = data[10]
		m["email"] = data[11]
		m["code"] = data[12]
		m["auto_create_ffm"] = data[13]
		m["order_source_id"] = data[14]
		m["status"] = data[15]
		m["created_at"] = data[16]
		m["updated_at"] = data[17]
		m["deleted_at"] = data[18]
		m["recognized_hosts"] = data[19]
		m["ghn_note_code"] = data[20]
		m["try_on"] = data[21]
		m["company_info"] = data[22]
		m["money_transaction_rrule"] = data[23]
		m["survey_info"] = data[24]
		m["shipping_service_select_strategy"] = data[25]
		m["inventory_overstock"] = data[26]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type ShopExtended represents a join
func sqlgenShopExtended(_ *ShopExtended, _ *Shop, as sq.AS, t0 sq.JOIN_TYPE, _ *Address, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlShopExtended_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlShopExtended_As = as
	__sqlShopExtended_JoinAs = []sq.AS{a0, a1}
	__sqlShopExtended_JoinConds = []string{c0, c1}
	return true
}

type ShopExtendeds []*ShopExtended

var __sqlShopExtended_JoinTypes []sq.JOIN_TYPE
var __sqlShopExtended_As sq.AS
var __sqlShopExtended_JoinAs []sq.AS
var __sqlShopExtended_JoinConds []string

func (m *ShopExtended) SQLTableName() string  { return "shop" }
func (m *ShopExtendeds) SQLTableName() string { return "shop" }

func (m *ShopExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopExtendeds, 0, 128)
	for rows.Next() {
		m := new(ShopExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *ShopExtended) SQLSelect(w SQLWriter) error {
	(*ShopExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*ShopExtended)(nil).__sqlJoin(w, __sqlShopExtended_JoinTypes)
	return nil
}

func (m *ShopExtendeds) SQLSelect(w SQLWriter) error {
	return (*ShopExtended)(nil).SQLSelect(w)
}

func (m *ShopExtended) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlShopExtended_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *ShopExtendeds) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*ShopExtended)(nil).SQLJoin(w, types)
}

func (m *ShopExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlShopExtended_As), (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlShopExtended_JoinAs[0]), (*Address)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlShopExtended_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *ShopExtended) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("shop")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Address)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlShopExtended_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlShopExtended_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlShopExtended_JoinConds[1])
}

func (m *ShopExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.Address = new(Address)
	args = append(args, m.Address.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// *ShopDelete is a substruct of *Shop
func substructShopDelete(_ *ShopDelete, _ *Shop) bool { return true }

func ShopDeletesFromShops(ps []*Shop) []*ShopDelete {
	ss := make([]*ShopDelete, len(ps))
	for i, p := range ps {
		ss[i] = NewShopDeleteFromShop(p)
	}
	return ss
}

func ShopDeletesToShops(ss []*ShopDelete) []*Shop {
	ps := make([]*Shop, len(ss))
	for i, s := range ss {
		ps[i] = s.ToShop()
	}
	return ps
}

func NewShopDeleteFromShop(sp *Shop) *ShopDelete {
	if sp == nil {
		return nil
	}
	s := new(ShopDelete)
	s.CopyFrom(sp)
	return s
}

func (s *ShopDelete) ToShop() *Shop {
	if s == nil {
		return nil
	}
	sp := new(Shop)
	s.AssignTo(sp)
	return sp
}

func (s *ShopDelete) CopyFrom(sp *Shop) {
	s.DeletedAt = sp.DeletedAt
}

func (s *ShopDelete) AssignTo(sp *Shop) {
	sp.DeletedAt = s.DeletedAt
}

// Type ShopDelete represents table shop
func sqlgenShopDelete(_ *ShopDelete, _ *Shop) bool { return true }

type ShopDeletes []*ShopDelete

const __sqlShopDelete_Table = "shop"
const __sqlShopDelete_ListCols = "\"deleted_at\""
const __sqlShopDelete_Insert = "INSERT INTO \"shop\" (" + __sqlShopDelete_ListCols + ") VALUES"
const __sqlShopDelete_Select = "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\""
const __sqlShopDelete_Select_history = "SELECT " + __sqlShopDelete_ListCols + " FROM history.\"shop\""
const __sqlShopDelete_UpdateAll = "UPDATE \"shop\" SET (" + __sqlShopDelete_ListCols + ")"

func (m *ShopDelete) SQLTableName() string  { return "shop" }
func (m *ShopDeletes) SQLTableName() string { return "shop" }
func (m *ShopDelete) SQLListCols() string   { return __sqlShopDelete_ListCols }

func (m *ShopDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShopDelete_ListCols + " FROM \"shop\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShopDelete)(nil))
}

func (m *ShopDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *ShopDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShopDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShopDeletes, 0, 128)
	for rows.Next() {
		m := new(ShopDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShopDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (_ *ShopDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select)
	return nil
}

func (m *ShopDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShopDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShopDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shop")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShopDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShopDeleteHistory map[string]interface{}
type ShopDeleteHistories []map[string]interface{}

func (m *ShopDeleteHistory) SQLTableName() string  { return "history.\"shop\"" }
func (m ShopDeleteHistories) SQLTableName() string { return "history.\"shop\"" }

func (m *ShopDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShopDelete_Select_history)
	return nil
}

func (m ShopDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *ShopDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShopDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *ShopDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(ShopDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShopDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Partner represents table partner
func sqlgenPartner(_ *Partner) bool { return true }

type Partners []*Partner

const __sqlPartner_Table = "partner"
const __sqlPartner_ListCols = "\"id\",\"owner_id\",\"status\",\"is_test\",\"name\",\"public_name\",\"phone\",\"email\",\"image_url\",\"website_url\",\"contact_persons\",\"recognized_hosts\",\"redirect_urls\",\"available_from_etop\",\"available_from_etop_config\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlPartner_Insert = "INSERT INTO \"partner\" (" + __sqlPartner_ListCols + ") VALUES"
const __sqlPartner_Select = "SELECT " + __sqlPartner_ListCols + " FROM \"partner\""
const __sqlPartner_Select_history = "SELECT " + __sqlPartner_ListCols + " FROM history.\"partner\""
const __sqlPartner_UpdateAll = "UPDATE \"partner\" SET (" + __sqlPartner_ListCols + ")"

func (m *Partner) SQLTableName() string  { return "partner" }
func (m *Partners) SQLTableName() string { return "partner" }
func (m *Partner) SQLListCols() string   { return __sqlPartner_ListCols }

func (m *Partner) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartner_ListCols + " FROM \"partner\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Partner)(nil))
}

func (m *Partner) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.OwnerID,
		m.Status,
		core.Int(m.IsTest),
		core.String(m.Name),
		core.String(m.PublicName),
		core.String(m.Phone),
		core.String(m.Email),
		core.String(m.ImageURL),
		core.String(m.WebsiteURL),
		core.JSON{m.ContactPersons},
		core.Array{m.RecognizedHosts, opts},
		core.Array{m.RedirectURLs, opts},
		core.Bool(m.AvailableFromEtop),
		core.JSON{m.AvailableFromEtopConfig},
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *Partner) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.OwnerID,
		&m.Status,
		(*core.Int)(&m.IsTest),
		(*core.String)(&m.Name),
		(*core.String)(&m.PublicName),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Email),
		(*core.String)(&m.ImageURL),
		(*core.String)(&m.WebsiteURL),
		core.JSON{&m.ContactPersons},
		core.Array{&m.RecognizedHosts, opts},
		core.Array{&m.RedirectURLs, opts},
		(*core.Bool)(&m.AvailableFromEtop),
		core.JSON{&m.AvailableFromEtopConfig},
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *Partner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Partners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Partners, 0, 128)
	for rows.Next() {
		m := new(Partner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Partner) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (_ *Partners) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select)
	return nil
}

func (m *Partner) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Partners) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(18)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Partner) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.OwnerID != 0 {
		flag = true
		w.WriteName("owner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OwnerID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.PublicName != "" {
		flag = true
		w.WriteName("public_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PublicName)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.ImageURL != "" {
		flag = true
		w.WriteName("image_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ImageURL)
	}
	if m.WebsiteURL != "" {
		flag = true
		w.WriteName("website_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebsiteURL)
	}
	if m.ContactPersons != nil {
		flag = true
		w.WriteName("contact_persons")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.ContactPersons})
	}
	if m.RecognizedHosts != nil {
		flag = true
		w.WriteName("recognized_hosts")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RecognizedHosts, opts})
	}
	if m.RedirectURLs != nil {
		flag = true
		w.WriteName("redirect_urls")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.RedirectURLs, opts})
	}
	if m.AvailableFromEtop {
		flag = true
		w.WriteName("available_from_etop")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AvailableFromEtop)
	}
	if m.AvailableFromEtopConfig != nil {
		flag = true
		w.WriteName("available_from_etop_config")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.AvailableFromEtopConfig})
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Partner) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerHistory map[string]interface{}
type PartnerHistories []map[string]interface{}

func (m *PartnerHistory) SQLTableName() string  { return "history.\"partner\"" }
func (m PartnerHistories) SQLTableName() string { return "history.\"partner\"" }

func (m *PartnerHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartner_Select_history)
	return nil
}

func (m PartnerHistory) ID() core.Interface              { return core.Interface{m["id"]} }
func (m PartnerHistory) OwnerID() core.Interface         { return core.Interface{m["owner_id"]} }
func (m PartnerHistory) Status() core.Interface          { return core.Interface{m["status"]} }
func (m PartnerHistory) IsTest() core.Interface          { return core.Interface{m["is_test"]} }
func (m PartnerHistory) Name() core.Interface            { return core.Interface{m["name"]} }
func (m PartnerHistory) PublicName() core.Interface      { return core.Interface{m["public_name"]} }
func (m PartnerHistory) Phone() core.Interface           { return core.Interface{m["phone"]} }
func (m PartnerHistory) Email() core.Interface           { return core.Interface{m["email"]} }
func (m PartnerHistory) ImageURL() core.Interface        { return core.Interface{m["image_url"]} }
func (m PartnerHistory) WebsiteURL() core.Interface      { return core.Interface{m["website_url"]} }
func (m PartnerHistory) ContactPersons() core.Interface  { return core.Interface{m["contact_persons"]} }
func (m PartnerHistory) RecognizedHosts() core.Interface { return core.Interface{m["recognized_hosts"]} }
func (m PartnerHistory) RedirectURLs() core.Interface    { return core.Interface{m["redirect_urls"]} }
func (m PartnerHistory) AvailableFromEtop() core.Interface {
	return core.Interface{m["available_from_etop"]}
}
func (m PartnerHistory) AvailableFromEtopConfig() core.Interface {
	return core.Interface{m["available_from_etop_config"]}
}
func (m PartnerHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m PartnerHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }
func (m PartnerHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *PartnerHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerHistory, 18)
	res["id"] = data[0]
	res["owner_id"] = data[1]
	res["status"] = data[2]
	res["is_test"] = data[3]
	res["name"] = data[4]
	res["public_name"] = data[5]
	res["phone"] = data[6]
	res["email"] = data[7]
	res["image_url"] = data[8]
	res["website_url"] = data[9]
	res["contact_persons"] = data[10]
	res["recognized_hosts"] = data[11]
	res["redirect_urls"] = data[12]
	res["available_from_etop"] = data[13]
	res["available_from_etop_config"] = data[14]
	res["created_at"] = data[15]
	res["updated_at"] = data[16]
	res["deleted_at"] = data[17]
	*m = res
	return nil
}

func (ms *PartnerHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerHistory)
		m["id"] = data[0]
		m["owner_id"] = data[1]
		m["status"] = data[2]
		m["is_test"] = data[3]
		m["name"] = data[4]
		m["public_name"] = data[5]
		m["phone"] = data[6]
		m["email"] = data[7]
		m["image_url"] = data[8]
		m["website_url"] = data[9]
		m["contact_persons"] = data[10]
		m["recognized_hosts"] = data[11]
		m["redirect_urls"] = data[12]
		m["available_from_etop"] = data[13]
		m["available_from_etop_config"] = data[14]
		m["created_at"] = data[15]
		m["updated_at"] = data[16]
		m["deleted_at"] = data[17]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountAuth represents table account_auth
func sqlgenAccountAuth(_ *AccountAuth) bool { return true }

type AccountAuths []*AccountAuth

const __sqlAccountAuth_Table = "account_auth"
const __sqlAccountAuth_ListCols = "\"auth_key\",\"account_id\",\"status\",\"roles\",\"permissions\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlAccountAuth_Insert = "INSERT INTO \"account_auth\" (" + __sqlAccountAuth_ListCols + ") VALUES"
const __sqlAccountAuth_Select = "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\""
const __sqlAccountAuth_Select_history = "SELECT " + __sqlAccountAuth_ListCols + " FROM history.\"account_auth\""
const __sqlAccountAuth_UpdateAll = "UPDATE \"account_auth\" SET (" + __sqlAccountAuth_ListCols + ")"

func (m *AccountAuth) SQLTableName() string  { return "account_auth" }
func (m *AccountAuths) SQLTableName() string { return "account_auth" }
func (m *AccountAuth) SQLListCols() string   { return __sqlAccountAuth_ListCols }

func (m *AccountAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountAuth_ListCols + " FROM \"account_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountAuth)(nil))
}

func (m *AccountAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.AccountID,
		m.Status,
		core.Array{m.Roles, opts},
		core.Array{m.Permissions, opts},
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.AccountID,
		&m.Status,
		core.Array{&m.Roles, opts},
		core.Array{&m.Permissions, opts},
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuths, 0, 128)
	for rows.Next() {
		m := new(AccountAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (_ *AccountAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select)
	return nil
}

func (m *AccountAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(8)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_auth")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Roles, opts})
	}
	if m.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permissions, opts})
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountAuthHistory map[string]interface{}
type AccountAuthHistories []map[string]interface{}

func (m *AccountAuthHistory) SQLTableName() string  { return "history.\"account_auth\"" }
func (m AccountAuthHistories) SQLTableName() string { return "history.\"account_auth\"" }

func (m *AccountAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountAuth_Select_history)
	return nil
}

func (m AccountAuthHistory) AuthKey() core.Interface     { return core.Interface{m["auth_key"]} }
func (m AccountAuthHistory) AccountID() core.Interface   { return core.Interface{m["account_id"]} }
func (m AccountAuthHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m AccountAuthHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountAuthHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountAuthHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountAuthHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountAuthHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }

func (m *AccountAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountAuthHistory, 8)
	res["auth_key"] = data[0]
	res["account_id"] = data[1]
	res["status"] = data[2]
	res["roles"] = data[3]
	res["permissions"] = data[4]
	res["created_at"] = data[5]
	res["updated_at"] = data[6]
	res["deleted_at"] = data[7]
	*m = res
	return nil
}

func (ms *AccountAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	res := make(AccountAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountAuthHistory)
		m["auth_key"] = data[0]
		m["account_id"] = data[1]
		m["status"] = data[2]
		m["roles"] = data[3]
		m["permissions"] = data[4]
		m["created_at"] = data[5]
		m["updated_at"] = data[6]
		m["deleted_at"] = data[7]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountAuthFtPartner represents a join
func sqlgenAccountAuthFtPartner(_ *AccountAuthFtPartner, _ *AccountAuth, as sq.AS, t0 sq.JOIN_TYPE, _ *Partner, a0 sq.AS, c0 string) bool {
	__sqlAccountAuthFtPartner_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlAccountAuthFtPartner_As = as
	__sqlAccountAuthFtPartner_JoinAs = []sq.AS{a0}
	__sqlAccountAuthFtPartner_JoinConds = []string{c0}
	return true
}

type AccountAuthFtPartners []*AccountAuthFtPartner

var __sqlAccountAuthFtPartner_JoinTypes []sq.JOIN_TYPE
var __sqlAccountAuthFtPartner_As sq.AS
var __sqlAccountAuthFtPartner_JoinAs []sq.AS
var __sqlAccountAuthFtPartner_JoinConds []string

func (m *AccountAuthFtPartner) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtPartners) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtPartner) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtPartners) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtPartners, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtPartner)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtPartner) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtPartner)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtPartner)(nil).__sqlJoin(w, __sqlAccountAuthFtPartner_JoinTypes)
	return nil
}

func (m *AccountAuthFtPartners) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtPartner)(nil).SQLSelect(w)
}

func (m *AccountAuthFtPartner) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountAuthFtPartner_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountAuthFtPartners) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountAuthFtPartner)(nil).SQLJoin(w, types)
}

func (m *AccountAuthFtPartner) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountAuthFtPartner_As), (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountAuthFtPartner_JoinAs[0]), (*Partner)(nil).SQLListCols())
}

func (m *AccountAuthFtPartner) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtPartner_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Partner)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtPartner_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountAuthFtPartner_JoinConds[0])
}

func (m *AccountAuthFtPartner) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Partner = new(Partner)
	args = append(args, m.Partner.SQLScanArgs(opts)...)

	return args
}

// Type AccountAuthFtShop represents a join
func sqlgenAccountAuthFtShop(_ *AccountAuthFtShop, _ *AccountAuth, as sq.AS, t0 sq.JOIN_TYPE, _ *Shop, a0 sq.AS, c0 string) bool {
	__sqlAccountAuthFtShop_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlAccountAuthFtShop_As = as
	__sqlAccountAuthFtShop_JoinAs = []sq.AS{a0}
	__sqlAccountAuthFtShop_JoinConds = []string{c0}
	return true
}

type AccountAuthFtShops []*AccountAuthFtShop

var __sqlAccountAuthFtShop_JoinTypes []sq.JOIN_TYPE
var __sqlAccountAuthFtShop_As sq.AS
var __sqlAccountAuthFtShop_JoinAs []sq.AS
var __sqlAccountAuthFtShop_JoinConds []string

func (m *AccountAuthFtShop) SQLTableName() string  { return "account_auth" }
func (m *AccountAuthFtShops) SQLTableName() string { return "account_auth" }

func (m *AccountAuthFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountAuthFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountAuthFtShops, 0, 128)
	for rows.Next() {
		m := new(AccountAuthFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountAuthFtShop) SQLSelect(w SQLWriter) error {
	(*AccountAuthFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountAuthFtShop)(nil).__sqlJoin(w, __sqlAccountAuthFtShop_JoinTypes)
	return nil
}

func (m *AccountAuthFtShops) SQLSelect(w SQLWriter) error {
	return (*AccountAuthFtShop)(nil).SQLSelect(w)
}

func (m *AccountAuthFtShop) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountAuthFtShop_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountAuthFtShops) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountAuthFtShop)(nil).SQLJoin(w, types)
}

func (m *AccountAuthFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountAuthFtShop_As), (*AccountAuth)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountAuthFtShop_JoinAs[0]), (*Shop)(nil).SQLListCols())
}

func (m *AccountAuthFtShop) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_auth")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtShop_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountAuthFtShop_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountAuthFtShop_JoinConds[0])
}

func (m *AccountAuthFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountAuth = new(AccountAuth)
	args = append(args, m.AccountAuth.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)

	return args
}

// Type PartnerRelation represents table partner_relation
func sqlgenPartnerRelation(_ *PartnerRelation) bool { return true }

type PartnerRelations []*PartnerRelation

const __sqlPartnerRelation_Table = "partner_relation"
const __sqlPartnerRelation_ListCols = "\"auth_key\",\"partner_id\",\"subject_id\",\"subject_type\",\"external_subject_id\",\"nonce\",\"status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\""
const __sqlPartnerRelation_Insert = "INSERT INTO \"partner_relation\" (" + __sqlPartnerRelation_ListCols + ") VALUES"
const __sqlPartnerRelation_Select = "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\""
const __sqlPartnerRelation_Select_history = "SELECT " + __sqlPartnerRelation_ListCols + " FROM history.\"partner_relation\""
const __sqlPartnerRelation_UpdateAll = "UPDATE \"partner_relation\" SET (" + __sqlPartnerRelation_ListCols + ")"

func (m *PartnerRelation) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelations) SQLTableName() string { return "partner_relation" }
func (m *PartnerRelation) SQLListCols() string   { return __sqlPartnerRelation_ListCols }

func (m *PartnerRelation) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlPartnerRelation_ListCols + " FROM \"partner_relation\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*PartnerRelation)(nil))
}

func (m *PartnerRelation) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.AuthKey),
		m.PartnerID,
		m.SubjectID,
		core.String(m.SubjectType),
		core.String(m.ExternalSubjectID),
		m.Nonce,
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.AuthKey),
		&m.PartnerID,
		&m.SubjectID,
		(*core.String)(&m.SubjectType),
		(*core.String)(&m.ExternalSubjectID),
		&m.Nonce,
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
	}
}

func (m *PartnerRelation) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelations) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelations, 0, 128)
	for rows.Next() {
		m := new(PartnerRelation)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *PartnerRelation) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (_ *PartnerRelations) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select)
	return nil
}

func (m *PartnerRelation) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms PartnerRelations) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(12)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *PartnerRelation) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("partner_relation")
	w.WriteRawString(" SET ")
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if m.PartnerID != 0 {
		flag = true
		w.WriteName("partner_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PartnerID)
	}
	if m.SubjectID != 0 {
		flag = true
		w.WriteName("subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.SubjectID)
	}
	if m.SubjectType != "" {
		flag = true
		w.WriteName("subject_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.SubjectType))
	}
	if m.ExternalSubjectID != "" {
		flag = true
		w.WriteName("external_subject_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalSubjectID)
	}
	if m.Nonce != 0 {
		flag = true
		w.WriteName("nonce")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Nonce)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *PartnerRelation) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type PartnerRelationHistory map[string]interface{}
type PartnerRelationHistories []map[string]interface{}

func (m *PartnerRelationHistory) SQLTableName() string  { return "history.\"partner_relation\"" }
func (m PartnerRelationHistories) SQLTableName() string { return "history.\"partner_relation\"" }

func (m *PartnerRelationHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlPartnerRelation_Select_history)
	return nil
}

func (m PartnerRelationHistory) AuthKey() core.Interface     { return core.Interface{m["auth_key"]} }
func (m PartnerRelationHistory) PartnerID() core.Interface   { return core.Interface{m["partner_id"]} }
func (m PartnerRelationHistory) SubjectID() core.Interface   { return core.Interface{m["subject_id"]} }
func (m PartnerRelationHistory) SubjectType() core.Interface { return core.Interface{m["subject_type"]} }
func (m PartnerRelationHistory) ExternalSubjectID() core.Interface {
	return core.Interface{m["external_subject_id"]}
}
func (m PartnerRelationHistory) Nonce() core.Interface       { return core.Interface{m["nonce"]} }
func (m PartnerRelationHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m PartnerRelationHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m PartnerRelationHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m PartnerRelationHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m PartnerRelationHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m PartnerRelationHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }

func (m *PartnerRelationHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(PartnerRelationHistory, 12)
	res["auth_key"] = data[0]
	res["partner_id"] = data[1]
	res["subject_id"] = data[2]
	res["subject_type"] = data[3]
	res["external_subject_id"] = data[4]
	res["nonce"] = data[5]
	res["status"] = data[6]
	res["created_at"] = data[7]
	res["updated_at"] = data[8]
	res["deleted_at"] = data[9]
	res["roles"] = data[10]
	res["permissions"] = data[11]
	*m = res
	return nil
}

func (ms *PartnerRelationHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	res := make(PartnerRelationHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(PartnerRelationHistory)
		m["auth_key"] = data[0]
		m["partner_id"] = data[1]
		m["subject_id"] = data[2]
		m["subject_type"] = data[3]
		m["external_subject_id"] = data[4]
		m["nonce"] = data[5]
		m["status"] = data[6]
		m["created_at"] = data[7]
		m["updated_at"] = data[8]
		m["deleted_at"] = data[9]
		m["roles"] = data[10]
		m["permissions"] = data[11]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type PartnerRelationFtShop represents a join
func sqlgenPartnerRelationFtShop(_ *PartnerRelationFtShop, _ *PartnerRelation, as sq.AS, t0 sq.JOIN_TYPE, _ *Shop, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlPartnerRelationFtShop_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlPartnerRelationFtShop_As = as
	__sqlPartnerRelationFtShop_JoinAs = []sq.AS{a0, a1}
	__sqlPartnerRelationFtShop_JoinConds = []string{c0, c1}
	return true
}

type PartnerRelationFtShops []*PartnerRelationFtShop

var __sqlPartnerRelationFtShop_JoinTypes []sq.JOIN_TYPE
var __sqlPartnerRelationFtShop_As sq.AS
var __sqlPartnerRelationFtShop_JoinAs []sq.AS
var __sqlPartnerRelationFtShop_JoinConds []string

func (m *PartnerRelationFtShop) SQLTableName() string  { return "partner_relation" }
func (m *PartnerRelationFtShops) SQLTableName() string { return "partner_relation" }

func (m *PartnerRelationFtShop) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *PartnerRelationFtShops) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(PartnerRelationFtShops, 0, 128)
	for rows.Next() {
		m := new(PartnerRelationFtShop)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *PartnerRelationFtShop) SQLSelect(w SQLWriter) error {
	(*PartnerRelationFtShop)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*PartnerRelationFtShop)(nil).__sqlJoin(w, __sqlPartnerRelationFtShop_JoinTypes)
	return nil
}

func (m *PartnerRelationFtShops) SQLSelect(w SQLWriter) error {
	return (*PartnerRelationFtShop)(nil).SQLSelect(w)
}

func (m *PartnerRelationFtShop) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlPartnerRelationFtShop_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *PartnerRelationFtShops) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*PartnerRelationFtShop)(nil).SQLJoin(w, types)
}

func (m *PartnerRelationFtShop) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_As), (*PartnerRelation)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_JoinAs[0]), (*Shop)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlPartnerRelationFtShop_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *PartnerRelationFtShop) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("partner_relation")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlPartnerRelationFtShop_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlPartnerRelationFtShop_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlPartnerRelationFtShop_JoinConds[1])
}

func (m *PartnerRelationFtShop) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.PartnerRelation = new(PartnerRelation)
	args = append(args, m.PartnerRelation.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// Type User represents table user
func sqlgenUser(_ *User) bool { return true }

type Users []*User

const __sqlUser_Table = "user"
const __sqlUser_ListCols = "\"id\",\"full_name\",\"short_name\",\"email\",\"phone\",\"status\",\"created_at\",\"updated_at\",\"agreed_tos_at\",\"agreed_email_info_at\",\"email_verified_at\",\"phone_verified_at\",\"email_verification_sent_at\",\"phone_verification_sent_at\",\"is_test\",\"source\",\"ref_user_id\",\"ref_sale_id\""
const __sqlUser_Insert = "INSERT INTO \"user\" (" + __sqlUser_ListCols + ") VALUES"
const __sqlUser_Select = "SELECT " + __sqlUser_ListCols + " FROM \"user\""
const __sqlUser_Select_history = "SELECT " + __sqlUser_ListCols + " FROM history.\"user\""
const __sqlUser_UpdateAll = "UPDATE \"user\" SET (" + __sqlUser_ListCols + ")"

func (m *User) SQLTableName() string  { return "user" }
func (m *Users) SQLTableName() string { return "user" }
func (m *User) SQLListCols() string   { return __sqlUser_ListCols }

func (m *User) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUser_ListCols + " FROM \"user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*User)(nil))
}

func (m *User) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.UserInner.FullName),
		core.String(m.UserInner.ShortName),
		core.String(m.UserInner.Email),
		core.String(m.UserInner.Phone),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.AgreedTOSAt),
		core.Time(m.AgreedEmailInfoAt),
		core.Time(m.EmailVerifiedAt),
		core.Time(m.PhoneVerifiedAt),
		core.Time(m.EmailVerificationSentAt),
		core.Time(m.PhoneVerificationSentAt),
		core.Int(m.IsTest),
		m.Source,
		m.RefUserID,
		m.RefSaleID,
	}
}

func (m *User) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.UserInner.FullName),
		(*core.String)(&m.UserInner.ShortName),
		(*core.String)(&m.UserInner.Email),
		(*core.String)(&m.UserInner.Phone),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.AgreedTOSAt),
		(*core.Time)(&m.AgreedEmailInfoAt),
		(*core.Time)(&m.EmailVerifiedAt),
		(*core.Time)(&m.PhoneVerifiedAt),
		(*core.Time)(&m.EmailVerificationSentAt),
		(*core.Time)(&m.PhoneVerificationSentAt),
		(*core.Int)(&m.IsTest),
		&m.Source,
		&m.RefUserID,
		&m.RefSaleID,
	}
}

func (m *User) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Users) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Users, 0, 128)
	for rows.Next() {
		m := new(User)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *User) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (_ *Users) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select)
	return nil
}

func (m *User) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Users) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(18)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *User) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserInner.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.FullName)
	}
	if m.UserInner.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.ShortName)
	}
	if m.UserInner.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Email)
	}
	if m.UserInner.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserInner.Phone)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.AgreedTOSAt.IsZero() {
		flag = true
		w.WriteName("agreed_tos_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedTOSAt)
	}
	if !m.AgreedEmailInfoAt.IsZero() {
		flag = true
		w.WriteName("agreed_email_info_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AgreedEmailInfoAt)
	}
	if !m.EmailVerifiedAt.IsZero() {
		flag = true
		w.WriteName("email_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerifiedAt)
	}
	if !m.PhoneVerifiedAt.IsZero() {
		flag = true
		w.WriteName("phone_verified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerifiedAt)
	}
	if !m.EmailVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("email_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EmailVerificationSentAt)
	}
	if !m.PhoneVerificationSentAt.IsZero() {
		flag = true
		w.WriteName("phone_verification_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PhoneVerificationSentAt)
	}
	if m.IsTest != 0 {
		flag = true
		w.WriteName("is_test")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.IsTest)
	}
	if m.Source != 0 {
		flag = true
		w.WriteName("source")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Source)
	}
	if m.RefUserID != 0 {
		flag = true
		w.WriteName("ref_user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefUserID)
	}
	if m.RefSaleID != 0 {
		flag = true
		w.WriteName("ref_sale_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RefSaleID)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *User) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(18)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserHistory map[string]interface{}
type UserHistories []map[string]interface{}

func (m *UserHistory) SQLTableName() string  { return "history.\"user\"" }
func (m UserHistories) SQLTableName() string { return "history.\"user\"" }

func (m *UserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUser_Select_history)
	return nil
}

func (m UserHistory) ID() core.Interface          { return core.Interface{m["id"]} }
func (m UserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m UserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m UserHistory) Email() core.Interface       { return core.Interface{m["email"]} }
func (m UserHistory) Phone() core.Interface       { return core.Interface{m["phone"]} }
func (m UserHistory) Status() core.Interface      { return core.Interface{m["status"]} }
func (m UserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m UserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m UserHistory) AgreedTOSAt() core.Interface { return core.Interface{m["agreed_tos_at"]} }
func (m UserHistory) AgreedEmailInfoAt() core.Interface {
	return core.Interface{m["agreed_email_info_at"]}
}
func (m UserHistory) EmailVerifiedAt() core.Interface { return core.Interface{m["email_verified_at"]} }
func (m UserHistory) PhoneVerifiedAt() core.Interface { return core.Interface{m["phone_verified_at"]} }
func (m UserHistory) EmailVerificationSentAt() core.Interface {
	return core.Interface{m["email_verification_sent_at"]}
}
func (m UserHistory) PhoneVerificationSentAt() core.Interface {
	return core.Interface{m["phone_verification_sent_at"]}
}
func (m UserHistory) IsTest() core.Interface    { return core.Interface{m["is_test"]} }
func (m UserHistory) Source() core.Interface    { return core.Interface{m["source"]} }
func (m UserHistory) RefUserID() core.Interface { return core.Interface{m["ref_user_id"]} }
func (m UserHistory) RefSaleID() core.Interface { return core.Interface{m["ref_sale_id"]} }

func (m *UserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserHistory, 18)
	res["id"] = data[0]
	res["full_name"] = data[1]
	res["short_name"] = data[2]
	res["email"] = data[3]
	res["phone"] = data[4]
	res["status"] = data[5]
	res["created_at"] = data[6]
	res["updated_at"] = data[7]
	res["agreed_tos_at"] = data[8]
	res["agreed_email_info_at"] = data[9]
	res["email_verified_at"] = data[10]
	res["phone_verified_at"] = data[11]
	res["email_verification_sent_at"] = data[12]
	res["phone_verification_sent_at"] = data[13]
	res["is_test"] = data[14]
	res["source"] = data[15]
	res["ref_user_id"] = data[16]
	res["ref_sale_id"] = data[17]
	*m = res
	return nil
}

func (ms *UserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 18)
	args := make([]interface{}, 18)
	for i := 0; i < 18; i++ {
		args[i] = &data[i]
	}
	res := make(UserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserHistory)
		m["id"] = data[0]
		m["full_name"] = data[1]
		m["short_name"] = data[2]
		m["email"] = data[3]
		m["phone"] = data[4]
		m["status"] = data[5]
		m["created_at"] = data[6]
		m["updated_at"] = data[7]
		m["agreed_tos_at"] = data[8]
		m["agreed_email_info_at"] = data[9]
		m["email_verified_at"] = data[10]
		m["phone_verified_at"] = data[11]
		m["email_verification_sent_at"] = data[12]
		m["phone_verification_sent_at"] = data[13]
		m["is_test"] = data[14]
		m["source"] = data[15]
		m["ref_user_id"] = data[16]
		m["ref_sale_id"] = data[17]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountUser represents table account_user
func sqlgenAccountUser(_ *AccountUser) bool { return true }

type AccountUsers []*AccountUser

const __sqlAccountUser_Table = "account_user"
const __sqlAccountUser_ListCols = "\"account_id\",\"user_id\",\"status\",\"response_status\",\"created_at\",\"updated_at\",\"deleted_at\",\"roles\",\"permissions\",\"full_name\",\"short_name\",\"position\",\"invitation_sent_at\",\"invitation_sent_by\",\"invitation_accepted_at\",\"invitation_rejected_at\",\"disabled_at\",\"disabled_by\",\"disable_reason\""
const __sqlAccountUser_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUser_ListCols + ") VALUES"
const __sqlAccountUser_Select = "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\""
const __sqlAccountUser_Select_history = "SELECT " + __sqlAccountUser_ListCols + " FROM history.\"account_user\""
const __sqlAccountUser_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUser_ListCols + ")"

func (m *AccountUser) SQLTableName() string  { return "account_user" }
func (m *AccountUsers) SQLTableName() string { return "account_user" }
func (m *AccountUser) SQLListCols() string   { return __sqlAccountUser_ListCols }

func (m *AccountUser) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUser_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUser)(nil))
}

func (m *AccountUser) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.AccountID,
		m.UserID,
		m.Status,
		m.ResponseStatus,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
		core.Array{m.Permission.Roles, opts},
		core.Array{m.Permission.Permissions, opts},
		core.String(m.FullName),
		core.String(m.ShortName),
		core.String(m.Position),
		core.Time(m.InvitationSentAt),
		m.InvitationSentBy,
		core.Time(m.InvitationAcceptedAt),
		core.Time(m.InvitationRejectedAt),
		core.Time(m.DisabledAt),
		core.Time(m.DisabledBy),
		core.String(m.DisableReason),
	}
}

func (m *AccountUser) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.AccountID,
		&m.UserID,
		&m.Status,
		&m.ResponseStatus,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
		core.Array{&m.Permission.Roles, opts},
		core.Array{&m.Permission.Permissions, opts},
		(*core.String)(&m.FullName),
		(*core.String)(&m.ShortName),
		(*core.String)(&m.Position),
		(*core.Time)(&m.InvitationSentAt),
		&m.InvitationSentBy,
		(*core.Time)(&m.InvitationAcceptedAt),
		(*core.Time)(&m.InvitationRejectedAt),
		(*core.Time)(&m.DisabledAt),
		(*core.Time)(&m.DisabledBy),
		(*core.String)(&m.DisableReason),
	}
}

func (m *AccountUser) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUsers) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUsers, 0, 128)
	for rows.Next() {
		m := new(AccountUser)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUser) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (_ *AccountUsers) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select)
	return nil
}

func (m *AccountUser) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUsers) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(19)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUser) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.ResponseStatus != 0 {
		flag = true
		w.WriteName("response_status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ResponseStatus)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if m.Permission.Roles != nil {
		flag = true
		w.WriteName("roles")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Roles, opts})
	}
	if m.Permission.Permissions != nil {
		flag = true
		w.WriteName("permissions")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Permission.Permissions, opts})
	}
	if m.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FullName)
	}
	if m.ShortName != "" {
		flag = true
		w.WriteName("short_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShortName)
	}
	if m.Position != "" {
		flag = true
		w.WriteName("position")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Position)
	}
	if !m.InvitationSentAt.IsZero() {
		flag = true
		w.WriteName("invitation_sent_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentAt)
	}
	if m.InvitationSentBy != 0 {
		flag = true
		w.WriteName("invitation_sent_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationSentBy)
	}
	if !m.InvitationAcceptedAt.IsZero() {
		flag = true
		w.WriteName("invitation_accepted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationAcceptedAt)
	}
	if !m.InvitationRejectedAt.IsZero() {
		flag = true
		w.WriteName("invitation_rejected_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.InvitationRejectedAt)
	}
	if !m.DisabledAt.IsZero() {
		flag = true
		w.WriteName("disabled_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledAt)
	}
	if !m.DisabledBy.IsZero() {
		flag = true
		w.WriteName("disabled_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisabledBy)
	}
	if m.DisableReason != "" {
		flag = true
		w.WriteName("disable_reason")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DisableReason)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUser) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(19)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserHistory map[string]interface{}
type AccountUserHistories []map[string]interface{}

func (m *AccountUserHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUser_Select_history)
	return nil
}

func (m AccountUserHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m AccountUserHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m AccountUserHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m AccountUserHistory) ResponseStatus() core.Interface {
	return core.Interface{m["response_status"]}
}
func (m AccountUserHistory) CreatedAt() core.Interface   { return core.Interface{m["created_at"]} }
func (m AccountUserHistory) UpdatedAt() core.Interface   { return core.Interface{m["updated_at"]} }
func (m AccountUserHistory) DeletedAt() core.Interface   { return core.Interface{m["deleted_at"]} }
func (m AccountUserHistory) Roles() core.Interface       { return core.Interface{m["roles"]} }
func (m AccountUserHistory) Permissions() core.Interface { return core.Interface{m["permissions"]} }
func (m AccountUserHistory) FullName() core.Interface    { return core.Interface{m["full_name"]} }
func (m AccountUserHistory) ShortName() core.Interface   { return core.Interface{m["short_name"]} }
func (m AccountUserHistory) Position() core.Interface    { return core.Interface{m["position"]} }
func (m AccountUserHistory) InvitationSentAt() core.Interface {
	return core.Interface{m["invitation_sent_at"]}
}
func (m AccountUserHistory) InvitationSentBy() core.Interface {
	return core.Interface{m["invitation_sent_by"]}
}
func (m AccountUserHistory) InvitationAcceptedAt() core.Interface {
	return core.Interface{m["invitation_accepted_at"]}
}
func (m AccountUserHistory) InvitationRejectedAt() core.Interface {
	return core.Interface{m["invitation_rejected_at"]}
}
func (m AccountUserHistory) DisabledAt() core.Interface    { return core.Interface{m["disabled_at"]} }
func (m AccountUserHistory) DisabledBy() core.Interface    { return core.Interface{m["disabled_by"]} }
func (m AccountUserHistory) DisableReason() core.Interface { return core.Interface{m["disable_reason"]} }

func (m *AccountUserHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserHistory, 19)
	res["account_id"] = data[0]
	res["user_id"] = data[1]
	res["status"] = data[2]
	res["response_status"] = data[3]
	res["created_at"] = data[4]
	res["updated_at"] = data[5]
	res["deleted_at"] = data[6]
	res["roles"] = data[7]
	res["permissions"] = data[8]
	res["full_name"] = data[9]
	res["short_name"] = data[10]
	res["position"] = data[11]
	res["invitation_sent_at"] = data[12]
	res["invitation_sent_by"] = data[13]
	res["invitation_accepted_at"] = data[14]
	res["invitation_rejected_at"] = data[15]
	res["disabled_at"] = data[16]
	res["disabled_by"] = data[17]
	res["disable_reason"] = data[18]
	*m = res
	return nil
}

func (ms *AccountUserHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 19)
	args := make([]interface{}, 19)
	for i := 0; i < 19; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserHistory)
		m["account_id"] = data[0]
		m["user_id"] = data[1]
		m["status"] = data[2]
		m["response_status"] = data[3]
		m["created_at"] = data[4]
		m["updated_at"] = data[5]
		m["deleted_at"] = data[6]
		m["roles"] = data[7]
		m["permissions"] = data[8]
		m["full_name"] = data[9]
		m["short_name"] = data[10]
		m["position"] = data[11]
		m["invitation_sent_at"] = data[12]
		m["invitation_sent_by"] = data[13]
		m["invitation_accepted_at"] = data[14]
		m["invitation_rejected_at"] = data[15]
		m["disabled_at"] = data[16]
		m["disabled_by"] = data[17]
		m["disable_reason"] = data[18]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type AccountUserExtended represents a join
func sqlgenAccountUserExtended(_ *AccountUserExtended, _ *AccountUser, as sq.AS, t0 sq.JOIN_TYPE, _ *Account, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *User, a1 sq.AS, c1 string) bool {
	__sqlAccountUserExtended_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlAccountUserExtended_As = as
	__sqlAccountUserExtended_JoinAs = []sq.AS{a0, a1}
	__sqlAccountUserExtended_JoinConds = []string{c0, c1}
	return true
}

type AccountUserExtendeds []*AccountUserExtended

var __sqlAccountUserExtended_JoinTypes []sq.JOIN_TYPE
var __sqlAccountUserExtended_As sq.AS
var __sqlAccountUserExtended_JoinAs []sq.AS
var __sqlAccountUserExtended_JoinConds []string

func (m *AccountUserExtended) SQLTableName() string  { return "account_user" }
func (m *AccountUserExtendeds) SQLTableName() string { return "account_user" }

func (m *AccountUserExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserExtendeds, 0, 128)
	for rows.Next() {
		m := new(AccountUserExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *AccountUserExtended) SQLSelect(w SQLWriter) error {
	(*AccountUserExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*AccountUserExtended)(nil).__sqlJoin(w, __sqlAccountUserExtended_JoinTypes)
	return nil
}

func (m *AccountUserExtendeds) SQLSelect(w SQLWriter) error {
	return (*AccountUserExtended)(nil).SQLSelect(w)
}

func (m *AccountUserExtended) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlAccountUserExtended_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *AccountUserExtendeds) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*AccountUserExtended)(nil).SQLJoin(w, types)
}

func (m *AccountUserExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlAccountUserExtended_As), (*AccountUser)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountUserExtended_JoinAs[0]), (*Account)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlAccountUserExtended_JoinAs[1]), (*User)(nil).SQLListCols())
}

func (m *AccountUserExtended) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 2 {
		panic("common/sql: expect 2 types to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("account_user")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Account)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountUserExtended_JoinConds[0])
	w.WriteByte(' ')
	w.WriteRawString(string(types[1]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*User)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlAccountUserExtended_JoinAs[1]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlAccountUserExtended_JoinConds[1])
}

func (m *AccountUserExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.AccountUser = new(AccountUser)
	args = append(args, m.AccountUser.SQLScanArgs(opts)...)
	m.Account = new(Account)
	args = append(args, m.Account.SQLScanArgs(opts)...)
	m.User = new(User)
	args = append(args, m.User.SQLScanArgs(opts)...)

	return args
}

// *AccountUserDelete is a substruct of *AccountUser
func substructAccountUserDelete(_ *AccountUserDelete, _ *AccountUser) bool { return true }

func AccountUserDeletesFromAccountUsers(ps []*AccountUser) []*AccountUserDelete {
	ss := make([]*AccountUserDelete, len(ps))
	for i, p := range ps {
		ss[i] = NewAccountUserDeleteFromAccountUser(p)
	}
	return ss
}

func AccountUserDeletesToAccountUsers(ss []*AccountUserDelete) []*AccountUser {
	ps := make([]*AccountUser, len(ss))
	for i, s := range ss {
		ps[i] = s.ToAccountUser()
	}
	return ps
}

func NewAccountUserDeleteFromAccountUser(sp *AccountUser) *AccountUserDelete {
	if sp == nil {
		return nil
	}
	s := new(AccountUserDelete)
	s.CopyFrom(sp)
	return s
}

func (s *AccountUserDelete) ToAccountUser() *AccountUser {
	if s == nil {
		return nil
	}
	sp := new(AccountUser)
	s.AssignTo(sp)
	return sp
}

func (s *AccountUserDelete) CopyFrom(sp *AccountUser) {
	s.DeletedAt = sp.DeletedAt
}

func (s *AccountUserDelete) AssignTo(sp *AccountUser) {
	sp.DeletedAt = s.DeletedAt
}

// Type AccountUserDelete represents table account_user
func sqlgenAccountUserDelete(_ *AccountUserDelete, _ *AccountUser) bool { return true }

type AccountUserDeletes []*AccountUserDelete

const __sqlAccountUserDelete_Table = "account_user"
const __sqlAccountUserDelete_ListCols = "\"deleted_at\""
const __sqlAccountUserDelete_Insert = "INSERT INTO \"account_user\" (" + __sqlAccountUserDelete_ListCols + ") VALUES"
const __sqlAccountUserDelete_Select = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\""
const __sqlAccountUserDelete_Select_history = "SELECT " + __sqlAccountUserDelete_ListCols + " FROM history.\"account_user\""
const __sqlAccountUserDelete_UpdateAll = "UPDATE \"account_user\" SET (" + __sqlAccountUserDelete_ListCols + ")"

func (m *AccountUserDelete) SQLTableName() string  { return "account_user" }
func (m *AccountUserDeletes) SQLTableName() string { return "account_user" }
func (m *AccountUserDelete) SQLListCols() string   { return __sqlAccountUserDelete_ListCols }

func (m *AccountUserDelete) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAccountUserDelete_ListCols + " FROM \"account_user\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*AccountUserDelete)(nil))
}

func (m *AccountUserDelete) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.Time(m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *AccountUserDelete) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *AccountUserDeletes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(AccountUserDeletes, 0, 128)
	for rows.Next() {
		m := new(AccountUserDelete)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *AccountUserDelete) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (_ *AccountUserDeletes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select)
	return nil
}

func (m *AccountUserDelete) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms AccountUserDeletes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(1)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *AccountUserDelete) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("account_user")
	w.WriteRawString(" SET ")
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *AccountUserDelete) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(1)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AccountUserDeleteHistory map[string]interface{}
type AccountUserDeleteHistories []map[string]interface{}

func (m *AccountUserDeleteHistory) SQLTableName() string  { return "history.\"account_user\"" }
func (m AccountUserDeleteHistories) SQLTableName() string { return "history.\"account_user\"" }

func (m *AccountUserDeleteHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAccountUserDelete_Select_history)
	return nil
}

func (m AccountUserDeleteHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *AccountUserDeleteHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AccountUserDeleteHistory, 1)
	res["deleted_at"] = data[0]
	*m = res
	return nil
}

func (ms *AccountUserDeleteHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 1)
	args := make([]interface{}, 1)
	for i := 0; i < 1; i++ {
		args[i] = &data[i]
	}
	res := make(AccountUserDeleteHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AccountUserDeleteHistory)
		m["deleted_at"] = data[0]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserAuth represents table user_auth
func sqlgenUserAuth(_ *UserAuth) bool { return true }

type UserAuths []*UserAuth

const __sqlUserAuth_Table = "user_auth"
const __sqlUserAuth_ListCols = "\"user_id\",\"auth_type\",\"auth_key\",\"created_at\",\"updated_at\""
const __sqlUserAuth_Insert = "INSERT INTO \"user_auth\" (" + __sqlUserAuth_ListCols + ") VALUES"
const __sqlUserAuth_Select = "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\""
const __sqlUserAuth_Select_history = "SELECT " + __sqlUserAuth_ListCols + " FROM history.\"user_auth\""
const __sqlUserAuth_UpdateAll = "UPDATE \"user_auth\" SET (" + __sqlUserAuth_ListCols + ")"

func (m *UserAuth) SQLTableName() string  { return "user_auth" }
func (m *UserAuths) SQLTableName() string { return "user_auth" }
func (m *UserAuth) SQLListCols() string   { return __sqlUserAuth_ListCols }

func (m *UserAuth) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserAuth_ListCols + " FROM \"user_auth\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserAuth)(nil))
}

func (m *UserAuth) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.UserID,
		core.String(m.AuthType),
		core.String(m.AuthKey),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserAuth) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.UserID,
		(*core.String)(&m.AuthType),
		(*core.String)(&m.AuthKey),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserAuth) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserAuths) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserAuths, 0, 128)
	for rows.Next() {
		m := new(UserAuth)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserAuth) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (_ *UserAuths) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select)
	return nil
}

func (m *UserAuth) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserAuths) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(5)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserAuth) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_auth")
	w.WriteRawString(" SET ")
	if m.UserID != 0 {
		flag = true
		w.WriteName("user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserID)
	}
	if m.AuthType != "" {
		flag = true
		w.WriteName("auth_type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthType)
	}
	if m.AuthKey != "" {
		flag = true
		w.WriteName("auth_key")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AuthKey)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserAuth) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(5)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserAuthHistory map[string]interface{}
type UserAuthHistories []map[string]interface{}

func (m *UserAuthHistory) SQLTableName() string  { return "history.\"user_auth\"" }
func (m UserAuthHistories) SQLTableName() string { return "history.\"user_auth\"" }

func (m *UserAuthHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserAuth_Select_history)
	return nil
}

func (m UserAuthHistory) UserID() core.Interface    { return core.Interface{m["user_id"]} }
func (m UserAuthHistory) AuthType() core.Interface  { return core.Interface{m["auth_type"]} }
func (m UserAuthHistory) AuthKey() core.Interface   { return core.Interface{m["auth_key"]} }
func (m UserAuthHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m UserAuthHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserAuthHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserAuthHistory, 5)
	res["user_id"] = data[0]
	res["auth_type"] = data[1]
	res["auth_key"] = data[2]
	res["created_at"] = data[3]
	res["updated_at"] = data[4]
	*m = res
	return nil
}

func (ms *UserAuthHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 5)
	args := make([]interface{}, 5)
	for i := 0; i < 5; i++ {
		args[i] = &data[i]
	}
	res := make(UserAuthHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserAuthHistory)
		m["user_id"] = data[0]
		m["auth_type"] = data[1]
		m["auth_key"] = data[2]
		m["created_at"] = data[3]
		m["updated_at"] = data[4]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type UserInternal represents table user_internal
func sqlgenUserInternal(_ *UserInternal) bool { return true }

type UserInternals []*UserInternal

const __sqlUserInternal_Table = "user_internal"
const __sqlUserInternal_ListCols = "\"id\",\"hashpwd\",\"updated_at\""
const __sqlUserInternal_Insert = "INSERT INTO \"user_internal\" (" + __sqlUserInternal_ListCols + ") VALUES"
const __sqlUserInternal_Select = "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\""
const __sqlUserInternal_Select_history = "SELECT " + __sqlUserInternal_ListCols + " FROM history.\"user_internal\""
const __sqlUserInternal_UpdateAll = "UPDATE \"user_internal\" SET (" + __sqlUserInternal_ListCols + ")"

func (m *UserInternal) SQLTableName() string  { return "user_internal" }
func (m *UserInternals) SQLTableName() string { return "user_internal" }
func (m *UserInternal) SQLListCols() string   { return __sqlUserInternal_ListCols }

func (m *UserInternal) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlUserInternal_ListCols + " FROM \"user_internal\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*UserInternal)(nil))
}

func (m *UserInternal) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Hashpwd),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *UserInternal) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Hashpwd),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *UserInternal) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *UserInternals) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(UserInternals, 0, 128)
	for rows.Next() {
		m := new(UserInternal)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *UserInternal) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (_ *UserInternals) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select)
	return nil
}

func (m *UserInternal) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms UserInternals) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *UserInternal) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("user_internal")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Hashpwd != "" {
		flag = true
		w.WriteName("hashpwd")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Hashpwd)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *UserInternal) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type UserInternalHistory map[string]interface{}
type UserInternalHistories []map[string]interface{}

func (m *UserInternalHistory) SQLTableName() string  { return "history.\"user_internal\"" }
func (m UserInternalHistories) SQLTableName() string { return "history.\"user_internal\"" }

func (m *UserInternalHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlUserInternal_Select_history)
	return nil
}

func (m UserInternalHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m UserInternalHistory) Hashpwd() core.Interface   { return core.Interface{m["hashpwd"]} }
func (m UserInternalHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *UserInternalHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(UserInternalHistory, 3)
	res["id"] = data[0]
	res["hashpwd"] = data[1]
	res["updated_at"] = data[2]
	*m = res
	return nil
}

func (ms *UserInternalHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(UserInternalHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(UserInternalHistory)
		m["id"] = data[0]
		m["hashpwd"] = data[1]
		m["updated_at"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Address represents table address
func sqlgenAddress(_ *Address) bool { return true }

type Addresses []*Address

const __sqlAddress_Table = "address"
const __sqlAddress_ListCols = "\"id\",\"full_name\",\"first_name\",\"last_name\",\"phone\",\"position\",\"email\",\"country\",\"city\",\"province\",\"district\",\"ward\",\"zip\",\"district_code\",\"province_code\",\"ward_code\",\"company\",\"address1\",\"address2\",\"type\",\"account_id\",\"notes\",\"created_at\",\"updated_at\",\"coordinates\""
const __sqlAddress_Insert = "INSERT INTO \"address\" (" + __sqlAddress_ListCols + ") VALUES"
const __sqlAddress_Select = "SELECT " + __sqlAddress_ListCols + " FROM \"address\""
const __sqlAddress_Select_history = "SELECT " + __sqlAddress_ListCols + " FROM history.\"address\""
const __sqlAddress_UpdateAll = "UPDATE \"address\" SET (" + __sqlAddress_ListCols + ")"

func (m *Address) SQLTableName() string   { return "address" }
func (m *Addresses) SQLTableName() string { return "address" }
func (m *Address) SQLListCols() string    { return __sqlAddress_ListCols }

func (m *Address) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlAddress_ListCols + " FROM \"address\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Address)(nil))
}

func (m *Address) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.FullName),
		core.String(m.FirstName),
		core.String(m.LastName),
		core.String(m.Phone),
		core.String(m.Position),
		core.String(m.Email),
		core.String(m.Country),
		core.String(m.City),
		core.String(m.Province),
		core.String(m.District),
		core.String(m.Ward),
		core.String(m.Zip),
		core.String(m.DistrictCode),
		core.String(m.ProvinceCode),
		core.String(m.WardCode),
		core.String(m.Company),
		core.String(m.Address1),
		core.String(m.Address2),
		core.String(m.Type),
		m.AccountID,
		core.JSON{m.Notes},
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.JSON{m.Coordinates},
	}
}

func (m *Address) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.FullName),
		(*core.String)(&m.FirstName),
		(*core.String)(&m.LastName),
		(*core.String)(&m.Phone),
		(*core.String)(&m.Position),
		(*core.String)(&m.Email),
		(*core.String)(&m.Country),
		(*core.String)(&m.City),
		(*core.String)(&m.Province),
		(*core.String)(&m.District),
		(*core.String)(&m.Ward),
		(*core.String)(&m.Zip),
		(*core.String)(&m.DistrictCode),
		(*core.String)(&m.ProvinceCode),
		(*core.String)(&m.WardCode),
		(*core.String)(&m.Company),
		(*core.String)(&m.Address1),
		(*core.String)(&m.Address2),
		(*core.String)(&m.Type),
		&m.AccountID,
		core.JSON{&m.Notes},
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		core.JSON{&m.Coordinates},
	}
}

func (m *Address) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Addresses) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Addresses, 0, 128)
	for rows.Next() {
		m := new(Address)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Address) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Select)
	return nil
}

func (_ *Addresses) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Select)
	return nil
}

func (m *Address) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(25)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Addresses) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(25)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Address) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("address")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.FullName != "" {
		flag = true
		w.WriteName("full_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FullName)
	}
	if m.FirstName != "" {
		flag = true
		w.WriteName("first_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FirstName)
	}
	if m.LastName != "" {
		flag = true
		w.WriteName("last_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.LastName)
	}
	if m.Phone != "" {
		flag = true
		w.WriteName("phone")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Phone)
	}
	if m.Position != "" {
		flag = true
		w.WriteName("position")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Position)
	}
	if m.Email != "" {
		flag = true
		w.WriteName("email")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email)
	}
	if m.Country != "" {
		flag = true
		w.WriteName("country")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Country)
	}
	if m.City != "" {
		flag = true
		w.WriteName("city")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.City)
	}
	if m.Province != "" {
		flag = true
		w.WriteName("province")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Province)
	}
	if m.District != "" {
		flag = true
		w.WriteName("district")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.District)
	}
	if m.Ward != "" {
		flag = true
		w.WriteName("ward")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Ward)
	}
	if m.Zip != "" {
		flag = true
		w.WriteName("zip")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Zip)
	}
	if m.DistrictCode != "" {
		flag = true
		w.WriteName("district_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DistrictCode)
	}
	if m.ProvinceCode != "" {
		flag = true
		w.WriteName("province_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ProvinceCode)
	}
	if m.WardCode != "" {
		flag = true
		w.WriteName("ward_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WardCode)
	}
	if m.Company != "" {
		flag = true
		w.WriteName("company")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Company)
	}
	if m.Address1 != "" {
		flag = true
		w.WriteName("address1")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Address1)
	}
	if m.Address2 != "" {
		flag = true
		w.WriteName("address2")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Address2)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.Notes != nil {
		flag = true
		w.WriteName("notes")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Notes})
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if m.Coordinates != nil {
		flag = true
		w.WriteName("coordinates")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Coordinates})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Address) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(25)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type AddressHistory map[string]interface{}
type AddressHistories []map[string]interface{}

func (m *AddressHistory) SQLTableName() string  { return "history.\"address\"" }
func (m AddressHistories) SQLTableName() string { return "history.\"address\"" }

func (m *AddressHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Select_history)
	return nil
}

func (m AddressHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlAddress_Select_history)
	return nil
}

func (m AddressHistory) ID() core.Interface           { return core.Interface{m["id"]} }
func (m AddressHistory) FullName() core.Interface     { return core.Interface{m["full_name"]} }
func (m AddressHistory) FirstName() core.Interface    { return core.Interface{m["first_name"]} }
func (m AddressHistory) LastName() core.Interface     { return core.Interface{m["last_name"]} }
func (m AddressHistory) Phone() core.Interface        { return core.Interface{m["phone"]} }
func (m AddressHistory) Position() core.Interface     { return core.Interface{m["position"]} }
func (m AddressHistory) Email() core.Interface        { return core.Interface{m["email"]} }
func (m AddressHistory) Country() core.Interface      { return core.Interface{m["country"]} }
func (m AddressHistory) City() core.Interface         { return core.Interface{m["city"]} }
func (m AddressHistory) Province() core.Interface     { return core.Interface{m["province"]} }
func (m AddressHistory) District() core.Interface     { return core.Interface{m["district"]} }
func (m AddressHistory) Ward() core.Interface         { return core.Interface{m["ward"]} }
func (m AddressHistory) Zip() core.Interface          { return core.Interface{m["zip"]} }
func (m AddressHistory) DistrictCode() core.Interface { return core.Interface{m["district_code"]} }
func (m AddressHistory) ProvinceCode() core.Interface { return core.Interface{m["province_code"]} }
func (m AddressHistory) WardCode() core.Interface     { return core.Interface{m["ward_code"]} }
func (m AddressHistory) Company() core.Interface      { return core.Interface{m["company"]} }
func (m AddressHistory) Address1() core.Interface     { return core.Interface{m["address1"]} }
func (m AddressHistory) Address2() core.Interface     { return core.Interface{m["address2"]} }
func (m AddressHistory) Type() core.Interface         { return core.Interface{m["type"]} }
func (m AddressHistory) AccountID() core.Interface    { return core.Interface{m["account_id"]} }
func (m AddressHistory) Notes() core.Interface        { return core.Interface{m["notes"]} }
func (m AddressHistory) CreatedAt() core.Interface    { return core.Interface{m["created_at"]} }
func (m AddressHistory) UpdatedAt() core.Interface    { return core.Interface{m["updated_at"]} }
func (m AddressHistory) Coordinates() core.Interface  { return core.Interface{m["coordinates"]} }

func (m *AddressHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 25)
	args := make([]interface{}, 25)
	for i := 0; i < 25; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(AddressHistory, 25)
	res["id"] = data[0]
	res["full_name"] = data[1]
	res["first_name"] = data[2]
	res["last_name"] = data[3]
	res["phone"] = data[4]
	res["position"] = data[5]
	res["email"] = data[6]
	res["country"] = data[7]
	res["city"] = data[8]
	res["province"] = data[9]
	res["district"] = data[10]
	res["ward"] = data[11]
	res["zip"] = data[12]
	res["district_code"] = data[13]
	res["province_code"] = data[14]
	res["ward_code"] = data[15]
	res["company"] = data[16]
	res["address1"] = data[17]
	res["address2"] = data[18]
	res["type"] = data[19]
	res["account_id"] = data[20]
	res["notes"] = data[21]
	res["created_at"] = data[22]
	res["updated_at"] = data[23]
	res["coordinates"] = data[24]
	*m = res
	return nil
}

func (ms *AddressHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 25)
	args := make([]interface{}, 25)
	for i := 0; i < 25; i++ {
		args[i] = &data[i]
	}
	res := make(AddressHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(AddressHistory)
		m["id"] = data[0]
		m["full_name"] = data[1]
		m["first_name"] = data[2]
		m["last_name"] = data[3]
		m["phone"] = data[4]
		m["position"] = data[5]
		m["email"] = data[6]
		m["country"] = data[7]
		m["city"] = data[8]
		m["province"] = data[9]
		m["district"] = data[10]
		m["ward"] = data[11]
		m["zip"] = data[12]
		m["district_code"] = data[13]
		m["province_code"] = data[14]
		m["ward_code"] = data[15]
		m["company"] = data[16]
		m["address1"] = data[17]
		m["address2"] = data[18]
		m["type"] = data[19]
		m["account_id"] = data[20]
		m["notes"] = data[21]
		m["created_at"] = data[22]
		m["updated_at"] = data[23]
		m["coordinates"] = data[24]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Code represents table code
func sqlgenCode(_ *Code) bool { return true }

type Codes []*Code

const __sqlCode_Table = "code"
const __sqlCode_ListCols = "\"code\",\"type\",\"created_at\""
const __sqlCode_Insert = "INSERT INTO \"code\" (" + __sqlCode_ListCols + ") VALUES"
const __sqlCode_Select = "SELECT " + __sqlCode_ListCols + " FROM \"code\""
const __sqlCode_Select_history = "SELECT " + __sqlCode_ListCols + " FROM history.\"code\""
const __sqlCode_UpdateAll = "UPDATE \"code\" SET (" + __sqlCode_ListCols + ")"

func (m *Code) SQLTableName() string  { return "code" }
func (m *Codes) SQLTableName() string { return "code" }
func (m *Code) SQLListCols() string   { return __sqlCode_ListCols }

func (m *Code) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlCode_ListCols + " FROM \"code\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Code)(nil))
}

func (m *Code) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		core.String(m.Code),
		core.String(m.Type),
		core.Now(m.CreatedAt, now, create),
	}
}

func (m *Code) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.Code),
		(*core.String)(&m.Type),
		(*core.Time)(&m.CreatedAt),
	}
}

func (m *Code) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Codes) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Codes, 0, 128)
	for rows.Next() {
		m := new(Code)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Code) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select)
	return nil
}

func (_ *Codes) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select)
	return nil
}

func (m *Code) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Codes) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(3)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Code) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("code")
	w.WriteRawString(" SET ")
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(string(m.Type))
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Code) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(3)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type CodeHistory map[string]interface{}
type CodeHistories []map[string]interface{}

func (m *CodeHistory) SQLTableName() string  { return "history.\"code\"" }
func (m CodeHistories) SQLTableName() string { return "history.\"code\"" }

func (m *CodeHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select_history)
	return nil
}

func (m CodeHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCode_Select_history)
	return nil
}

func (m CodeHistory) Code() core.Interface      { return core.Interface{m["code"]} }
func (m CodeHistory) Type() core.Interface      { return core.Interface{m["type"]} }
func (m CodeHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }

func (m *CodeHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(CodeHistory, 3)
	res["code"] = data[0]
	res["type"] = data[1]
	res["created_at"] = data[2]
	*m = res
	return nil
}

func (ms *CodeHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 3)
	args := make([]interface{}, 3)
	for i := 0; i < 3; i++ {
		args[i] = &data[i]
	}
	res := make(CodeHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(CodeHistory)
		m["code"] = data[0]
		m["type"] = data[1]
		m["created_at"] = data[2]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Credit represents table credit
func sqlgenCredit(_ *Credit) bool { return true }

type Credits []*Credit

const __sqlCredit_Table = "credit"
const __sqlCredit_ListCols = "\"id\",\"amount\",\"shop_id\",\"type\",\"status\",\"created_at\",\"updated_at\",\"paid_at\""
const __sqlCredit_Insert = "INSERT INTO \"credit\" (" + __sqlCredit_ListCols + ") VALUES"
const __sqlCredit_Select = "SELECT " + __sqlCredit_ListCols + " FROM \"credit\""
const __sqlCredit_Select_history = "SELECT " + __sqlCredit_ListCols + " FROM history.\"credit\""
const __sqlCredit_UpdateAll = "UPDATE \"credit\" SET (" + __sqlCredit_ListCols + ")"

func (m *Credit) SQLTableName() string  { return "credit" }
func (m *Credits) SQLTableName() string { return "credit" }
func (m *Credit) SQLListCols() string   { return __sqlCredit_ListCols }

func (m *Credit) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlCredit_ListCols + " FROM \"credit\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Credit)(nil))
}

func (m *Credit) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.Int(m.Amount),
		m.ShopID,
		core.String(m.Type),
		m.Status,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.PaidAt),
	}
}

func (m *Credit) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.Int)(&m.Amount),
		&m.ShopID,
		(*core.String)(&m.Type),
		&m.Status,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.PaidAt),
	}
}

func (m *Credit) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Credits) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Credits, 0, 128)
	for rows.Next() {
		m := new(Credit)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Credit) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Select)
	return nil
}

func (_ *Credits) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Select)
	return nil
}

func (m *Credit) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Credits) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(8)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Credit) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("credit")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Amount != 0 {
		flag = true
		w.WriteName("amount")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Amount)
	}
	if m.ShopID != 0 {
		flag = true
		w.WriteName("shop_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ShopID)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if m.Status != 0 {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.PaidAt.IsZero() {
		flag = true
		w.WriteName("paid_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.PaidAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Credit) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(8)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type CreditHistory map[string]interface{}
type CreditHistories []map[string]interface{}

func (m *CreditHistory) SQLTableName() string  { return "history.\"credit\"" }
func (m CreditHistories) SQLTableName() string { return "history.\"credit\"" }

func (m *CreditHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Select_history)
	return nil
}

func (m CreditHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCredit_Select_history)
	return nil
}

func (m CreditHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m CreditHistory) Amount() core.Interface    { return core.Interface{m["amount"]} }
func (m CreditHistory) ShopID() core.Interface    { return core.Interface{m["shop_id"]} }
func (m CreditHistory) Type() core.Interface      { return core.Interface{m["type"]} }
func (m CreditHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m CreditHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m CreditHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }
func (m CreditHistory) PaidAt() core.Interface    { return core.Interface{m["paid_at"]} }

func (m *CreditHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(CreditHistory, 8)
	res["id"] = data[0]
	res["amount"] = data[1]
	res["shop_id"] = data[2]
	res["type"] = data[3]
	res["status"] = data[4]
	res["created_at"] = data[5]
	res["updated_at"] = data[6]
	res["paid_at"] = data[7]
	*m = res
	return nil
}

func (ms *CreditHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 8)
	args := make([]interface{}, 8)
	for i := 0; i < 8; i++ {
		args[i] = &data[i]
	}
	res := make(CreditHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(CreditHistory)
		m["id"] = data[0]
		m["amount"] = data[1]
		m["shop_id"] = data[2]
		m["type"] = data[3]
		m["status"] = data[4]
		m["created_at"] = data[5]
		m["updated_at"] = data[6]
		m["paid_at"] = data[7]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type CreditExtended represents a join
func sqlgenCreditExtended(_ *CreditExtended, _ *Credit, as sq.AS, t0 sq.JOIN_TYPE, _ *Shop, a0 sq.AS, c0 string) bool {
	__sqlCreditExtended_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlCreditExtended_As = as
	__sqlCreditExtended_JoinAs = []sq.AS{a0}
	__sqlCreditExtended_JoinConds = []string{c0}
	return true
}

type CreditExtendeds []*CreditExtended

var __sqlCreditExtended_JoinTypes []sq.JOIN_TYPE
var __sqlCreditExtended_As sq.AS
var __sqlCreditExtended_JoinAs []sq.AS
var __sqlCreditExtended_JoinConds []string

func (m *CreditExtended) SQLTableName() string  { return "credit" }
func (m *CreditExtendeds) SQLTableName() string { return "credit" }

func (m *CreditExtended) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *CreditExtendeds) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(CreditExtendeds, 0, 128)
	for rows.Next() {
		m := new(CreditExtended)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *CreditExtended) SQLSelect(w SQLWriter) error {
	(*CreditExtended)(nil).__sqlSelect(w)
	w.WriteByte(' ')
	(*CreditExtended)(nil).__sqlJoin(w, __sqlCreditExtended_JoinTypes)
	return nil
}

func (m *CreditExtendeds) SQLSelect(w SQLWriter) error {
	return (*CreditExtended)(nil).SQLSelect(w)
}

func (m *CreditExtended) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	if len(types) == 0 {
		types = __sqlCreditExtended_JoinTypes
	}
	m.__sqlJoin(w, types)
	return nil
}

func (m *CreditExtendeds) SQLJoin(w SQLWriter, types []sq.JOIN_TYPE) error {
	return (*CreditExtended)(nil).SQLJoin(w, types)
}

func (m *CreditExtended) __sqlSelect(w SQLWriter) {
	w.WriteRawString("SELECT ")
	core.WriteCols(w, string(__sqlCreditExtended_As), (*Credit)(nil).SQLListCols())
	w.WriteByte(',')
	core.WriteCols(w, string(__sqlCreditExtended_JoinAs[0]), (*Shop)(nil).SQLListCols())
}

func (m *CreditExtended) __sqlJoin(w SQLWriter, types []sq.JOIN_TYPE) {
	if len(types) != 1 {
		panic("common/sql: expect 1 type to join")
	}
	w.WriteRawString("FROM ")
	w.WriteName("credit")
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlCreditExtended_As))
	w.WriteByte(' ')
	w.WriteRawString(string(types[0]))
	w.WriteRawString(" JOIN ")
	w.WriteName((*Shop)(nil).SQLTableName())
	w.WriteRawString(" AS ")
	w.WriteRawString(string(__sqlCreditExtended_JoinAs[0]))
	w.WriteRawString(" ON ")
	w.WriteQueryString(__sqlCreditExtended_JoinConds[0])
}

func (m *CreditExtended) SQLScanArgs(opts core.Opts) []interface{} {
	args := make([]interface{}, 0, 64) // TODO: pre-calculate length
	m.Credit = new(Credit)
	args = append(args, m.Credit.SQLScanArgs(opts)...)
	m.Shop = new(Shop)
	args = append(args, m.Shop.SQLScanArgs(opts)...)

	return args
}

// Type ShippingSource represents table shipping_source
func sqlgenShippingSource(_ *ShippingSource) bool { return true }

type ShippingSources []*ShippingSource

const __sqlShippingSource_Table = "shipping_source"
const __sqlShippingSource_ListCols = "\"id\",\"name\",\"username\",\"type\",\"created_at\",\"updated_at\""
const __sqlShippingSource_Insert = "INSERT INTO \"shipping_source\" (" + __sqlShippingSource_ListCols + ") VALUES"
const __sqlShippingSource_Select = "SELECT " + __sqlShippingSource_ListCols + " FROM \"shipping_source\""
const __sqlShippingSource_Select_history = "SELECT " + __sqlShippingSource_ListCols + " FROM history.\"shipping_source\""
const __sqlShippingSource_UpdateAll = "UPDATE \"shipping_source\" SET (" + __sqlShippingSource_ListCols + ")"

func (m *ShippingSource) SQLTableName() string  { return "shipping_source" }
func (m *ShippingSources) SQLTableName() string { return "shipping_source" }
func (m *ShippingSource) SQLListCols() string   { return __sqlShippingSource_ListCols }

func (m *ShippingSource) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShippingSource_ListCols + " FROM \"shipping_source\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShippingSource)(nil))
}

func (m *ShippingSource) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.String(m.Name),
		core.String(m.Username),
		core.String(m.Type),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
	}
}

func (m *ShippingSource) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.String)(&m.Name),
		(*core.String)(&m.Username),
		(*core.String)(&m.Type),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
	}
}

func (m *ShippingSource) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShippingSources) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShippingSources, 0, 128)
	for rows.Next() {
		m := new(ShippingSource)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShippingSource) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select)
	return nil
}

func (_ *ShippingSources) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select)
	return nil
}

func (m *ShippingSource) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShippingSources) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(6)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShippingSource) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shipping_source")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Name != "" {
		flag = true
		w.WriteName("name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Name)
	}
	if m.Username != "" {
		flag = true
		w.WriteName("username")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Username)
	}
	if m.Type != "" {
		flag = true
		w.WriteName("type")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Type)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShippingSource) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShippingSourceHistory map[string]interface{}
type ShippingSourceHistories []map[string]interface{}

func (m *ShippingSourceHistory) SQLTableName() string  { return "history.\"shipping_source\"" }
func (m ShippingSourceHistories) SQLTableName() string { return "history.\"shipping_source\"" }

func (m *ShippingSourceHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select_history)
	return nil
}

func (m ShippingSourceHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSource_Select_history)
	return nil
}

func (m ShippingSourceHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m ShippingSourceHistory) Name() core.Interface      { return core.Interface{m["name"]} }
func (m ShippingSourceHistory) Username() core.Interface  { return core.Interface{m["username"]} }
func (m ShippingSourceHistory) Type() core.Interface      { return core.Interface{m["type"]} }
func (m ShippingSourceHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m ShippingSourceHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *ShippingSourceHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShippingSourceHistory, 6)
	res["id"] = data[0]
	res["name"] = data[1]
	res["username"] = data[2]
	res["type"] = data[3]
	res["created_at"] = data[4]
	res["updated_at"] = data[5]
	*m = res
	return nil
}

func (ms *ShippingSourceHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	res := make(ShippingSourceHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShippingSourceHistory)
		m["id"] = data[0]
		m["name"] = data[1]
		m["username"] = data[2]
		m["type"] = data[3]
		m["created_at"] = data[4]
		m["updated_at"] = data[5]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type ShippingSourceInternal represents table shipping_source_internal
func sqlgenShippingSourceInternal(_ *ShippingSourceInternal) bool { return true }

type ShippingSourceInternals []*ShippingSourceInternal

const __sqlShippingSourceInternal_Table = "shipping_source_internal"
const __sqlShippingSourceInternal_ListCols = "\"id\",\"created_at\",\"updated_at\",\"last_sync_at\",\"access_token\",\"expires_at\",\"secret\""
const __sqlShippingSourceInternal_Insert = "INSERT INTO \"shipping_source_internal\" (" + __sqlShippingSourceInternal_ListCols + ") VALUES"
const __sqlShippingSourceInternal_Select = "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM \"shipping_source_internal\""
const __sqlShippingSourceInternal_Select_history = "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM history.\"shipping_source_internal\""
const __sqlShippingSourceInternal_UpdateAll = "UPDATE \"shipping_source_internal\" SET (" + __sqlShippingSourceInternal_ListCols + ")"

func (m *ShippingSourceInternal) SQLTableName() string  { return "shipping_source_internal" }
func (m *ShippingSourceInternals) SQLTableName() string { return "shipping_source_internal" }
func (m *ShippingSourceInternal) SQLListCols() string   { return __sqlShippingSourceInternal_ListCols }

func (m *ShippingSourceInternal) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlShippingSourceInternal_ListCols + " FROM \"shipping_source_internal\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*ShippingSourceInternal)(nil))
}

func (m *ShippingSourceInternal) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.LastSyncAt),
		core.String(m.AccessToken),
		core.Time(m.ExpiresAt),
		core.JSON{m.Secret},
	}
}

func (m *ShippingSourceInternal) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.LastSyncAt),
		(*core.String)(&m.AccessToken),
		(*core.Time)(&m.ExpiresAt),
		core.JSON{&m.Secret},
	}
}

func (m *ShippingSourceInternal) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *ShippingSourceInternals) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(ShippingSourceInternals, 0, 128)
	for rows.Next() {
		m := new(ShippingSourceInternal)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *ShippingSourceInternal) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select)
	return nil
}

func (_ *ShippingSourceInternals) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select)
	return nil
}

func (m *ShippingSourceInternal) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms ShippingSourceInternals) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(7)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *ShippingSourceInternal) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("shipping_source_internal")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.LastSyncAt.IsZero() {
		flag = true
		w.WriteName("last_sync_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.LastSyncAt)
	}
	if m.AccessToken != "" {
		flag = true
		w.WriteName("access_token")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccessToken)
	}
	if !m.ExpiresAt.IsZero() {
		flag = true
		w.WriteName("expires_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExpiresAt)
	}
	if m.Secret != nil {
		flag = true
		w.WriteName("secret")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Secret})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *ShippingSourceInternal) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(7)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type ShippingSourceInternalHistory map[string]interface{}
type ShippingSourceInternalHistories []map[string]interface{}

func (m *ShippingSourceInternalHistory) SQLTableName() string {
	return "history.\"shipping_source_internal\""
}
func (m ShippingSourceInternalHistories) SQLTableName() string {
	return "history.\"shipping_source_internal\""
}

func (m *ShippingSourceInternalHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select_history)
	return nil
}

func (m ShippingSourceInternalHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlShippingSourceInternal_Select_history)
	return nil
}

func (m ShippingSourceInternalHistory) ID() core.Interface { return core.Interface{m["id"]} }
func (m ShippingSourceInternalHistory) CreatedAt() core.Interface {
	return core.Interface{m["created_at"]}
}
func (m ShippingSourceInternalHistory) UpdatedAt() core.Interface {
	return core.Interface{m["updated_at"]}
}
func (m ShippingSourceInternalHistory) LastSyncAt() core.Interface {
	return core.Interface{m["last_sync_at"]}
}
func (m ShippingSourceInternalHistory) AccessToken() core.Interface {
	return core.Interface{m["access_token"]}
}
func (m ShippingSourceInternalHistory) ExpiresAt() core.Interface {
	return core.Interface{m["expires_at"]}
}
func (m ShippingSourceInternalHistory) Secret() core.Interface { return core.Interface{m["secret"]} }

func (m *ShippingSourceInternalHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(ShippingSourceInternalHistory, 7)
	res["id"] = data[0]
	res["created_at"] = data[1]
	res["updated_at"] = data[2]
	res["last_sync_at"] = data[3]
	res["access_token"] = data[4]
	res["expires_at"] = data[5]
	res["secret"] = data[6]
	*m = res
	return nil
}

func (ms *ShippingSourceInternalHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 7)
	args := make([]interface{}, 7)
	for i := 0; i < 7; i++ {
		args[i] = &data[i]
	}
	res := make(ShippingSourceInternalHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(ShippingSourceInternalHistory)
		m["id"] = data[0]
		m["created_at"] = data[1]
		m["updated_at"] = data[2]
		m["last_sync_at"] = data[3]
		m["access_token"] = data[4]
		m["expires_at"] = data[5]
		m["secret"] = data[6]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Webhook represents table webhook
func sqlgenWebhook(_ *Webhook) bool { return true }

type Webhooks []*Webhook

const __sqlWebhook_Table = "webhook"
const __sqlWebhook_ListCols = "\"id\",\"account_id\",\"entities\",\"fields\",\"url\",\"metadata\",\"created_at\",\"updated_at\",\"deleted_at\""
const __sqlWebhook_Insert = "INSERT INTO \"webhook\" (" + __sqlWebhook_ListCols + ") VALUES"
const __sqlWebhook_Select = "SELECT " + __sqlWebhook_ListCols + " FROM \"webhook\""
const __sqlWebhook_Select_history = "SELECT " + __sqlWebhook_ListCols + " FROM history.\"webhook\""
const __sqlWebhook_UpdateAll = "UPDATE \"webhook\" SET (" + __sqlWebhook_ListCols + ")"

func (m *Webhook) SQLTableName() string  { return "webhook" }
func (m *Webhooks) SQLTableName() string { return "webhook" }
func (m *Webhook) SQLListCols() string   { return __sqlWebhook_ListCols }

func (m *Webhook) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlWebhook_ListCols + " FROM \"webhook\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Webhook)(nil))
}

func (m *Webhook) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.AccountID,
		core.Array{m.Entities, opts},
		core.Array{m.Fields, opts},
		core.String(m.URL),
		core.String(m.Metadata),
		core.Now(m.CreatedAt, now, create),
		core.Now(m.UpdatedAt, now, true),
		core.Time(m.DeletedAt),
	}
}

func (m *Webhook) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.AccountID,
		core.Array{&m.Entities, opts},
		core.Array{&m.Fields, opts},
		(*core.String)(&m.URL),
		(*core.String)(&m.Metadata),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.UpdatedAt),
		(*core.Time)(&m.DeletedAt),
	}
}

func (m *Webhook) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Webhooks) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Webhooks, 0, 128)
	for rows.Next() {
		m := new(Webhook)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Webhook) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Select)
	return nil
}

func (_ *Webhooks) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Select)
	return nil
}

func (m *Webhook) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(9)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Webhooks) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(9)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Webhook) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("webhook")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if m.Entities != nil {
		flag = true
		w.WriteName("entities")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Entities, opts})
	}
	if m.Fields != nil {
		flag = true
		w.WriteName("fields")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Array{m.Fields, opts})
	}
	if m.URL != "" {
		flag = true
		w.WriteName("url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.URL)
	}
	if m.Metadata != "" {
		flag = true
		w.WriteName("metadata")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Metadata)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.UpdatedAt.IsZero() {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.Now(m.UpdatedAt, time.Now(), true))
	}
	if !m.DeletedAt.IsZero() {
		flag = true
		w.WriteName("deleted_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.DeletedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Webhook) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(9)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type WebhookHistory map[string]interface{}
type WebhookHistories []map[string]interface{}

func (m *WebhookHistory) SQLTableName() string  { return "history.\"webhook\"" }
func (m WebhookHistories) SQLTableName() string { return "history.\"webhook\"" }

func (m *WebhookHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Select_history)
	return nil
}

func (m WebhookHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlWebhook_Select_history)
	return nil
}

func (m WebhookHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m WebhookHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m WebhookHistory) Entities() core.Interface  { return core.Interface{m["entities"]} }
func (m WebhookHistory) Fields() core.Interface    { return core.Interface{m["fields"]} }
func (m WebhookHistory) URL() core.Interface       { return core.Interface{m["url"]} }
func (m WebhookHistory) Metadata() core.Interface  { return core.Interface{m["metadata"]} }
func (m WebhookHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m WebhookHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }
func (m WebhookHistory) DeletedAt() core.Interface { return core.Interface{m["deleted_at"]} }

func (m *WebhookHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 9)
	args := make([]interface{}, 9)
	for i := 0; i < 9; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(WebhookHistory, 9)
	res["id"] = data[0]
	res["account_id"] = data[1]
	res["entities"] = data[2]
	res["fields"] = data[3]
	res["url"] = data[4]
	res["metadata"] = data[5]
	res["created_at"] = data[6]
	res["updated_at"] = data[7]
	res["deleted_at"] = data[8]
	*m = res
	return nil
}

func (ms *WebhookHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 9)
	args := make([]interface{}, 9)
	for i := 0; i < 9; i++ {
		args[i] = &data[i]
	}
	res := make(WebhookHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(WebhookHistory)
		m["id"] = data[0]
		m["account_id"] = data[1]
		m["entities"] = data[2]
		m["fields"] = data[3]
		m["url"] = data[4]
		m["metadata"] = data[5]
		m["created_at"] = data[6]
		m["updated_at"] = data[7]
		m["deleted_at"] = data[8]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

// Type Callback represents table callback
func sqlgenChangesData(_ *Callback) bool { return true }

type Callbacks []*Callback

const __sqlCallback_Table = "callback"
const __sqlCallback_ListCols = "\"id\",\"webhook_id\",\"account_id\",\"created_at\",\"changes\",\"result\""
const __sqlCallback_Insert = "INSERT INTO \"callback\" (" + __sqlCallback_ListCols + ") VALUES"
const __sqlCallback_Select = "SELECT " + __sqlCallback_ListCols + " FROM \"callback\""
const __sqlCallback_Select_history = "SELECT " + __sqlCallback_ListCols + " FROM history.\"callback\""
const __sqlCallback_UpdateAll = "UPDATE \"callback\" SET (" + __sqlCallback_ListCols + ")"

func (m *Callback) SQLTableName() string  { return "callback" }
func (m *Callbacks) SQLTableName() string { return "callback" }
func (m *Callback) SQLListCols() string   { return __sqlCallback_ListCols }

func (m *Callback) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlCallback_ListCols + " FROM \"callback\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Callback)(nil))
}

func (m *Callback) SQLArgs(opts core.Opts, create bool) []interface{} {
	now := time.Now()
	return []interface{}{
		m.ID,
		m.WebhookID,
		m.AccountID,
		core.Now(m.CreatedAt, now, create),
		core.JSON{m.Changes},
		core.JSON{m.Result},
	}
}

func (m *Callback) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		&m.ID,
		&m.WebhookID,
		&m.AccountID,
		(*core.Time)(&m.CreatedAt),
		core.JSON{&m.Changes},
		core.JSON{&m.Result},
	}
}

func (m *Callback) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Callbacks) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Callbacks, 0, 128)
	for rows.Next() {
		m := new(Callback)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Callback) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Select)
	return nil
}

func (_ *Callbacks) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Select)
	return nil
}

func (m *Callback) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Callbacks) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(6)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Callback) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("callback")
	w.WriteRawString(" SET ")
	if m.ID != 0 {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.WebhookID != 0 {
		flag = true
		w.WriteName("webhook_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.WebhookID)
	}
	if m.AccountID != 0 {
		flag = true
		w.WriteName("account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AccountID)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if m.Changes != nil {
		flag = true
		w.WriteName("changes")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Changes})
	}
	if m.Result != nil {
		flag = true
		w.WriteName("result")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(core.JSON{m.Result})
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Callback) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(6)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type CallbackHistory map[string]interface{}
type CallbackHistories []map[string]interface{}

func (m *CallbackHistory) SQLTableName() string  { return "history.\"callback\"" }
func (m CallbackHistories) SQLTableName() string { return "history.\"callback\"" }

func (m *CallbackHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Select_history)
	return nil
}

func (m CallbackHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlCallback_Select_history)
	return nil
}

func (m CallbackHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m CallbackHistory) WebhookID() core.Interface { return core.Interface{m["webhook_id"]} }
func (m CallbackHistory) AccountID() core.Interface { return core.Interface{m["account_id"]} }
func (m CallbackHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m CallbackHistory) Changes() core.Interface   { return core.Interface{m["changes"]} }
func (m CallbackHistory) Result() core.Interface    { return core.Interface{m["result"]} }

func (m *CallbackHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(CallbackHistory, 6)
	res["id"] = data[0]
	res["webhook_id"] = data[1]
	res["account_id"] = data[2]
	res["created_at"] = data[3]
	res["changes"] = data[4]
	res["result"] = data[5]
	*m = res
	return nil
}

func (ms *CallbackHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 6)
	args := make([]interface{}, 6)
	for i := 0; i < 6; i++ {
		args[i] = &data[i]
	}
	res := make(CallbackHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(CallbackHistory)
		m["id"] = data[0]
		m["webhook_id"] = data[1]
		m["account_id"] = data[2]
		m["created_at"] = data[3]
		m["changes"] = data[4]
		m["result"] = data[5]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
