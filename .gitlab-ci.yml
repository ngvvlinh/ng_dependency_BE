stages:
- verify
- build
- test
- package
- deploy
- dev
- sandbox
- staging
- production

variables:
  GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME
  PROJECT_DIR: $CI_BUILDS_DIR/$CI_PROJECT_NAMESPACE

# cache: &global_cache
#   key: ${CI_COMMIT_REF_SLUG}
#   paths: [".cache"]
#   policy: pull

.go-cache:
  before_script:
    - mkdir -p .cache
    - export GOPATH="$CI_PROJECT_DIR/.cache" 
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .cache

verify:import:
  extends: .verify
  script:
    - time scripts/verify-imports.sh

verify:lint:
  extends: .verify
  script:
    - time scripts/ci/verify-lint.sh
 
verify:generate:
  extends: .verify
  script:
    - time scripts/ci/verify-generate.sh

build:
  image: golang:1.15
  stage: build
  extends: .go-cache
  script:
    - go install ./...
    - time scripts/install-tools.sh
  only:
    refs:
      - branches
    # changes:
    #   - "go.mod"
    #   - "go.sum"

test:
  image: golang:1.15
  stage: test
  extends: .go-cache
  services:
    - postgres:12.2-alpine
    - redis:latest
  variables:
    POSTGRES_DB: test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: "postgres"
    POSTGRES_HOST_AUTH_METHOD: trust
  dependencies: 
    - verify:import
    - verify:lint
    - verify:generate
  except: ["tags"] 
  script:
    - time go run ./scripts/init_testdb/main.go -drop
    - time scripts/ci/test-all.sh simple
 
include: 'ci/**.yml'
