// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package shop

import (
	context "context"
	fmt "fmt"
	http "net/http"

	proto "github.com/golang/protobuf/proto"

	common "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	order "etop.vn/backend/pb/etop/order"
	shop "etop.vn/backend/pb/etop/shop"
	httprpc "etop.vn/backend/pkg/common/httprpc"
)

type Server interface {
	http.Handler
	PathPrefix() string
}

type AccountServiceServer struct {
	AccountAPI
}

func NewAccountServiceServer(svc AccountAPI) Server {
	return &AccountServiceServer{
		AccountAPI: svc,
	}
}

const AccountServicePathPrefix = "/shop.Account/"

func (s *AccountServiceServer) PathPrefix() string {
	return AccountServicePathPrefix
}

func (s *AccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *AccountServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Account/CreateExternalAccountAhamove":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.CreateExternalAccountAhamove(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/DeleteShop":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.DeleteShop(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/GetBalanceShop":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.GetBalanceShop(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/GetExternalAccountAhamove":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.GetExternalAccountAhamove(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/RegisterShop":
		msg := new(shop.RegisterShopRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.RegisterShop(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/RequestVerifyExternalAccountAhamove":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.RequestVerifyExternalAccountAhamove(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/SetDefaultAddress":
		msg := new(etop.SetDefaultAddressRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.SetDefaultAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerification":
		msg := new(shop.UpdateXAccountAhamoveVerificationRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.UpdateExternalAccountAhamoveVerification(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/UpdateExternalAccountAhamoveVerificationImages":
		msg := new(shop.UpdateXAccountAhamoveVerificationRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.UpdateExternalAccountAhamoveVerificationImages(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Account/UpdateShop":
		msg := new(shop.UpdateShopRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AccountAPI.UpdateShop(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type AuthorizeServiceServer struct {
	AuthorizeAPI
}

func NewAuthorizeServiceServer(svc AuthorizeAPI) Server {
	return &AuthorizeServiceServer{
		AuthorizeAPI: svc,
	}
}

const AuthorizeServicePathPrefix = "/shop.Authorize/"

func (s *AuthorizeServiceServer) PathPrefix() string {
	return AuthorizeServicePathPrefix
}

func (s *AuthorizeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *AuthorizeServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Authorize/AuthorizePartner":
		msg := new(shop.AuthorizePartnerRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AuthorizeAPI.AuthorizePartner(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAuthorizedPartners":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AuthorizeAPI.GetAuthorizedPartners(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Authorize/GetAvailablePartners":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.AuthorizeAPI.GetAvailablePartners(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type BrandServiceServer struct {
	BrandAPI
}

func NewBrandServiceServer(svc BrandAPI) Server {
	return &BrandServiceServer{
		BrandAPI: svc,
	}
}

const BrandServicePathPrefix = "/shop.Brand/"

func (s *BrandServiceServer) PathPrefix() string {
	return BrandServicePathPrefix
}

func (s *BrandServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *BrandServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Brand/CreateBrand":
		msg := new(shop.CreateBrandRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.CreateBrand(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Brand/DeleteBrand":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.DeleteBrand(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandByID":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.GetBrandByID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrands":
		msg := new(shop.GetBrandsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.GetBrands(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Brand/GetBrandsByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.GetBrandsByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Brand/UpdateBrandInfo":
		msg := new(shop.UpdateBrandRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.BrandAPI.UpdateBrandInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CarrierServiceServer struct {
	CarrierAPI
}

func NewCarrierServiceServer(svc CarrierAPI) Server {
	return &CarrierServiceServer{
		CarrierAPI: svc,
	}
}

const CarrierServicePathPrefix = "/shop.Carrier/"

func (s *CarrierServiceServer) PathPrefix() string {
	return CarrierServicePathPrefix
}

func (s *CarrierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CarrierServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Carrier/CreateCarrier":
		msg := new(shop.CreateCarrierRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.CreateCarrier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Carrier/DeleteCarrier":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.DeleteCarrier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarrier":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.GetCarrier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriers":
		msg := new(shop.GetCarriersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.GetCarriers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Carrier/GetCarriersByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.GetCarriersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Carrier/UpdateCarrier":
		msg := new(shop.UpdateCarrierRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CarrierAPI.UpdateCarrier(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CategoryServiceServer struct {
	CategoryAPI
}

func NewCategoryServiceServer(svc CategoryAPI) Server {
	return &CategoryServiceServer{
		CategoryAPI: svc,
	}
}

const CategoryServicePathPrefix = "/shop.Category/"

func (s *CategoryServiceServer) PathPrefix() string {
	return CategoryServicePathPrefix
}

func (s *CategoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CategoryServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Category/CreateCategory":
		msg := new(shop.CreateCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CategoryAPI.CreateCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Category/DeleteCategory":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CategoryAPI.DeleteCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Category/GetCategories":
		msg := new(shop.GetCategoriesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CategoryAPI.GetCategories(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Category/GetCategory":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CategoryAPI.GetCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Category/UpdateCategory":
		msg := new(shop.UpdateCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CategoryAPI.UpdateCategory(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CollectionServiceServer struct {
	CollectionAPI
}

func NewCollectionServiceServer(svc CollectionAPI) Server {
	return &CollectionServiceServer{
		CollectionAPI: svc,
	}
}

const CollectionServicePathPrefix = "/shop.Collection/"

func (s *CollectionServiceServer) PathPrefix() string {
	return CollectionServicePathPrefix
}

func (s *CollectionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CollectionServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Collection/CreateCollection":
		msg := new(shop.CreateCollectionRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CollectionAPI.CreateCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollection":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CollectionAPI.GetCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollections":
		msg := new(shop.GetCollectionsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CollectionAPI.GetCollections(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Collection/GetCollectionsByProductID":
		msg := new(shop.GetShopCollectionsByProductIDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CollectionAPI.GetCollectionsByProductID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Collection/UpdateCollection":
		msg := new(shop.UpdateCollectionRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CollectionAPI.UpdateCollection(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerServiceServer struct {
	CustomerAPI
}

func NewCustomerServiceServer(svc CustomerAPI) Server {
	return &CustomerServiceServer{
		CustomerAPI: svc,
	}
}

const CustomerServicePathPrefix = "/shop.Customer/"

func (s *CustomerServiceServer) PathPrefix() string {
	return CustomerServicePathPrefix
}

func (s *CustomerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Customer/AddCustomersToGroup":
		msg := new(shop.AddCustomerToGroupRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.AddCustomersToGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/BatchSetCustomersStatus":
		msg := new(shop.SetCustomersStatusRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.BatchSetCustomersStatus(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomer":
		msg := new(shop.CreateCustomerRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.CreateCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/CreateCustomerAddress":
		msg := new(shop.CreateCustomerAddressRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.CreateCustomerAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomer":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.DeleteCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/DeleteCustomerAddress":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.DeleteCustomerAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomer":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.GetCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerAddresses":
		msg := new(shop.GetCustomerAddressesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.GetCustomerAddresses(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomerDetails":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.GetCustomerDetails(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomers":
		msg := new(shop.GetCustomersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.GetCustomers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/GetCustomersByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.GetCustomersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/RemoveCustomersFromGroup":
		msg := new(shop.RemoveCustomerOutOfGroupRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.RemoveCustomersFromGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/SetDefaultCustomerAddress":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.SetDefaultCustomerAddress(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomer":
		msg := new(shop.UpdateCustomerRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.UpdateCustomer(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Customer/UpdateCustomerAddress":
		msg := new(shop.UpdateCustomerAddressRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerAPI.UpdateCustomerAddress(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type CustomerGroupServiceServer struct {
	CustomerGroupAPI
}

func NewCustomerGroupServiceServer(svc CustomerGroupAPI) Server {
	return &CustomerGroupServiceServer{
		CustomerGroupAPI: svc,
	}
}

const CustomerGroupServicePathPrefix = "/shop.CustomerGroup/"

func (s *CustomerGroupServiceServer) PathPrefix() string {
	return CustomerGroupServicePathPrefix
}

func (s *CustomerGroupServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *CustomerGroupServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.CustomerGroup/CreateCustomerGroup":
		msg := new(shop.CreateCustomerGroupRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerGroupAPI.CreateCustomerGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroup":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerGroupAPI.GetCustomerGroup(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/GetCustomerGroups":
		msg := new(shop.GetCustomerGroupsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerGroupAPI.GetCustomerGroups(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.CustomerGroup/UpdateCustomerGroup":
		msg := new(shop.UpdateCustomerGroupRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.CustomerGroupAPI.UpdateCustomerGroup(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ExportServiceServer struct {
	ExportAPI
}

func NewExportServiceServer(svc ExportAPI) Server {
	return &ExportServiceServer{
		ExportAPI: svc,
	}
}

const ExportServicePathPrefix = "/shop.Export/"

func (s *ExportServiceServer) PathPrefix() string {
	return ExportServicePathPrefix
}

func (s *ExportServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ExportServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Export/GetExports":
		msg := new(shop.GetExportsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExportAPI.GetExports(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Export/RequestExport":
		msg := new(shop.RequestExportRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExportAPI.RequestExport(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ExternalAccountServiceServer struct {
	ExternalAccountAPI
}

func NewExternalAccountServiceServer(svc ExternalAccountAPI) Server {
	return &ExternalAccountServiceServer{
		ExternalAccountAPI: svc,
	}
}

const ExternalAccountServicePathPrefix = "/shop.ExternalAccount/"

func (s *ExternalAccountServiceServer) PathPrefix() string {
	return ExternalAccountServicePathPrefix
}

func (s *ExternalAccountServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ExternalAccountServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ExternalAccount/ConnectCarrierServiceExternalAccountHaravan":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExternalAccountAPI.ConnectCarrierServiceExternalAccountHaravan(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ExternalAccount/CreateExternalAccountHaravan":
		msg := new(shop.ExternalAccountHaravanRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExternalAccountAPI.CreateExternalAccountHaravan(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ExternalAccount/DeleteConnectedCarrierServiceExternalAccountHaravan":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExternalAccountAPI.DeleteConnectedCarrierServiceExternalAccountHaravan(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ExternalAccount/GetExternalAccountHaravan":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExternalAccountAPI.GetExternalAccountHaravan(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ExternalAccount/UpdateExternalAccountHaravanToken":
		msg := new(shop.ExternalAccountHaravanRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ExternalAccountAPI.UpdateExternalAccountHaravanToken(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type FulfillmentServiceServer struct {
	FulfillmentAPI
}

func NewFulfillmentServiceServer(svc FulfillmentAPI) Server {
	return &FulfillmentServiceServer{
		FulfillmentAPI: svc,
	}
}

const FulfillmentServicePathPrefix = "/shop.Fulfillment/"

func (s *FulfillmentServiceServer) PathPrefix() string {
	return FulfillmentServicePathPrefix
}

func (s *FulfillmentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *FulfillmentServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Fulfillment/GetExternalShippingServices":
		msg := new(order.GetExternalShippingServicesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.GetExternalShippingServices(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillment":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.GetFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetFulfillments":
		msg := new(shop.GetFulfillmentsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.GetFulfillments(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicExternalShippingServices":
		msg := new(order.GetExternalShippingServicesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.GetPublicExternalShippingServices(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/GetPublicFulfillment":
		msg := new(shop.GetPublicFulfillmentRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.GetPublicFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Fulfillment/UpdateFulfillmentsShippingState":
		msg := new(shop.UpdateFulfillmentsShippingStateRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.FulfillmentAPI.UpdateFulfillmentsShippingState(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type HistoryServiceServer struct {
	HistoryAPI
}

func NewHistoryServiceServer(svc HistoryAPI) Server {
	return &HistoryServiceServer{
		HistoryAPI: svc,
	}
}

const HistoryServicePathPrefix = "/shop.History/"

func (s *HistoryServiceServer) PathPrefix() string {
	return HistoryServicePathPrefix
}

func (s *HistoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *HistoryServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.History/GetFulfillmentHistory":
		msg := new(shop.GetFulfillmentHistoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.HistoryAPI.GetFulfillmentHistory(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InventoryServiceServer struct {
	InventoryAPI
}

func NewInventoryServiceServer(svc InventoryAPI) Server {
	return &InventoryServiceServer{
		InventoryAPI: svc,
	}
}

const InventoryServicePathPrefix = "/shop.Inventory/"

func (s *InventoryServiceServer) PathPrefix() string {
	return InventoryServicePathPrefix
}

func (s *InventoryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *InventoryServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Inventory/AdjustInventoryQuantity":
		msg := new(shop.AdjustInventoryQuantityRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.AdjustInventoryQuantity(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/CancelInventoryVoucher":
		msg := new(shop.CancelInventoryVoucherRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.CancelInventoryVoucher(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/ConfirmInventoryVoucher":
		msg := new(shop.ConfirmInventoryVoucherRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.ConfirmInventoryVoucher(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/CreateInventoryVoucher":
		msg := new(shop.CreateInventoryVoucherRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.CreateInventoryVoucher(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariant":
		msg := new(shop.GetInventoryVariantRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariants":
		msg := new(shop.GetInventoryVariantsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVariants(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVariantsByVariantIDs":
		msg := new(shop.GetInventoryVariantsByVariantIDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVariantsByVariantIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVoucher":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVoucher(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchers":
		msg := new(shop.GetInventoryVouchersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVouchers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByIDs":
		msg := new(shop.GetInventoryVouchersByIDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVouchersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/GetInventoryVouchersByReference":
		msg := new(shop.GetInventoryVouchersByReferenceRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.GetInventoryVouchersByReference(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVariantCostPrice":
		msg := new(shop.UpdateInventoryVariantCostPriceRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.UpdateInventoryVariantCostPrice(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Inventory/UpdateInventoryVoucher":
		msg := new(shop.UpdateInventoryVoucherRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InventoryAPI.UpdateInventoryVoucher(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type InvitationServiceServer struct {
	InvitationAPI
}

func NewInvitationServiceServer(svc InvitationAPI) Server {
	return &InvitationServiceServer{
		InvitationAPI: svc,
	}
}

const InvitationServicePathPrefix = "/shop.Invitation/"

func (s *InvitationServiceServer) PathPrefix() string {
	return InvitationServicePathPrefix
}

func (s *InvitationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *InvitationServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Invitation/CreateInvitation":
		msg := new(shop.CreateInvitationRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InvitationAPI.CreateInvitation(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Invitation/GetInvitations":
		msg := new(shop.GetInvitationsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.InvitationAPI.GetInvitations(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type LedgerServiceServer struct {
	LedgerAPI
}

func NewLedgerServiceServer(svc LedgerAPI) Server {
	return &LedgerServiceServer{
		LedgerAPI: svc,
	}
}

const LedgerServicePathPrefix = "/shop.Ledger/"

func (s *LedgerServiceServer) PathPrefix() string {
	return LedgerServicePathPrefix
}

func (s *LedgerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *LedgerServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Ledger/CreateLedger":
		msg := new(shop.CreateLedgerRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.LedgerAPI.CreateLedger(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Ledger/DeleteLedger":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.LedgerAPI.DeleteLedger(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedger":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.LedgerAPI.GetLedger(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Ledger/GetLedgers":
		msg := new(shop.GetLedgersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.LedgerAPI.GetLedgers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Ledger/UpdateLedger":
		msg := new(shop.UpdateLedgerRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.LedgerAPI.UpdateLedger(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	MiscAPI
}

func NewMiscServiceServer(svc MiscAPI) Server {
	return &MiscServiceServer{
		MiscAPI: svc,
	}
}

const MiscServicePathPrefix = "/shop.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Misc/VersionInfo":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.MiscAPI.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MoneyTransactionServiceServer struct {
	MoneyTransactionAPI
}

func NewMoneyTransactionServiceServer(svc MoneyTransactionAPI) Server {
	return &MoneyTransactionServiceServer{
		MoneyTransactionAPI: svc,
	}
}

const MoneyTransactionServicePathPrefix = "/shop.MoneyTransaction/"

func (s *MoneyTransactionServiceServer) PathPrefix() string {
	return MoneyTransactionServicePathPrefix
}

func (s *MoneyTransactionServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MoneyTransactionServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.MoneyTransaction/GetMoneyTransaction":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.MoneyTransactionAPI.GetMoneyTransaction(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.MoneyTransaction/GetMoneyTransactions":
		msg := new(shop.GetMoneyTransactionsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.MoneyTransactionAPI.GetMoneyTransactions(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type NotificationServiceServer struct {
	NotificationAPI
}

func NewNotificationServiceServer(svc NotificationAPI) Server {
	return &NotificationServiceServer{
		NotificationAPI: svc,
	}
}

const NotificationServicePathPrefix = "/shop.Notification/"

func (s *NotificationServiceServer) PathPrefix() string {
	return NotificationServicePathPrefix
}

func (s *NotificationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *NotificationServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Notification/CreateDevice":
		msg := new(etop.CreateDeviceRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.NotificationAPI.CreateDevice(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Notification/DeleteDevice":
		msg := new(etop.DeleteDeviceRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.NotificationAPI.DeleteDevice(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotification":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.NotificationAPI.GetNotification(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Notification/GetNotifications":
		msg := new(etop.GetNotificationsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.NotificationAPI.GetNotifications(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Notification/UpdateNotifications":
		msg := new(etop.UpdateNotificationsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.NotificationAPI.UpdateNotifications(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type OrderServiceServer struct {
	OrderAPI
}

func NewOrderServiceServer(svc OrderAPI) Server {
	return &OrderServiceServer{
		OrderAPI: svc,
	}
}

const OrderServicePathPrefix = "/shop.Order/"

func (s *OrderServiceServer) PathPrefix() string {
	return OrderServicePathPrefix
}

func (s *OrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *OrderServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Order/CancelOrder":
		msg := new(shop.CancelOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.CancelOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrder":
		msg := new(shop.ConfirmOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.ConfirmOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/ConfirmOrderAndCreateFulfillments":
		msg := new(shop.OrderIDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.ConfirmOrderAndCreateFulfillments(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/CreateOrder":
		msg := new(order.CreateOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.CreateOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/GetOrder":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.GetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/GetOrders":
		msg := new(shop.GetOrdersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.GetOrders(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByIDs":
		msg := new(etop.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.GetOrdersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/GetOrdersByReceiptID":
		msg := new(shop.GetOrdersByReceiptIDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.GetOrdersByReceiptID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrder":
		msg := new(order.UpdateOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.UpdateOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderPaymentStatus":
		msg := new(shop.UpdateOrderPaymentStatusRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.UpdateOrderPaymentStatus(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrderShippingInfo":
		msg := new(shop.UpdateOrderShippingInfoRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.UpdateOrderShippingInfo(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Order/UpdateOrdersStatus":
		msg := new(shop.UpdateOrdersStatusRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.OrderAPI.UpdateOrdersStatus(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PaymentServiceServer struct {
	PaymentAPI
}

func NewPaymentServiceServer(svc PaymentAPI) Server {
	return &PaymentServiceServer{
		PaymentAPI: svc,
	}
}

const PaymentServicePathPrefix = "/shop.Payment/"

func (s *PaymentServiceServer) PathPrefix() string {
	return PaymentServicePathPrefix
}

func (s *PaymentServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *PaymentServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Payment/PaymentCheckReturnData":
		msg := new(shop.PaymentCheckReturnDataRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PaymentAPI.PaymentCheckReturnData(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Payment/PaymentTradingOrder":
		msg := new(shop.PaymentTradingOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PaymentAPI.PaymentTradingOrder(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductServiceServer struct {
	ProductAPI
}

func NewProductServiceServer(svc ProductAPI) Server {
	return &ProductServiceServer{
		ProductAPI: svc,
	}
}

const ProductServicePathPrefix = "/shop.Product/"

func (s *ProductServiceServer) PathPrefix() string {
	return ProductServicePathPrefix
}

func (s *ProductServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Product/AddProductCollection":
		msg := new(shop.AddShopProductCollectionRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.AddProductCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/CreateProduct":
		msg := new(shop.CreateProductRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.CreateProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/CreateVariant":
		msg := new(shop.CreateVariantRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.CreateVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetProduct":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetProducts":
		msg := new(shop.GetVariantsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetProducts(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetProductsByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetProductsByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetVariant":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetVariantsByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/GetVariantsBySupplierID":
		msg := new(shop.GetVariantsBySupplierIDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.GetVariantsBySupplierID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCategory":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.RemoveProductCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProductCollection":
		msg := new(shop.RemoveShopProductCollectionRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.RemoveProductCollection(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/RemoveProducts":
		msg := new(shop.RemoveVariantsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.RemoveProducts(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/RemoveVariants":
		msg := new(shop.RemoveVariantsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.RemoveVariants(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProduct":
		msg := new(shop.UpdateProductRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductCategory":
		msg := new(shop.UpdateProductCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProductCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductImages":
		msg := new(shop.UpdateVariantImagesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProductImages(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductMetaFields":
		msg := new(shop.UpdateProductMetaFieldsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProductMetaFields(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsStatus":
		msg := new(shop.UpdateProductStatusRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProductsStatus(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateProductsTags":
		msg := new(shop.UpdateProductsTagsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateProductsTags(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariant":
		msg := new(shop.UpdateVariantRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantAttributes":
		msg := new(shop.UpdateVariantAttributesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateVariantAttributes(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantImages":
		msg := new(shop.UpdateVariantImagesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateVariantImages(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Product/UpdateVariantsStatus":
		msg := new(shop.UpdateProductStatusRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductAPI.UpdateVariantsStatus(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ProductSourceServiceServer struct {
	ProductSourceAPI
}

func NewProductSourceServiceServer(svc ProductSourceAPI) Server {
	return &ProductSourceServiceServer{
		ProductSourceAPI: svc,
	}
}

const ProductSourceServicePathPrefix = "/shop.ProductSource/"

func (s *ProductSourceServiceServer) PathPrefix() string {
	return ProductSourceServicePathPrefix
}

func (s *ProductSourceServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ProductSourceServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.ProductSource/CreateProductSource":
		msg := new(shop.CreateProductSourceRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.CreateProductSource(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateProductSourceCategory":
		msg := new(shop.CreatePSCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.CreateProductSourceCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/CreateVariant":
		msg := new(shop.DeprecatedCreateVariantRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.CreateVariant(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategories":
		msg := new(shop.GetProductSourceCategoriesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.GetProductSourceCategories(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetProductSourceCategory":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.GetProductSourceCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/GetShopProductSources":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.GetShopProductSources(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/RemoveProductSourceCategory":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.RemoveProductSourceCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductSourceCategory":
		msg := new(shop.UpdateProductSourceCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.UpdateProductSourceCategory(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.ProductSource/UpdateProductsPSCategory":
		msg := new(shop.UpdateProductsPSCategoryRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ProductSourceAPI.UpdateProductsPSCategory(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type PurchaseOrderServiceServer struct {
	PurchaseOrderAPI
}

func NewPurchaseOrderServiceServer(svc PurchaseOrderAPI) Server {
	return &PurchaseOrderServiceServer{
		PurchaseOrderAPI: svc,
	}
}

const PurchaseOrderServicePathPrefix = "/shop.PurchaseOrder/"

func (s *PurchaseOrderServiceServer) PathPrefix() string {
	return PurchaseOrderServicePathPrefix
}

func (s *PurchaseOrderServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *PurchaseOrderServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.PurchaseOrder/CancelPurchaseOrder":
		msg := new(shop.CancelPurchaseOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.CancelPurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/ConfirmPurchaseOrder":
		msg := new(shop.ConfirmPurchaseOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.ConfirmPurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/CreatePurchaseOrder":
		msg := new(shop.CreatePurchaseOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.CreatePurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/DeletePurchaseOrder":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.DeletePurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrder":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.GetPurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrders":
		msg := new(shop.GetPurchaseOrdersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.GetPurchaseOrders(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.GetPurchaseOrdersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/GetPurchaseOrdersByReceiptID":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.GetPurchaseOrdersByReceiptID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.PurchaseOrder/UpdatePurchaseOrder":
		msg := new(shop.UpdatePurchaseOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.PurchaseOrderAPI.UpdatePurchaseOrder(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ReceiptServiceServer struct {
	ReceiptAPI
}

func NewReceiptServiceServer(svc ReceiptAPI) Server {
	return &ReceiptServiceServer{
		ReceiptAPI: svc,
	}
}

const ReceiptServicePathPrefix = "/shop.Receipt/"

func (s *ReceiptServiceServer) PathPrefix() string {
	return ReceiptServicePathPrefix
}

func (s *ReceiptServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ReceiptServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Receipt/CancelReceipt":
		msg := new(shop.CancelReceiptRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.CancelReceipt(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/ConfirmReceipt":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.ConfirmReceipt(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/CreateReceipt":
		msg := new(shop.CreateReceiptRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.CreateReceipt(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipt":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.GetReceipt(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceipts":
		msg := new(shop.GetReceiptsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.GetReceipts(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/GetReceiptsByLedgerType":
		msg := new(shop.GetReceiptsByLedgerTypeRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.GetReceiptsByLedgerType(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Receipt/UpdateReceipt":
		msg := new(shop.UpdateReceiptRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ReceiptAPI.UpdateReceipt(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type ShipnowServiceServer struct {
	ShipnowAPI
}

func NewShipnowServiceServer(svc ShipnowAPI) Server {
	return &ShipnowServiceServer{
		ShipnowAPI: svc,
	}
}

const ShipnowServicePathPrefix = "/etop.Shipnow/"

func (s *ShipnowServiceServer) PathPrefix() string {
	return ShipnowServicePathPrefix
}

func (s *ShipnowServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *ShipnowServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/etop.Shipnow/CancelShipnowFulfillment":
		msg := new(order.CancelShipnowFulfillmentRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.CancelShipnowFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/ConfirmShipnowFulfillment":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.ConfirmShipnowFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/CreateShipnowFulfillment":
		msg := new(order.CreateShipnowFulfillmentRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.CreateShipnowFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/GetShipnowFulfillment":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.GetShipnowFulfillment(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/GetShipnowFulfillments":
		msg := new(order.GetShipnowFulfillmentsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.GetShipnowFulfillments(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/GetShipnowServices":
		msg := new(order.GetShipnowServicesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.GetShipnowServices(ctx, msg)
		}
		return msg, fn, nil
	case "/etop.Shipnow/UpdateShipnowFulfillment":
		msg := new(order.UpdateShipnowFulfillmentRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.ShipnowAPI.UpdateShipnowFulfillment(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type StocktakeServiceServer struct {
	StocktakeAPI
}

func NewStocktakeServiceServer(svc StocktakeAPI) Server {
	return &StocktakeServiceServer{
		StocktakeAPI: svc,
	}
}

const StocktakeServicePathPrefix = "/shop.Stocktake/"

func (s *StocktakeServiceServer) PathPrefix() string {
	return StocktakeServicePathPrefix
}

func (s *StocktakeServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *StocktakeServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Stocktake/CancelStocktake":
		msg := new(shop.CancelStocktakeRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.CancelStocktake(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/ConfirmStocktake":
		msg := new(shop.ConfirmStocktakeRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.ConfirmStocktake(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/CreateStocktake":
		msg := new(shop.CreateStocktakeRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.CreateStocktake(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktake":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.GetStocktake(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakes":
		msg := new(shop.GetStocktakesRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.GetStocktakes(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/GetStocktakesByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.GetStocktakesByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Stocktake/UpdateStocktake":
		msg := new(shop.UpdateStocktakeRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.StocktakeAPI.UpdateStocktake(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SummaryServiceServer struct {
	SummaryAPI
}

func NewSummaryServiceServer(svc SummaryAPI) Server {
	return &SummaryServiceServer{
		SummaryAPI: svc,
	}
}

const SummaryServicePathPrefix = "/shop.Summary/"

func (s *SummaryServiceServer) PathPrefix() string {
	return SummaryServicePathPrefix
}

func (s *SummaryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *SummaryServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Summary/CalcBalanceShop":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SummaryAPI.CalcBalanceShop(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizeFulfillments":
		msg := new(shop.SummarizeFulfillmentsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SummaryAPI.SummarizeFulfillments(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Summary/SummarizePOS":
		msg := new(shop.SummarizePOSRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SummaryAPI.SummarizePOS(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type SupplierServiceServer struct {
	SupplierAPI
}

func NewSupplierServiceServer(svc SupplierAPI) Server {
	return &SupplierServiceServer{
		SupplierAPI: svc,
	}
}

const SupplierServicePathPrefix = "/shop.Supplier/"

func (s *SupplierServiceServer) PathPrefix() string {
	return SupplierServicePathPrefix
}

func (s *SupplierServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *SupplierServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Supplier/CreateSupplier":
		msg := new(shop.CreateSupplierRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.CreateSupplier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/DeleteSupplier":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.DeleteSupplier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSupplier":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.GetSupplier(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliers":
		msg := new(shop.GetSuppliersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.GetSuppliers(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByIDs":
		msg := new(common.IDsRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.GetSuppliersByIDs(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/GetSuppliersByVariantID":
		msg := new(shop.GetSuppliersByVariantIDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.GetSuppliersByVariantID(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Supplier/UpdateSupplier":
		msg := new(shop.UpdateSupplierRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.SupplierAPI.UpdateSupplier(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type TradingServiceServer struct {
	TradingAPI
}

func NewTradingServiceServer(svc TradingAPI) Server {
	return &TradingServiceServer{
		TradingAPI: svc,
	}
}

const TradingServicePathPrefix = "/shop.Trading/"

func (s *TradingServiceServer) PathPrefix() string {
	return TradingServicePathPrefix
}

func (s *TradingServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *TradingServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/shop.Trading/TradingCreateOrder":
		msg := new(order.TradingCreateOrderRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.TradingAPI.TradingCreateOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrder":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.TradingAPI.TradingGetOrder(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetOrders":
		msg := new(shop.GetOrdersRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.TradingAPI.TradingGetOrders(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProduct":
		msg := new(common.IDRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.TradingAPI.TradingGetProduct(ctx, msg)
		}
		return msg, fn, nil
	case "/shop.Trading/TradingGetProducts":
		msg := new(common.CommonListRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.TradingAPI.TradingGetProducts(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
