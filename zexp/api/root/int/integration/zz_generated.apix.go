// +build !generator

// Code generated by generator apix. DO NOT EDIT.

package integration

import (
	context "context"
	fmt "fmt"
	http "net/http"

	proto "github.com/golang/protobuf/proto"

	common "etop.vn/backend/pb/common"
	integration "etop.vn/backend/pb/etop/integration"
	httprpc "etop.vn/backend/pkg/common/httprpc"
)

type Server interface {
	http.Handler
	PathPrefix() string
}

type IntegrationServiceServer struct {
	IntegrationAPI
}

func NewIntegrationServiceServer(svc IntegrationAPI) Server {
	return &IntegrationServiceServer{
		IntegrationAPI: svc,
	}
}

const IntegrationServicePathPrefix = "/integration.Integration/"

func (s *IntegrationServiceServer) PathPrefix() string {
	return IntegrationServicePathPrefix
}

func (s *IntegrationServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *IntegrationServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/integration.Integration/GrantAccess":
		msg := new(integration.GrantAccessRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.GrantAccess(ctx, msg)
		}
		return msg, fn, nil
	case "/integration.Integration/Init":
		msg := new(integration.InitRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.Init(ctx, msg)
		}
		return msg, fn, nil
	case "/integration.Integration/LoginUsingToken":
		msg := new(integration.LoginUsingTokenRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.LoginUsingToken(ctx, msg)
		}
		return msg, fn, nil
	case "/integration.Integration/Register":
		msg := new(integration.RegisterRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.Register(ctx, msg)
		}
		return msg, fn, nil
	case "/integration.Integration/RequestLogin":
		msg := new(integration.RequestLoginRequest)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.RequestLogin(ctx, msg)
		}
		return msg, fn, nil
	case "/integration.Integration/SessionInfo":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.IntegrationAPI.SessionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type MiscServiceServer struct {
	MiscAPI
}

func NewMiscServiceServer(svc MiscAPI) Server {
	return &MiscServiceServer{
		MiscAPI: svc,
	}
}

const MiscServicePathPrefix = "/integration.Misc/"

func (s *MiscServiceServer) PathPrefix() string {
	return MiscServicePathPrefix
}

func (s *MiscServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path)
	if err != nil {
		httprpc.WriteError(ctx, resp, err)
		return
	}
	serve(ctx, resp, req, reqMsg, exec)
}

func (s *MiscServiceServer) parseRoute(path string) (reqMsg proto.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/integration.Misc/VersionInfo":
		msg := new(common.Empty)
		fn := func(ctx context.Context) (proto.Message, error) {
			return s.MiscAPI.VersionInfo(ctx, msg)
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
