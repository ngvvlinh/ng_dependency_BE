// +build !generator

// Code generated by generator convert. DO NOT EDIT.

package test

import (
	scheme "etop.vn/backend/pkg/common/scheme"
)

func init() {
	registerConversionFunctions(scheme.Global)
}

func registerConversionFunctions(s *scheme.Scheme) {
	s.Register((*B)(nil), (*A)(nil), func(arg, out interface{}) error {
		Convert_B_A(arg.(*B), out.(*A))
		return nil
	})
	s.Register(([]*B)(nil), (*[]*A)(nil), func(arg, out interface{}) error {
		out0 := Convert_Bs_As(arg.([]*B))
		*out.(*[]*A) = out0
		return nil
	})
	s.Register((*A)(nil), (*B)(nil), func(arg, out interface{}) error {
		Convert_A_B(arg.(*A), out.(*B))
		return nil
	})
	s.Register(([]*A)(nil), (*[]*B)(nil), func(arg, out interface{}) error {
		out0 := Convert_As_Bs(arg.([]*A))
		*out.(*[]*B) = out0
		return nil
	})
}

//-- convert etop.vn/backend/tools/pkg/generators/convert/test.A --//

func Convert_B_A(arg *B, out *A) *A {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &A{}
	}
	convert_B_A(arg, out)
	return out
}

func convert_B_A(arg *B, out *A) {
	out.Value = 0 // types do not match
}

func Convert_Bs_As(args []*B) (outs []*A) {
	tmps := make([]A, len(args))
	outs = make([]*A, len(args))
	for i := range tmps {
		outs[i] = Convert_B_A(args[i], &tmps[i])
	}
	return outs
}

func Convert_A_B(arg *A, out *B) *B {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &B{}
	}
	ConvertAB(arg, out)
	return out
}

func convert_A_B(arg *A, out *B) {
	out.Value = "" // types do not match
}

func Convert_As_Bs(args []*A) (outs []*B) {
	tmps := make([]B, len(args))
	outs = make([]*B, len(args))
	for i := range tmps {
		outs[i] = Convert_A_B(args[i], &tmps[i])
	}
	return outs
}
