package generator

import (
	"bytes"
	"fmt"
	"go/types"
	"io"
	"strconv"

	"golang.org/x/tools/go/packages"
)

type Printer interface {
	FilePath() string
	Import(name, path string)
	TypeString(types.Type) string

	io.WriteCloser
}

var _ Printer = &printer{}

type printer struct {
	engine   *engine
	plugin   *pluginStruct
	pkg      *packages.Package
	filePath string
	closed   bool
	buf      *bytes.Buffer

	aliasByPkgPath map[string]string
	pkgPathByAlias map[string]string
}

func newPrinter(engine *engine, plugin *pluginStruct, pkg *packages.Package, filePath string) *printer {
	return &printer{
		engine:   engine,
		plugin:   plugin,
		pkg:      pkg,
		filePath: filePath,
		buf:      engine.bufPool.Get().(*bytes.Buffer),

		aliasByPkgPath: make(map[string]string),
		pkgPathByAlias: make(map[string]string),
	}
}

func (p *printer) FilePath() string {
	return p.filePath
}

func (p *printer) Write(data []byte) (n int, err error) {
	if p.closed {
		panic("already closed")
	}
	return p.buf.Write(data)
}

func (p *printer) Close() (_err error) {
	if p.closed {
		return nil
	}
	p.closed = true
	defer p.engine.bufPool.Put(p.buf)

	w, err := p.engine.writeFile(p.filePath)
	if err != nil {
		return err
	}
	defer func() {
		err := w.Close()
		if _err == nil {
			_err = err
		}
	}()

	fprintf := func(format string, args ...interface{}) {
		if _err != nil {
			return
		}
		_, err := fmt.Fprintf(w, format, args...)
		if err != nil {
			_err = err
			return
		}
	}
	fprintf("// +build !generator\n\n")
	fprintf("// Package %v generated by generator:%v. DO NOT EDIT.\n", p.pkg.Name, p.plugin.name)
	fprintf("package %v\n\n", p.pkg.Name)
	fprintf("import (\n")
	for path, alias := range p.aliasByPkgPath {
		fprintf("%v %q\n", alias, path)
	}
	fprintf(")\n\n")
	fprintf("%s", p.buf.Bytes())
	return
}

func (p *printer) Import(name, path string) {
	if _, ok := p.aliasByPkgPath[path]; ok {
		return
	}
	if name == "" {
		p.aliasByPkgPath[path] = ""
		return
	}
	alias := name
	if _, ok := p.pkgPathByAlias[alias]; ok {
		for c := 1; ; c++ {
			alias = name + strconv.Itoa(c)
			if _, exist := p.pkgPathByAlias[alias]; !exist {
				break
			}
		}
	}
	p.pkgPathByAlias[alias] = path
	p.aliasByPkgPath[path] = alias
}

func (p *printer) TypeString(typ types.Type) string {
	return types.TypeString(typ, p.qualifier)
}

func (p *printer) qualifier(pkg *types.Package) string {
	if pkg == p.pkg.Types {
		return ""
	}
	pkgPath := pkg.Path()
	p.Import(pkg.Name(), pkgPath)
	return p.aliasByPkgPath[pkgPath]
}
