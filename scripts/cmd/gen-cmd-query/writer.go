package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type MultiWriter struct {
	*Writer
	WriteArgs     bytes.Buffer
	WriteIface    bytes.Buffer
	WriteDispatch bytes.Buffer
}

func (ws *MultiWriter) GetImportWriter(w io.Writer) ImportWriter {
	return importWriterImpl{w, ws.Writer}
}

type ImportWriter interface {
	io.Writer
	Importer
}

type importWriterImpl struct {
	io.Writer
	Importer
}

type Importer interface {
	Import(path string) (alias string)
}

type Writer struct {
	PackageName string
	PackagePath string

	// map package path to alias
	Imports map[string]string
	// map alias to package path
	Aliases map[string]string

	Body *bytes.Buffer
}

func NewWriter(pkgName string, pkgPath string) *Writer {
	return &Writer{
		PackageName: pkgName,
		PackagePath: pkgPath,
		Imports:     make(map[string]string),
		Aliases:     make(map[string]string),
		Body:        &bytes.Buffer{},
	}
}

// /v1 /v1a, /v1beta, /v1/foo
var reVx = regexp.MustCompile(`[a-z0-9]+/v[0-9]+[A-z]*(/[_0-9A-z]+)?$`)

func (w *Writer) Import(path string) (alias string) {
	if path == w.PackagePath {
		return ""
	}

	_alias, ok := w.Imports[path]
	if ok {
		return _alias
	}

	count := 0
	base := filepath.Base(path)
	// we want to alias to pathv1 (pathv1sub) instead of v1
	// - package/path/v1:		pathv1
	// - package/path/v1/sub:	pathv1sub
	if match := reVx.FindString(path); match != "" {
		base = strings.ReplaceAll(match, "/", "")
	}

	expectAlias := base
	for {
		_path, ok := w.Aliases[expectAlias]
		if !ok || _path == path {
			w.Imports[path] = expectAlias
			w.Aliases[expectAlias] = path
			return expectAlias
		}

		count++
		expectAlias = fmt.Sprintf("%v%v", base, count)
	}
}

func (w *Writer) Write(p []byte) (n int, err error) {
	return w.Body.Write(p)
}

func (w *Writer) WriteTo(dst io.Writer) {
	p(dst, "// Code generated by gen-cmd-query. DO NOT EDIT.\n\n")
	p(dst, "package %v\n\n", w.PackageName)
	if len(w.Imports) > 0 {
		p(dst, "import (\n")
		for impPath, impAlias := range w.Imports {
			if impAlias == "" {
				p(dst, "%q\n", impPath)
			} else {
				p(dst, "%v %q\n", impAlias, impPath)
			}
		}
		p(dst, ")\n\n")
	}
	_, err := dst.Write(w.Body.Bytes())
	must(err)
}

func (w *Writer) WriteFile(filename string, perm os.FileMode) {
	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	must(err)
	w.WriteTo(f)
	must(f.Close())
}
