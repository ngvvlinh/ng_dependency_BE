package main

const tplStr = `// package {{.PackageName}} generated by wrapper_gen. DO NOT EDIT.
package {{.PackageName}}W

import (
	"context"

	"github.com/twitchtv/twirp"

	common "etop.vn/backend/pkg/common"
	"etop.vn/common/bus"
	"etop.vn/backend/pkg/common/grpc"
	"etop.vn/common/l"
	"etop.vn/backend/pkg/common/metrics"
	"etop.vn/backend/pkg/common/telebot"
	"etop.vn/backend/pkg/common/wrapper"
	"etop.vn/backend/pkg/etop/authorize/claims"
	"etop.vn/backend/pkg/etop/authorize/middleware"
	"etop.vn/backend/pkg/etop/authorize/permission"
	"etop.vn/backend/pkg/etop/model"
	cm "etop.vn/backend/pb/common"
	{{.PackageName}} "{{.PackagePath}}"
	{{range .Imports -}}
	{{.Name}} "{{.Path}}"
	{{end}}
)

var ll = l.New()

var Client {{.ServiceName}}

type {{.ServiceName}} interface {
{{range $s := .Services -}}
	{{$.PackageName}}.{{$s.Name}}
{{end -}}
}

type {{.ServiceName}}Client struct{
{{range $s := .Services -}}
	_{{$s.Name}} {{$.PackageName}}.{{$s.Name}}
{{end -}}
}

func New{{.ServiceName}}Client(addr string, client *http.Client) {{.ServiceName}}{
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &{{.ServiceName}}Client{
	{{range $s := .Services -}}
		_{{$s.Name}}: {{$.PackageName}}.New{{$s.Name}}ProtobufClient(addr, client),
	{{end -}}
	}
}

func Connect{{.ServiceName}}Service(addr string, client *http.Client{{if $.HasSecret}}, secret string{{end}}) error {
	Client = New{{.ServiceName}}Client(addr, client)
	{{range $s := .Services -}}
	{{range $m := .Methods -}}
	bus.AddHandler("client", func(ctx context.Context, q *{{$m.Name}}Endpoint) error { panic("Unexpected") })
	{{end -}}
	{{end -}}

	ctx, _ := context.WithTimeout(context.Background(), 10 * time.Second)
	{{if $.HasSecret}}ctx = cmGrpc.AppendAccessToken(ctx, secret)
	{{end -}}
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to {{.ServiceName}}Service at %v", addr)
	}
	return err
}

func MustConnect{{.ServiceName}}Service(addr string, client *http.Client{{if $.HasSecret}}, secret string{{end}}) {
	err := Connect{{.ServiceName}}Service(addr, client{{if $.HasSecret}}, secret{{end}})
	if err != nil {
		ll.Fatal("Unable to connect {{.ServiceName}}", l.Error(err))
	}
}

type (
	EmptyClaim    = claims.EmptyClaim
	UserClaim  	  = claims.UserClaim
	AdminClaim    = claims.AdminClaim
	PartnerClaim  = claims.PartnerClaim
	ShopClaim     = claims.ShopClaim
)

{{range $s := .Services -}}
{{range $m := .Methods -}}
func (c *{{$.ServiceName}}Client) {{$m.Name}}(ctx context.Context, in {{.InputType}}) ({{.OutputType}}, error) {
	resp, err := c._{{$s.Name}}.{{$m.Name}}(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result": resp,
	})
	newNode.Error = err
	return resp, err
}
{{end}}{{end}}

type Muxer interface {
	Handle(string, http.Handler)
}

func New{{.ServiceName}}Server(mux Muxer, hooks *twirp.ServerHooks{{if $.HasSecret}}, secret string{{end}}) {
	{{- if $.HasSecret -}}
	if secret == "" {
		ll.Fatal("Secret is empty")
	}
	{{end -}}

{{range $s := .Services -}}
{{range $m := .Methods -}}
	bus.Expect(&{{$m.Name}}Endpoint{})
{{end -}}
{{end -}}

{{range $s := .Services -}}
	mux.Handle({{$.PackageName}}.{{$s.Name}}PathPrefix, {{$.PackageName}}.New{{$s.Name}}Server({{$s.Name}}{ {{if $.HasSecret}}secret: secret{{end}} }, hooks))
{{end -}}
}

type {{.ServiceName}}Impl struct {
{{range $s := .Services -}}
	{{$s.Name}}
{{end -}}
}

func New{{.ServiceName}}() {{.ServiceName}} {
	return {{.ServiceName}}Impl{}
}

{{range $s := .Services}}
type {{$s.Name}} struct { {{if $.HasSecret}}secret string{{end}} }

{{range $m := $s.Methods}}
type {{$m.Name}}Endpoint struct {
	{{$m.InputType}}
	Result {{$m.OutputType}}
	Context {{claim $m}}
	{{if authPartner $m}}CtxPartner *model.Partner{{end}}
}

func (s {{$s.Name}}) {{$m.Name}}(ctx context.Context, req {{$m.InputType}}) (resp {{$m.OutputType}}, err error) {
	t0 := time.Now()
	{{if requireAuth $m -}}
	var session *middleware.Session
	{{end -}}
	var errs []*cm.Error
	const rpcName = "{{$.PackageName}}.{{trimName $s.Name}}/{{$m.Name}}"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, {{if requireAuth $m}}session{{else}}nil{{end}}, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	{{- if requireAuth $m}}
	sessionQuery := &middleware.StartSessionQuery{
		Context: ctx,
		{{if requireAuth       $m}}RequireAuth: 	  true,
{{end}}	{{if requireUser       $m}}RequireUser: 	  true,
{{end}} {{if requireAPIKey     $m}}RequireAPIKey:     true,
{{end}} {{if requireAPIPartnerShopKey     $m}}RequireAPIPartnerShopKey:     true,
{{end}} {{if requirePartner    $m}}RequirePartner:    true,
{{end}}	{{if requireShop       $m}}RequireShop:       true,
{{end}}	{{if requireEtopAdmin  $m}}RequireEtopAdmin:  true,
{{end}}	{{if requireSuperAdmin $m}}RequireSuperAdmin: true,
{{end}} {{if authPartner       $m}}AuthPartner: {{authPartner $m}}, 
{{end}}
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	{{- end}}
	query := &{{$m.Name}}Endpoint{ {{baseName $m.InputType}}: req }
	{{if requireLogin $m -}}
	query.Context.Claim = session.Claim
	{{end -}}
	{{if requireUser $m -}}
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	{{end -}}
	{{if requirePartner $m -}}
	query.Context.Partner = session.Partner
	{{end -}}
	{{if requireShop $m -}}
	query.Context.Shop = session.Shop
	{{end -}}
	{{if requireEtopAdmin $m -}}
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	{{end -}}
	{{if requireSuperAdmin $m -}}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	{{end -}}
	{{if authPartner $m -}}
	query.CtxPartner = session.CtxPartner
	{{end -}}
	{{if authPartner $m | eq 0 | and (requireUser $m) -}}
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	{{end -}}
	{{if requireRole $m -}}
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
		{{if role $m | ne "" -}}
	// Verify that the user has role "{{role $m}}"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < {{roleLevel $m}} {
		return nil, common.ErrPermissionDenied
	}
		{{end -}}
	{{end -}}
	{{if requireSecret $m -}}
	// Verify secret token
	token := middleware.GetBearerTokenFromCtx(ctx)
	if token != s.secret {
		return nil, common.ErrUnauthenticated
	}
	{{end -}}
	{{if requireCaptcha $m -}}
	// Verify captcha token
	if err := middleware.VerifyCaptcha(ctx, req.RecaptchaToken); err != nil {
		return nil, err
	}
	{{end -}}

	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result 
	if err == nil {
		if resp == nil { 
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}
{{end}}
{{end}}
`
