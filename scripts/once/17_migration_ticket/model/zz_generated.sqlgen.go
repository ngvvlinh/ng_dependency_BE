// +build !generator

// Code generated by generator sqlgen. DO NOT EDIT.

package model

import (
	"database/sql"
	"sync"
	time "time"

	cmsql "o.o/backend/pkg/common/sql/cmsql"
	migration "o.o/backend/pkg/common/sql/migration"
	core "o.o/backend/pkg/common/sql/sq/core"
)

var __sqlModels []interface{ SQLVerifySchema(db *cmsql.Database) }
var __sqlonce sync.Once

func SQLVerifySchema(db *cmsql.Database) {
	__sqlonce.Do(func() {
		for _, m := range __sqlModels {
			m.SQLVerifySchema(db)
		}
	})
}

type SQLWriter = core.SQLWriter

type Tickets []*Ticket

const __sqlTicket_Table = "ticket"
const __sqlTicket_ListCols = "\"id\",\"assigned_user_id\",\"ticketstatus\",\"ticketcategories\",\"modifiedby\",\"ticket_title\",\"description\",\"contact_id\",\"note\",\"ffm_code\",\"ffm_url\",\"ffm_id\",\"etop_id\",\"order_id\",\"order_code\",\"company\",\"provider\",\"from_app\",\"code\",\"old_value\",\"new_value\",\"substatus\",\"etop_note\",\"reason\",\"created_at\",\"createdtime\",\"modified_at\",\"confirmed_at\",\"confirmed_by\",\"closed_at\",\"closed_by\",\"ticket_no\",\"etop_account_id\",\"external_id\",\"external_status\",\"external_cs_provider\",\"x_data\",\"x_error\",\"o_data\""
const __sqlTicket_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"assigned_user_id\" = EXCLUDED.\"assigned_user_id\",\"ticketstatus\" = EXCLUDED.\"ticketstatus\",\"ticketcategories\" = EXCLUDED.\"ticketcategories\",\"modifiedby\" = EXCLUDED.\"modifiedby\",\"ticket_title\" = EXCLUDED.\"ticket_title\",\"description\" = EXCLUDED.\"description\",\"contact_id\" = EXCLUDED.\"contact_id\",\"note\" = EXCLUDED.\"note\",\"ffm_code\" = EXCLUDED.\"ffm_code\",\"ffm_url\" = EXCLUDED.\"ffm_url\",\"ffm_id\" = EXCLUDED.\"ffm_id\",\"etop_id\" = EXCLUDED.\"etop_id\",\"order_id\" = EXCLUDED.\"order_id\",\"order_code\" = EXCLUDED.\"order_code\",\"company\" = EXCLUDED.\"company\",\"provider\" = EXCLUDED.\"provider\",\"from_app\" = EXCLUDED.\"from_app\",\"code\" = EXCLUDED.\"code\",\"old_value\" = EXCLUDED.\"old_value\",\"new_value\" = EXCLUDED.\"new_value\",\"substatus\" = EXCLUDED.\"substatus\",\"etop_note\" = EXCLUDED.\"etop_note\",\"reason\" = EXCLUDED.\"reason\",\"created_at\" = EXCLUDED.\"created_at\",\"createdtime\" = EXCLUDED.\"createdtime\",\"modified_at\" = EXCLUDED.\"modified_at\",\"confirmed_at\" = EXCLUDED.\"confirmed_at\",\"confirmed_by\" = EXCLUDED.\"confirmed_by\",\"closed_at\" = EXCLUDED.\"closed_at\",\"closed_by\" = EXCLUDED.\"closed_by\",\"ticket_no\" = EXCLUDED.\"ticket_no\",\"etop_account_id\" = EXCLUDED.\"etop_account_id\",\"external_id\" = EXCLUDED.\"external_id\",\"external_status\" = EXCLUDED.\"external_status\",\"external_cs_provider\" = EXCLUDED.\"external_cs_provider\",\"x_data\" = EXCLUDED.\"x_data\",\"x_error\" = EXCLUDED.\"x_error\",\"o_data\" = EXCLUDED.\"o_data\""
const __sqlTicket_Insert = "INSERT INTO \"ticket\" (" + __sqlTicket_ListCols + ") VALUES"
const __sqlTicket_Select = "SELECT " + __sqlTicket_ListCols + " FROM \"ticket\""
const __sqlTicket_Select_history = "SELECT " + __sqlTicket_ListCols + " FROM history.\"ticket\""
const __sqlTicket_UpdateAll = "UPDATE \"ticket\" SET (" + __sqlTicket_ListCols + ")"
const __sqlTicket_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_pkey DO UPDATE SET"

func (m *Ticket) SQLTableName() string  { return "ticket" }
func (m *Tickets) SQLTableName() string { return "ticket" }
func (m *Ticket) SQLListCols() string   { return __sqlTicket_ListCols }

func (m *Ticket) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicket_ListCols + " FROM \"ticket\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *Ticket) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"assigned_user_id": {
			ColumnName:       "assigned_user_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticketstatus": {
			ColumnName:       "ticketstatus",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticketcategories": {
			ColumnName:       "ticketcategories",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"modifiedby": {
			ColumnName:       "modifiedby",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticket_title": {
			ColumnName:       "ticket_title",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"description": {
			ColumnName:       "description",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"contact_id": {
			ColumnName:       "contact_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"note": {
			ColumnName:       "note",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ffm_code": {
			ColumnName:       "ffm_code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ffm_url": {
			ColumnName:       "ffm_url",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ffm_id": {
			ColumnName:       "ffm_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"etop_id": {
			ColumnName:       "etop_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"order_id": {
			ColumnName:       "order_id",
			ColumnType:       "dot.ID",
			ColumnDBType:     "int64",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"order_code": {
			ColumnName:       "order_code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"company": {
			ColumnName:       "company",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"provider": {
			ColumnName:       "provider",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"from_app": {
			ColumnName:       "from_app",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"code": {
			ColumnName:       "code",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"old_value": {
			ColumnName:       "old_value",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"new_value": {
			ColumnName:       "new_value",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"substatus": {
			ColumnName:       "substatus",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"etop_note": {
			ColumnName:       "etop_note",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"reason": {
			ColumnName:       "reason",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"createdtime": {
			ColumnName:       "createdtime",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"modified_at": {
			ColumnName:       "modified_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"confirmed_at": {
			ColumnName:       "confirmed_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"confirmed_by": {
			ColumnName:       "confirmed_by",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"closed_at": {
			ColumnName:       "closed_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"closed_by": {
			ColumnName:       "closed_by",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticket_no": {
			ColumnName:       "ticket_no",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"etop_account_id": {
			ColumnName:       "etop_account_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"external_id": {
			ColumnName:       "external_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"external_status": {
			ColumnName:       "external_status",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"external_cs_provider": {
			ColumnName:       "external_cs_provider",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"x_data": {
			ColumnName:       "x_data",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"x_error": {
			ColumnName:       "x_error",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"o_data": {
			ColumnName:       "o_data",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*Ticket)(nil))
}

func (m *Ticket) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.String(m.AssignedUserID),
		core.String(m.TicketStatus),
		core.String(m.TicketCategories),
		core.String(m.ModifiedBy),
		core.String(m.TicketTitle),
		core.String(m.Description),
		core.String(m.ContactID),
		core.String(m.Note),
		core.String(m.FfmCode),
		core.String(m.FfmUrl),
		core.String(m.FfmID),
		core.String(m.EtopID),
		m.OrderID,
		core.String(m.OrderCode),
		core.String(m.Company),
		core.String(m.Provider),
		core.String(m.FromApp),
		core.String(m.Code),
		core.String(m.OldValue),
		core.String(m.NewValue),
		core.String(m.SubStatus),
		core.String(m.EtopNote),
		core.String(m.Reason),
		core.Time(m.CreatedAt),
		core.Time(m.CreatedTime),
		core.Time(m.ModifiedAt),
		core.Time(m.ConfirmedAt),
		core.String(m.ConfirmedBy),
		core.Time(m.ClosedAt),
		core.String(m.ClosedBy),
		core.String(m.TicketNo),
		core.String(m.EtopAccountID),
		core.String(m.ExternalID),
		core.String(m.ExternalStatus),
		core.String(m.ExternalCSProvider),
		core.String(m.XData),
		core.String(m.XError),
		core.String(m.OData),
	}
}

func (m *Ticket) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		(*core.String)(&m.AssignedUserID),
		(*core.String)(&m.TicketStatus),
		(*core.String)(&m.TicketCategories),
		(*core.String)(&m.ModifiedBy),
		(*core.String)(&m.TicketTitle),
		(*core.String)(&m.Description),
		(*core.String)(&m.ContactID),
		(*core.String)(&m.Note),
		(*core.String)(&m.FfmCode),
		(*core.String)(&m.FfmUrl),
		(*core.String)(&m.FfmID),
		(*core.String)(&m.EtopID),
		&m.OrderID,
		(*core.String)(&m.OrderCode),
		(*core.String)(&m.Company),
		(*core.String)(&m.Provider),
		(*core.String)(&m.FromApp),
		(*core.String)(&m.Code),
		(*core.String)(&m.OldValue),
		(*core.String)(&m.NewValue),
		(*core.String)(&m.SubStatus),
		(*core.String)(&m.EtopNote),
		(*core.String)(&m.Reason),
		(*core.Time)(&m.CreatedAt),
		(*core.Time)(&m.CreatedTime),
		(*core.Time)(&m.ModifiedAt),
		(*core.Time)(&m.ConfirmedAt),
		(*core.String)(&m.ConfirmedBy),
		(*core.Time)(&m.ClosedAt),
		(*core.String)(&m.ClosedBy),
		(*core.String)(&m.TicketNo),
		(*core.String)(&m.EtopAccountID),
		(*core.String)(&m.ExternalID),
		(*core.String)(&m.ExternalStatus),
		(*core.String)(&m.ExternalCSProvider),
		(*core.String)(&m.XData),
		(*core.String)(&m.XError),
		(*core.String)(&m.OData),
	}
}

func (m *Ticket) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *Tickets) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(Tickets, 0, 128)
	for rows.Next() {
		m := new(Ticket)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *Ticket) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select)
	return nil
}

func (_ *Tickets) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select)
	return nil
}

func (m *Ticket) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(39)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms Tickets) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(39)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *Ticket) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicket_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicket_ListColsOnConflict)
	return nil
}

func (ms Tickets) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicket_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicket_ListColsOnConflict)
	return nil
}

func (m *Ticket) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.AssignedUserID != "" {
		flag = true
		w.WriteName("assigned_user_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.AssignedUserID)
	}
	if m.TicketStatus != "" {
		flag = true
		w.WriteName("ticketstatus")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketStatus)
	}
	if m.TicketCategories != "" {
		flag = true
		w.WriteName("ticketcategories")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketCategories)
	}
	if m.ModifiedBy != "" {
		flag = true
		w.WriteName("modifiedby")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ModifiedBy)
	}
	if m.TicketTitle != "" {
		flag = true
		w.WriteName("ticket_title")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketTitle)
	}
	if m.Description != "" {
		flag = true
		w.WriteName("description")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Description)
	}
	if m.ContactID != "" {
		flag = true
		w.WriteName("contact_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ContactID)
	}
	if m.Note != "" {
		flag = true
		w.WriteName("note")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Note)
	}
	if m.FfmCode != "" {
		flag = true
		w.WriteName("ffm_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FfmCode)
	}
	if m.FfmUrl != "" {
		flag = true
		w.WriteName("ffm_url")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FfmUrl)
	}
	if m.FfmID != "" {
		flag = true
		w.WriteName("ffm_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FfmID)
	}
	if m.EtopID != "" {
		flag = true
		w.WriteName("etop_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EtopID)
	}
	if m.OrderID != 0 {
		flag = true
		w.WriteName("order_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OrderID)
	}
	if m.OrderCode != "" {
		flag = true
		w.WriteName("order_code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OrderCode)
	}
	if m.Company != "" {
		flag = true
		w.WriteName("company")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Company)
	}
	if m.Provider != "" {
		flag = true
		w.WriteName("provider")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Provider)
	}
	if m.FromApp != "" {
		flag = true
		w.WriteName("from_app")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FromApp)
	}
	if m.Code != "" {
		flag = true
		w.WriteName("code")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Code)
	}
	if m.OldValue != "" {
		flag = true
		w.WriteName("old_value")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OldValue)
	}
	if m.NewValue != "" {
		flag = true
		w.WriteName("new_value")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.NewValue)
	}
	if m.SubStatus != "" {
		flag = true
		w.WriteName("substatus")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.SubStatus)
	}
	if m.EtopNote != "" {
		flag = true
		w.WriteName("etop_note")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EtopNote)
	}
	if m.Reason != "" {
		flag = true
		w.WriteName("reason")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Reason)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if !m.CreatedTime.IsZero() {
		flag = true
		w.WriteName("createdtime")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedTime)
	}
	if !m.ModifiedAt.IsZero() {
		flag = true
		w.WriteName("modified_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ModifiedAt)
	}
	if !m.ConfirmedAt.IsZero() {
		flag = true
		w.WriteName("confirmed_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ConfirmedAt)
	}
	if m.ConfirmedBy != "" {
		flag = true
		w.WriteName("confirmed_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ConfirmedBy)
	}
	if !m.ClosedAt.IsZero() {
		flag = true
		w.WriteName("closed_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ClosedAt)
	}
	if m.ClosedBy != "" {
		flag = true
		w.WriteName("closed_by")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ClosedBy)
	}
	if m.TicketNo != "" {
		flag = true
		w.WriteName("ticket_no")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketNo)
	}
	if m.EtopAccountID != "" {
		flag = true
		w.WriteName("etop_account_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.EtopAccountID)
	}
	if m.ExternalID != "" {
		flag = true
		w.WriteName("external_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalID)
	}
	if m.ExternalStatus != "" {
		flag = true
		w.WriteName("external_status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalStatus)
	}
	if m.ExternalCSProvider != "" {
		flag = true
		w.WriteName("external_cs_provider")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ExternalCSProvider)
	}
	if m.XData != "" {
		flag = true
		w.WriteName("x_data")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.XData)
	}
	if m.XError != "" {
		flag = true
		w.WriteName("x_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.XError)
	}
	if m.OData != "" {
		flag = true
		w.WriteName("o_data")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OData)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *Ticket) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(39)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketHistory map[string]interface{}
type TicketHistories []map[string]interface{}

func (m *TicketHistory) SQLTableName() string  { return "history.\"ticket\"" }
func (m TicketHistories) SQLTableName() string { return "history.\"ticket\"" }

func (m *TicketHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select_history)
	return nil
}

func (m TicketHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicket_Select_history)
	return nil
}

func (m TicketHistory) ID() core.Interface             { return core.Interface{m["id"]} }
func (m TicketHistory) AssignedUserID() core.Interface { return core.Interface{m["assigned_user_id"]} }
func (m TicketHistory) TicketStatus() core.Interface   { return core.Interface{m["ticketstatus"]} }
func (m TicketHistory) TicketCategories() core.Interface {
	return core.Interface{m["ticketcategories"]}
}
func (m TicketHistory) ModifiedBy() core.Interface     { return core.Interface{m["modifiedby"]} }
func (m TicketHistory) TicketTitle() core.Interface    { return core.Interface{m["ticket_title"]} }
func (m TicketHistory) Description() core.Interface    { return core.Interface{m["description"]} }
func (m TicketHistory) ContactID() core.Interface      { return core.Interface{m["contact_id"]} }
func (m TicketHistory) Note() core.Interface           { return core.Interface{m["note"]} }
func (m TicketHistory) FfmCode() core.Interface        { return core.Interface{m["ffm_code"]} }
func (m TicketHistory) FfmUrl() core.Interface         { return core.Interface{m["ffm_url"]} }
func (m TicketHistory) FfmID() core.Interface          { return core.Interface{m["ffm_id"]} }
func (m TicketHistory) EtopID() core.Interface         { return core.Interface{m["etop_id"]} }
func (m TicketHistory) OrderID() core.Interface        { return core.Interface{m["order_id"]} }
func (m TicketHistory) OrderCode() core.Interface      { return core.Interface{m["order_code"]} }
func (m TicketHistory) Company() core.Interface        { return core.Interface{m["company"]} }
func (m TicketHistory) Provider() core.Interface       { return core.Interface{m["provider"]} }
func (m TicketHistory) FromApp() core.Interface        { return core.Interface{m["from_app"]} }
func (m TicketHistory) Code() core.Interface           { return core.Interface{m["code"]} }
func (m TicketHistory) OldValue() core.Interface       { return core.Interface{m["old_value"]} }
func (m TicketHistory) NewValue() core.Interface       { return core.Interface{m["new_value"]} }
func (m TicketHistory) SubStatus() core.Interface      { return core.Interface{m["substatus"]} }
func (m TicketHistory) EtopNote() core.Interface       { return core.Interface{m["etop_note"]} }
func (m TicketHistory) Reason() core.Interface         { return core.Interface{m["reason"]} }
func (m TicketHistory) CreatedAt() core.Interface      { return core.Interface{m["created_at"]} }
func (m TicketHistory) CreatedTime() core.Interface    { return core.Interface{m["createdtime"]} }
func (m TicketHistory) ModifiedAt() core.Interface     { return core.Interface{m["modified_at"]} }
func (m TicketHistory) ConfirmedAt() core.Interface    { return core.Interface{m["confirmed_at"]} }
func (m TicketHistory) ConfirmedBy() core.Interface    { return core.Interface{m["confirmed_by"]} }
func (m TicketHistory) ClosedAt() core.Interface       { return core.Interface{m["closed_at"]} }
func (m TicketHistory) ClosedBy() core.Interface       { return core.Interface{m["closed_by"]} }
func (m TicketHistory) TicketNo() core.Interface       { return core.Interface{m["ticket_no"]} }
func (m TicketHistory) EtopAccountID() core.Interface  { return core.Interface{m["etop_account_id"]} }
func (m TicketHistory) ExternalID() core.Interface     { return core.Interface{m["external_id"]} }
func (m TicketHistory) ExternalStatus() core.Interface { return core.Interface{m["external_status"]} }
func (m TicketHistory) ExternalCSProvider() core.Interface {
	return core.Interface{m["external_cs_provider"]}
}
func (m TicketHistory) XData() core.Interface  { return core.Interface{m["x_data"]} }
func (m TicketHistory) XError() core.Interface { return core.Interface{m["x_error"]} }
func (m TicketHistory) OData() core.Interface  { return core.Interface{m["o_data"]} }

func (m *TicketHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 39)
	args := make([]interface{}, 39)
	for i := 0; i < 39; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketHistory, 39)
	res["id"] = data[0]
	res["assigned_user_id"] = data[1]
	res["ticketstatus"] = data[2]
	res["ticketcategories"] = data[3]
	res["modifiedby"] = data[4]
	res["ticket_title"] = data[5]
	res["description"] = data[6]
	res["contact_id"] = data[7]
	res["note"] = data[8]
	res["ffm_code"] = data[9]
	res["ffm_url"] = data[10]
	res["ffm_id"] = data[11]
	res["etop_id"] = data[12]
	res["order_id"] = data[13]
	res["order_code"] = data[14]
	res["company"] = data[15]
	res["provider"] = data[16]
	res["from_app"] = data[17]
	res["code"] = data[18]
	res["old_value"] = data[19]
	res["new_value"] = data[20]
	res["substatus"] = data[21]
	res["etop_note"] = data[22]
	res["reason"] = data[23]
	res["created_at"] = data[24]
	res["createdtime"] = data[25]
	res["modified_at"] = data[26]
	res["confirmed_at"] = data[27]
	res["confirmed_by"] = data[28]
	res["closed_at"] = data[29]
	res["closed_by"] = data[30]
	res["ticket_no"] = data[31]
	res["etop_account_id"] = data[32]
	res["external_id"] = data[33]
	res["external_status"] = data[34]
	res["external_cs_provider"] = data[35]
	res["x_data"] = data[36]
	res["x_error"] = data[37]
	res["o_data"] = data[38]
	*m = res
	return nil
}

func (ms *TicketHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 39)
	args := make([]interface{}, 39)
	for i := 0; i < 39; i++ {
		args[i] = &data[i]
	}
	res := make(TicketHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketHistory)
		m["id"] = data[0]
		m["assigned_user_id"] = data[1]
		m["ticketstatus"] = data[2]
		m["ticketcategories"] = data[3]
		m["modifiedby"] = data[4]
		m["ticket_title"] = data[5]
		m["description"] = data[6]
		m["contact_id"] = data[7]
		m["note"] = data[8]
		m["ffm_code"] = data[9]
		m["ffm_url"] = data[10]
		m["ffm_id"] = data[11]
		m["etop_id"] = data[12]
		m["order_id"] = data[13]
		m["order_code"] = data[14]
		m["company"] = data[15]
		m["provider"] = data[16]
		m["from_app"] = data[17]
		m["code"] = data[18]
		m["old_value"] = data[19]
		m["new_value"] = data[20]
		m["substatus"] = data[21]
		m["etop_note"] = data[22]
		m["reason"] = data[23]
		m["created_at"] = data[24]
		m["createdtime"] = data[25]
		m["modified_at"] = data[26]
		m["confirmed_at"] = data[27]
		m["confirmed_by"] = data[28]
		m["closed_at"] = data[29]
		m["closed_by"] = data[30]
		m["ticket_no"] = data[31]
		m["etop_account_id"] = data[32]
		m["external_id"] = data[33]
		m["external_status"] = data[34]
		m["external_cs_provider"] = data[35]
		m["x_data"] = data[36]
		m["x_error"] = data[37]
		m["o_data"] = data[38]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type TicketComments []*TicketComment

const __sqlTicketComment_Table = "ticket_comment"
const __sqlTicketComment_ListCols = "\"id\",\"content\",\"creator_id\",\"ticket_id\",\"thread_id\",\"created_at\",\"o_data\",\"x_id\",\"x_error\",\"from\""
const __sqlTicketComment_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"content\" = EXCLUDED.\"content\",\"creator_id\" = EXCLUDED.\"creator_id\",\"ticket_id\" = EXCLUDED.\"ticket_id\",\"thread_id\" = EXCLUDED.\"thread_id\",\"created_at\" = EXCLUDED.\"created_at\",\"o_data\" = EXCLUDED.\"o_data\",\"x_id\" = EXCLUDED.\"x_id\",\"x_error\" = EXCLUDED.\"x_error\",\"from\" = EXCLUDED.\"from\""
const __sqlTicketComment_Insert = "INSERT INTO \"ticket_comment\" (" + __sqlTicketComment_ListCols + ") VALUES"
const __sqlTicketComment_Select = "SELECT " + __sqlTicketComment_ListCols + " FROM \"ticket_comment\""
const __sqlTicketComment_Select_history = "SELECT " + __sqlTicketComment_ListCols + " FROM history.\"ticket_comment\""
const __sqlTicketComment_UpdateAll = "UPDATE \"ticket_comment\" SET (" + __sqlTicketComment_ListCols + ")"
const __sqlTicketComment_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT ticket_comment_pkey DO UPDATE SET"

func (m *TicketComment) SQLTableName() string  { return "ticket_comment" }
func (m *TicketComments) SQLTableName() string { return "ticket_comment" }
func (m *TicketComment) SQLListCols() string   { return __sqlTicketComment_ListCols }

func (m *TicketComment) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlTicketComment_ListCols + " FROM \"ticket_comment\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *TicketComment) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "ticket_comment"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"content": {
			ColumnName:       "content",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"creator_id": {
			ColumnName:       "creator_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"ticket_id": {
			ColumnName:       "ticket_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"thread_id": {
			ColumnName:       "thread_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "time.Time",
			ColumnDBType:     "struct",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"o_data": {
			ColumnName:       "o_data",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"x_id": {
			ColumnName:       "x_id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"x_error": {
			ColumnName:       "x_error",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"from": {
			ColumnName:       "from",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "ticket_comment", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*TicketComment)(nil))
}

func (m *TicketComment) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.String(m.Content),
		core.String(m.CreatorID),
		core.String(m.TicketID),
		core.String(m.ThreadID),
		core.Time(m.CreatedAt),
		core.String(m.OData),
		core.String(m.XID),
		core.String(m.XError),
		core.String(m.From),
	}
}

func (m *TicketComment) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		(*core.String)(&m.Content),
		(*core.String)(&m.CreatorID),
		(*core.String)(&m.TicketID),
		(*core.String)(&m.ThreadID),
		(*core.Time)(&m.CreatedAt),
		(*core.String)(&m.OData),
		(*core.String)(&m.XID),
		(*core.String)(&m.XError),
		(*core.String)(&m.From),
	}
}

func (m *TicketComment) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *TicketComments) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(TicketComments, 0, 128)
	for rows.Next() {
		m := new(TicketComment)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *TicketComment) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select)
	return nil
}

func (_ *TicketComments) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select)
	return nil
}

func (m *TicketComment) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(10)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms TicketComments) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(10)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *TicketComment) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlTicketComment_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketComment_ListColsOnConflict)
	return nil
}

func (ms TicketComments) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlTicketComment_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlTicketComment_ListColsOnConflict)
	return nil
}

func (m *TicketComment) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("ticket_comment")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.Content != "" {
		flag = true
		w.WriteName("content")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Content)
	}
	if m.CreatorID != "" {
		flag = true
		w.WriteName("creator_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatorID)
	}
	if m.TicketID != "" {
		flag = true
		w.WriteName("ticket_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.TicketID)
	}
	if m.ThreadID != "" {
		flag = true
		w.WriteName("thread_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ThreadID)
	}
	if !m.CreatedAt.IsZero() {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if m.OData != "" {
		flag = true
		w.WriteName("o_data")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OData)
	}
	if m.XID != "" {
		flag = true
		w.WriteName("x_id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.XID)
	}
	if m.XError != "" {
		flag = true
		w.WriteName("x_error")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.XError)
	}
	if m.From != "" {
		flag = true
		w.WriteName("from")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.From)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *TicketComment) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(10)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type TicketCommentHistory map[string]interface{}
type TicketCommentHistories []map[string]interface{}

func (m *TicketCommentHistory) SQLTableName() string  { return "history.\"ticket_comment\"" }
func (m TicketCommentHistories) SQLTableName() string { return "history.\"ticket_comment\"" }

func (m *TicketCommentHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select_history)
	return nil
}

func (m TicketCommentHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlTicketComment_Select_history)
	return nil
}

func (m TicketCommentHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m TicketCommentHistory) Content() core.Interface   { return core.Interface{m["content"]} }
func (m TicketCommentHistory) CreatorID() core.Interface { return core.Interface{m["creator_id"]} }
func (m TicketCommentHistory) TicketID() core.Interface  { return core.Interface{m["ticket_id"]} }
func (m TicketCommentHistory) ThreadID() core.Interface  { return core.Interface{m["thread_id"]} }
func (m TicketCommentHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m TicketCommentHistory) OData() core.Interface     { return core.Interface{m["o_data"]} }
func (m TicketCommentHistory) XID() core.Interface       { return core.Interface{m["x_id"]} }
func (m TicketCommentHistory) XError() core.Interface    { return core.Interface{m["x_error"]} }
func (m TicketCommentHistory) From() core.Interface      { return core.Interface{m["from"]} }

func (m *TicketCommentHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 10)
	args := make([]interface{}, 10)
	for i := 0; i < 10; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(TicketCommentHistory, 10)
	res["id"] = data[0]
	res["content"] = data[1]
	res["creator_id"] = data[2]
	res["ticket_id"] = data[3]
	res["thread_id"] = data[4]
	res["created_at"] = data[5]
	res["o_data"] = data[6]
	res["x_id"] = data[7]
	res["x_error"] = data[8]
	res["from"] = data[9]
	*m = res
	return nil
}

func (ms *TicketCommentHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 10)
	args := make([]interface{}, 10)
	for i := 0; i < 10; i++ {
		args[i] = &data[i]
	}
	res := make(TicketCommentHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(TicketCommentHistory)
		m["id"] = data[0]
		m["content"] = data[1]
		m["creator_id"] = data[2]
		m["ticket_id"] = data[3]
		m["thread_id"] = data[4]
		m["created_at"] = data[5]
		m["o_data"] = data[6]
		m["x_id"] = data[7]
		m["x_error"] = data[8]
		m["from"] = data[9]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

type VtigerAccounts []*VtigerAccount

const __sqlVtigerAccount_Table = "vtiger_account"
const __sqlVtigerAccount_ListCols = "\"id\",\"user_name\",\"first_name\",\"last_name\",\"roleid\",\"email1\",\"email2\",\"secondaryemail\",\"status\",\"o_data\",\"created_at\",\"updated_at\""
const __sqlVtigerAccount_ListColsOnConflict = "\"id\" = EXCLUDED.\"id\",\"user_name\" = EXCLUDED.\"user_name\",\"first_name\" = EXCLUDED.\"first_name\",\"last_name\" = EXCLUDED.\"last_name\",\"roleid\" = EXCLUDED.\"roleid\",\"email1\" = EXCLUDED.\"email1\",\"email2\" = EXCLUDED.\"email2\",\"secondaryemail\" = EXCLUDED.\"secondaryemail\",\"status\" = EXCLUDED.\"status\",\"o_data\" = EXCLUDED.\"o_data\",\"created_at\" = EXCLUDED.\"created_at\",\"updated_at\" = EXCLUDED.\"updated_at\""
const __sqlVtigerAccount_Insert = "INSERT INTO \"vtiger_account\" (" + __sqlVtigerAccount_ListCols + ") VALUES"
const __sqlVtigerAccount_Select = "SELECT " + __sqlVtigerAccount_ListCols + " FROM \"vtiger_account\""
const __sqlVtigerAccount_Select_history = "SELECT " + __sqlVtigerAccount_ListCols + " FROM history.\"vtiger_account\""
const __sqlVtigerAccount_UpdateAll = "UPDATE \"vtiger_account\" SET (" + __sqlVtigerAccount_ListCols + ")"
const __sqlVtigerAccount_UpdateOnConflict = " ON CONFLICT ON CONSTRAINT vtiger_account_pkey DO UPDATE SET"

func (m *VtigerAccount) SQLTableName() string  { return "vtiger_account" }
func (m *VtigerAccounts) SQLTableName() string { return "vtiger_account" }
func (m *VtigerAccount) SQLListCols() string   { return __sqlVtigerAccount_ListCols }

func (m *VtigerAccount) SQLVerifySchema(db *cmsql.Database) {
	query := "SELECT " + __sqlVtigerAccount_ListCols + " FROM \"vtiger_account\" WHERE false"
	if _, err := db.SQL(query).Exec(); err != nil {
		db.RecordError(err)
	}
}

func (m *VtigerAccount) Migration(db *cmsql.Database) {
	var mDBColumnNameAndType map[string]string
	if val, err := migration.GetColumnNamesAndTypes(db, "vtiger_account"); err != nil {
		db.RecordError(err)
		return
	} else {
		mDBColumnNameAndType = val
	}
	mModelColumnNameAndType := map[string]migration.ColumnDef{
		"id": {
			ColumnName:       "id",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"user_name": {
			ColumnName:       "user_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"first_name": {
			ColumnName:       "first_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"last_name": {
			ColumnName:       "last_name",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"roleid": {
			ColumnName:       "roleid",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email1": {
			ColumnName:       "email1",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"email2": {
			ColumnName:       "email2",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"secondaryemail": {
			ColumnName:       "secondaryemail",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"status": {
			ColumnName:       "status",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"o_data": {
			ColumnName:       "o_data",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"created_at": {
			ColumnName:       "created_at",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
		"updated_at": {
			ColumnName:       "updated_at",
			ColumnType:       "string",
			ColumnDBType:     "string",
			ColumnTag:        "",
			ColumnEnumValues: []string{},
		},
	}
	if err := migration.Compare(db, "vtiger_account", mModelColumnNameAndType, mDBColumnNameAndType); err != nil {
		db.RecordError(err)
	}
}

func init() {
	__sqlModels = append(__sqlModels, (*VtigerAccount)(nil))
}

func (m *VtigerAccount) SQLArgs(opts core.Opts, create bool) []interface{} {
	return []interface{}{
		core.String(m.ID),
		core.String(m.UserName),
		core.String(m.FirstName),
		core.String(m.LastName),
		core.String(m.RoleID),
		core.String(m.Email1),
		core.String(m.Email2),
		core.String(m.SecondaryEmail),
		core.String(m.Status),
		core.String(m.OData),
		core.String(m.CreatedAt),
		core.String(m.UpdatedAt),
	}
}

func (m *VtigerAccount) SQLScanArgs(opts core.Opts) []interface{} {
	return []interface{}{
		(*core.String)(&m.ID),
		(*core.String)(&m.UserName),
		(*core.String)(&m.FirstName),
		(*core.String)(&m.LastName),
		(*core.String)(&m.RoleID),
		(*core.String)(&m.Email1),
		(*core.String)(&m.Email2),
		(*core.String)(&m.SecondaryEmail),
		(*core.String)(&m.Status),
		(*core.String)(&m.OData),
		(*core.String)(&m.CreatedAt),
		(*core.String)(&m.UpdatedAt),
	}
}

func (m *VtigerAccount) SQLScan(opts core.Opts, row *sql.Row) error {
	return row.Scan(m.SQLScanArgs(opts)...)
}

func (ms *VtigerAccounts) SQLScan(opts core.Opts, rows *sql.Rows) error {
	res := make(VtigerAccounts, 0, 128)
	for rows.Next() {
		m := new(VtigerAccount)
		args := m.SQLScanArgs(opts)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (_ *VtigerAccount) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Select)
	return nil
}

func (_ *VtigerAccounts) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Select)
	return nil
}

func (m *VtigerAccount) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Insert)
	w.WriteRawString(" (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), true))
	return nil
}

func (ms VtigerAccounts) SQLInsert(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Insert)
	w.WriteRawString(" (")
	for i := 0; i < len(ms); i++ {
		w.WriteMarkers(12)
		w.WriteArgs(ms[i].SQLArgs(w.Opts(), true))
		w.WriteRawString("),(")
	}
	w.TrimLast(2)
	return nil
}

func (m *VtigerAccount) SQLUpsert(w SQLWriter) error {
	m.SQLInsert(w)
	w.WriteQueryString(__sqlVtigerAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlVtigerAccount_ListColsOnConflict)
	return nil
}

func (ms VtigerAccounts) SQLUpsert(w SQLWriter) error {
	ms.SQLInsert(w)
	w.WriteQueryString(__sqlVtigerAccount_UpdateOnConflict)
	w.WriteQueryString(" ")
	w.WriteQueryString(__sqlVtigerAccount_ListColsOnConflict)
	return nil
}

func (m *VtigerAccount) SQLUpdate(w SQLWriter) error {
	now, opts := time.Now(), w.Opts()
	_, _ = now, opts // suppress unuse error
	var flag bool
	w.WriteRawString("UPDATE ")
	w.WriteName("vtiger_account")
	w.WriteRawString(" SET ")
	if m.ID != "" {
		flag = true
		w.WriteName("id")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.ID)
	}
	if m.UserName != "" {
		flag = true
		w.WriteName("user_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UserName)
	}
	if m.FirstName != "" {
		flag = true
		w.WriteName("first_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.FirstName)
	}
	if m.LastName != "" {
		flag = true
		w.WriteName("last_name")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.LastName)
	}
	if m.RoleID != "" {
		flag = true
		w.WriteName("roleid")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.RoleID)
	}
	if m.Email1 != "" {
		flag = true
		w.WriteName("email1")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email1)
	}
	if m.Email2 != "" {
		flag = true
		w.WriteName("email2")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Email2)
	}
	if m.SecondaryEmail != "" {
		flag = true
		w.WriteName("secondaryemail")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.SecondaryEmail)
	}
	if m.Status != "" {
		flag = true
		w.WriteName("status")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.Status)
	}
	if m.OData != "" {
		flag = true
		w.WriteName("o_data")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.OData)
	}
	if m.CreatedAt != "" {
		flag = true
		w.WriteName("created_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.CreatedAt)
	}
	if m.UpdatedAt != "" {
		flag = true
		w.WriteName("updated_at")
		w.WriteByte('=')
		w.WriteMarker()
		w.WriteByte(',')
		w.WriteArg(m.UpdatedAt)
	}
	if !flag {
		return core.ErrNoColumn
	}
	w.TrimLast(1)
	return nil
}

func (m *VtigerAccount) SQLUpdateAll(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_UpdateAll)
	w.WriteRawString(" = (")
	w.WriteMarkers(12)
	w.WriteByte(')')
	w.WriteArgs(m.SQLArgs(w.Opts(), false))
	return nil
}

type VtigerAccountHistory map[string]interface{}
type VtigerAccountHistories []map[string]interface{}

func (m *VtigerAccountHistory) SQLTableName() string  { return "history.\"vtiger_account\"" }
func (m VtigerAccountHistories) SQLTableName() string { return "history.\"vtiger_account\"" }

func (m *VtigerAccountHistory) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Select_history)
	return nil
}

func (m VtigerAccountHistories) SQLSelect(w SQLWriter) error {
	w.WriteQueryString(__sqlVtigerAccount_Select_history)
	return nil
}

func (m VtigerAccountHistory) ID() core.Interface        { return core.Interface{m["id"]} }
func (m VtigerAccountHistory) UserName() core.Interface  { return core.Interface{m["user_name"]} }
func (m VtigerAccountHistory) FirstName() core.Interface { return core.Interface{m["first_name"]} }
func (m VtigerAccountHistory) LastName() core.Interface  { return core.Interface{m["last_name"]} }
func (m VtigerAccountHistory) RoleID() core.Interface    { return core.Interface{m["roleid"]} }
func (m VtigerAccountHistory) Email1() core.Interface    { return core.Interface{m["email1"]} }
func (m VtigerAccountHistory) Email2() core.Interface    { return core.Interface{m["email2"]} }
func (m VtigerAccountHistory) SecondaryEmail() core.Interface {
	return core.Interface{m["secondaryemail"]}
}
func (m VtigerAccountHistory) Status() core.Interface    { return core.Interface{m["status"]} }
func (m VtigerAccountHistory) OData() core.Interface     { return core.Interface{m["o_data"]} }
func (m VtigerAccountHistory) CreatedAt() core.Interface { return core.Interface{m["created_at"]} }
func (m VtigerAccountHistory) UpdatedAt() core.Interface { return core.Interface{m["updated_at"]} }

func (m *VtigerAccountHistory) SQLScan(opts core.Opts, row *sql.Row) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	if err := row.Scan(args...); err != nil {
		return err
	}
	res := make(VtigerAccountHistory, 12)
	res["id"] = data[0]
	res["user_name"] = data[1]
	res["first_name"] = data[2]
	res["last_name"] = data[3]
	res["roleid"] = data[4]
	res["email1"] = data[5]
	res["email2"] = data[6]
	res["secondaryemail"] = data[7]
	res["status"] = data[8]
	res["o_data"] = data[9]
	res["created_at"] = data[10]
	res["updated_at"] = data[11]
	*m = res
	return nil
}

func (ms *VtigerAccountHistories) SQLScan(opts core.Opts, rows *sql.Rows) error {
	data := make([]interface{}, 12)
	args := make([]interface{}, 12)
	for i := 0; i < 12; i++ {
		args[i] = &data[i]
	}
	res := make(VtigerAccountHistories, 0, 128)
	for rows.Next() {
		if err := rows.Scan(args...); err != nil {
			return err
		}
		m := make(VtigerAccountHistory)
		m["id"] = data[0]
		m["user_name"] = data[1]
		m["first_name"] = data[2]
		m["last_name"] = data[3]
		m["roleid"] = data[4]
		m["email1"] = data[5]
		m["email2"] = data[6]
		m["secondaryemail"] = data[7]
		m["status"] = data[8]
		m["o_data"] = data[9]
		m["created_at"] = data[10]
		m["updated_at"] = data[11]
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}
