// package affiliate generated by wrapper_gen. DO NOT EDIT.
package affiliateW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	affiliate "etop.vn/backend/pb/services/affiliate"
	common "etop.vn/backend/pkg/common"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	bus "etop.vn/common/bus"
	l "etop.vn/common/l"
)

var ll = l.New()

type (
	EmptyClaim     = claims.EmptyClaim
	UserClaim      = claims.UserClaim
	AdminClaim     = claims.AdminClaim
	PartnerClaim   = claims.PartnerClaim
	ShopClaim      = claims.ShopClaim
	AffiliateClaim = claims.AffiliateClaim
)

type Muxer interface {
	Handle(string, http.Handler)
}

func NewAffiliateServer(mux Muxer, hooks *twirp.ServerHooks, secret string) {
	if secret == "" {
		ll.Fatal("Secret is empty")
	}
	bus.Expect(&UpdateReferralEndpoint{})
	bus.Expect(&CreateOrUpdateTradingCommissionSettingEndpoint{})
	bus.Expect(&CreateTradingProductPromotionEndpoint{})
	bus.Expect(&GetTradingProductPromotionByProductIDsEndpoint{})
	bus.Expect(&GetTradingProductPromotionsEndpoint{})
	bus.Expect(&TradingGetProductsEndpoint{})
	bus.Expect(&UpdateTradingProductPromotionEndpoint{})
	bus.Expect(&GetProductPromotionEndpoint{})
	bus.Expect(&AffiliateGetProductsEndpoint{})
	bus.Expect(&CreateOrUpdateAffiliateCommissionSettingEndpoint{})
	bus.Expect(&CreateReferralCodeEndpoint{})
	bus.Expect(&GetCommissionsEndpoint{})
	bus.Expect(&GetProductPromotionByProductIDEndpoint{})
	bus.Expect(&GetReferralCodesEndpoint{})
	bus.Expect(&GetReferralsEndpoint{})
	bus.Expect(&GetTransactionsEndpoint{})
	bus.Expect(&NotifyNewShopPurchaseEndpoint{})
	mux.Handle(affiliate.UserServicePathPrefix, affiliate.NewUserServiceServer(UserService{secret: secret}, hooks))
	mux.Handle(affiliate.TradingServicePathPrefix, affiliate.NewTradingServiceServer(TradingService{secret: secret}, hooks))
	mux.Handle(affiliate.ShopServicePathPrefix, affiliate.NewShopServiceServer(ShopService{secret: secret}, hooks))
	mux.Handle(affiliate.AffiliateServicePathPrefix, affiliate.NewAffiliateServiceServer(AffiliateService{secret: secret}, hooks))
}

type AffiliateImpl struct {
	UserService
	TradingService
	ShopService
	AffiliateService
}

type UserService struct{ secret string }

type UpdateReferralEndpoint struct {
	*affiliate.UpdateReferralRequest
	Result  *affiliate.UserReferral
	Context UserClaim
}

func (s UserService) UpdateReferral(ctx context.Context, req *affiliate.UpdateReferralRequest) (resp *affiliate.UserReferral, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.User/UpdateReferral"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateReferralEndpoint{UpdateReferralRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type TradingService struct{ secret string }

type CreateOrUpdateTradingCommissionSettingEndpoint struct {
	*affiliate.CreateOrUpdateCommissionSettingRequest
	Result  *affiliate.CommissionSetting
	Context ShopClaim
}

func (s TradingService) CreateOrUpdateTradingCommissionSetting(ctx context.Context, req *affiliate.CreateOrUpdateCommissionSettingRequest) (resp *affiliate.CommissionSetting, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/CreateOrUpdateTradingCommissionSetting"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrUpdateTradingCommissionSettingEndpoint{CreateOrUpdateCommissionSettingRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateTradingProductPromotionEndpoint struct {
	*affiliate.CreateOrUpdateProductPromotionRequest
	Result  *affiliate.ProductPromotion
	Context ShopClaim
}

func (s TradingService) CreateTradingProductPromotion(ctx context.Context, req *affiliate.CreateOrUpdateProductPromotionRequest) (resp *affiliate.ProductPromotion, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/CreateTradingProductPromotion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateTradingProductPromotionEndpoint{CreateOrUpdateProductPromotionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetTradingProductPromotionByProductIDsEndpoint struct {
	*affiliate.GetTradingProductPromotionByIDsRequest
	Result  *affiliate.GetTradingProductPromotionByIDsResponse
	Context ShopClaim
}

func (s TradingService) GetTradingProductPromotionByProductIDs(ctx context.Context, req *affiliate.GetTradingProductPromotionByIDsRequest) (resp *affiliate.GetTradingProductPromotionByIDsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/GetTradingProductPromotionByProductIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetTradingProductPromotionByProductIDsEndpoint{GetTradingProductPromotionByIDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetTradingProductPromotionsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.GetProductPromotionsResponse
	Context ShopClaim
}

func (s TradingService) GetTradingProductPromotions(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.GetProductPromotionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/GetTradingProductPromotions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetTradingProductPromotionsEndpoint{CommonListRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type TradingGetProductsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.ShopGetProductsResponse
	Context ShopClaim
}

func (s TradingService) TradingGetProducts(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.ShopGetProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/TradingGetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &TradingGetProductsEndpoint{CommonListRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateTradingProductPromotionEndpoint struct {
	*affiliate.CreateOrUpdateProductPromotionRequest
	Result  *affiliate.ProductPromotion
	Context ShopClaim
}

func (s TradingService) UpdateTradingProductPromotion(ctx context.Context, req *affiliate.CreateOrUpdateProductPromotionRequest) (resp *affiliate.ProductPromotion, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Trading/UpdateTradingProductPromotion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateTradingProductPromotionEndpoint{CreateOrUpdateProductPromotionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ShopService struct{ secret string }

type GetProductPromotionEndpoint struct {
	*affiliate.GetProductPromotionRequest
	Result  *affiliate.GetProductPromotionResponse
	Context ShopClaim
}

func (s ShopService) GetProductPromotion(ctx context.Context, req *affiliate.GetProductPromotionRequest) (resp *affiliate.GetProductPromotionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Shop/GetProductPromotion"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductPromotionEndpoint{GetProductPromotionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type AffiliateService struct{ secret string }

type AffiliateGetProductsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.AffiliateGetProductsResponse
	Context AffiliateClaim
}

func (s AffiliateService) AffiliateGetProducts(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.AffiliateGetProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/AffiliateGetProducts"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AffiliateGetProductsEndpoint{CommonListRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateOrUpdateAffiliateCommissionSettingEndpoint struct {
	*affiliate.CreateOrUpdateCommissionSettingRequest
	Result  *affiliate.CommissionSetting
	Context AffiliateClaim
}

func (s AffiliateService) CreateOrUpdateAffiliateCommissionSetting(ctx context.Context, req *affiliate.CreateOrUpdateCommissionSettingRequest) (resp *affiliate.CommissionSetting, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/CreateOrUpdateAffiliateCommissionSetting"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrUpdateAffiliateCommissionSettingEndpoint{CreateOrUpdateCommissionSettingRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateReferralCodeEndpoint struct {
	*affiliate.CreateReferralCodeRequest
	Result  *affiliate.ReferralCode
	Context AffiliateClaim
}

func (s AffiliateService) CreateReferralCode(ctx context.Context, req *affiliate.CreateReferralCodeRequest) (resp *affiliate.ReferralCode, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/CreateReferralCode"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateReferralCodeEndpoint{CreateReferralCodeRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCommissionsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.GetCommissionsResponse
	Context ShopClaim
}

func (s AffiliateService) GetCommissions(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.GetCommissionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/GetCommissions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCommissionsEndpoint{CommonListRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductPromotionByProductIDEndpoint struct {
	*affiliate.GetProductPromotionByProductIDRequest
	Result  *affiliate.GetProductPromotionByProductIDResponse
	Context AffiliateClaim
}

func (s AffiliateService) GetProductPromotionByProductID(ctx context.Context, req *affiliate.GetProductPromotionByProductIDRequest) (resp *affiliate.GetProductPromotionByProductIDResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/GetProductPromotionByProductID"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductPromotionByProductIDEndpoint{GetProductPromotionByProductIDRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetReferralCodesEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.GetReferralCodesResponse
	Context AffiliateClaim
}

func (s AffiliateService) GetReferralCodes(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.GetReferralCodesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/GetReferralCodes"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReferralCodesEndpoint{CommonListRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetReferralsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.GetReferralsResponse
	Context AffiliateClaim
}

func (s AffiliateService) GetReferrals(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.GetReferralsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/GetReferrals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetReferralsEndpoint{CommonListRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetTransactionsEndpoint struct {
	*cm.CommonListRequest
	Result  *affiliate.GetTransactionsResponse
	Context AffiliateClaim
}

func (s AffiliateService) GetTransactions(ctx context.Context, req *cm.CommonListRequest) (resp *affiliate.GetTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/GetTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireAffiliate: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetTransactionsEndpoint{CommonListRequest: req}
	query.Context.Affiliate = session.Affiliate
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type NotifyNewShopPurchaseEndpoint struct {
	*affiliate.NotifyNewShopPurchaseRequest
	Result  *affiliate.NotifyNewShopPurchaseResponse
	Context EmptyClaim
}

func (s AffiliateService) NotifyNewShopPurchase(ctx context.Context, req *affiliate.NotifyNewShopPurchaseRequest) (resp *affiliate.NotifyNewShopPurchaseResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "affiliate.Affiliate/NotifyNewShopPurchase"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &NotifyNewShopPurchaseEndpoint{NotifyNewShopPurchaseRequest: req}
	// Verify secret token
	token := middleware.GetBearerTokenFromCtx(ctx)
	if token != s.secret {
		return nil, common.ErrUnauthenticated
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
