// package kiotviet generated by wrapper_gen. DO NOT EDIT.
package kiotvietW

import (
	"context"
	"net/http"
	"time"

	"github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	kiotviet "etop.vn/backend/pb/integration/kiotviet"
	common "etop.vn/backend/pkg/common"
	"etop.vn/backend/pkg/common/bus"
	cmGrpc "etop.vn/backend/pkg/common/grpc"
	"etop.vn/backend/pkg/common/l"
	cmWrapper "etop.vn/backend/pkg/common/wrapper"
	"etop.vn/backend/pkg/etop/authorize/claims"
	"etop.vn/backend/pkg/etop/authorize/middleware"
)

var ll = l.New()

var Client Kiotviet

type Kiotviet interface {
	kiotviet.MiscService
	kiotviet.SyncService
}

type KiotvietClient struct {
	_MiscService kiotviet.MiscService
	_SyncService kiotviet.SyncService
}

func NewKiotvietClient(addr string, client *http.Client) Kiotviet {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &KiotvietClient{
		_MiscService: kiotviet.NewMiscServiceProtobufClient(addr, client),
		_SyncService: kiotviet.NewSyncServiceProtobufClient(addr, client),
	}
}

func ConnectKiotvietService(addr string, client *http.Client, secret string) error {
	Client = NewKiotvietClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SyncProductSourceEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	ctx = cmGrpc.AppendAccessToken(ctx, secret)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to KiotvietService at %v", addr)
	}
	return err
}

func MustConnectKiotvietService(addr string, client *http.Client, secret string) {
	err := ConnectKiotvietService(addr, client, secret)
	if err != nil {
		ll.Fatal("Unable to connect Kiotviet", l.Error(err))
	}
}

type (
	EmptyClaim    = claims.EmptyClaim
	UserClaim     = claims.UserClaim
	AdminClaim    = claims.AdminClaim
	PartnerClaim  = claims.PartnerClaim
	ShopClaim     = claims.ShopClaim
	SupplierClaim = claims.SupplierClaim
)

func (c *KiotvietClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *KiotvietClient) SyncProductSource(ctx context.Context, in *kiotviet.SyncProductSourceRequest) (*cm.Empty, error) {
	resp, err := c._SyncService.SyncProductSource(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewKiotvietServer(mux Muxer, hooks *twirp.ServerHooks, secret string) {
	if secret == "" {
		ll.Fatal("Secret is empty")
	}
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&SyncProductSourceEndpoint{})
	mux.Handle(kiotviet.MiscServicePathPrefix, kiotviet.NewMiscServiceServer(MiscService{secret: secret}, hooks))
	mux.Handle(kiotviet.SyncServicePathPrefix, kiotviet.NewSyncServiceServer(SyncService{secret: secret}, hooks))
}

type KiotvietImpl struct {
	MiscService
	SyncService
}

func NewKiotviet() Kiotviet {
	return KiotvietImpl{}
}

type MiscService struct{ secret string }

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "kiotviet.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmWrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	// Verify secret token
	token := middleware.GetBearerTokenFromCtx(ctx)
	if token != s.secret {
		return nil, common.ErrUnauthenticated
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SyncService struct{ secret string }

type SyncProductSourceEndpoint struct {
	*kiotviet.SyncProductSourceRequest
	Result  *cm.Empty
	Context EmptyClaim
}

func (s SyncService) SyncProductSource(ctx context.Context, req *kiotviet.SyncProductSourceRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "kiotviet.Sync/SyncProductSource"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
	}()
	defer cmWrapper.Censor(req)
	query := &SyncProductSourceEndpoint{SyncProductSourceRequest: req}
	// Verify secret token
	token := middleware.GetBearerTokenFromCtx(ctx)
	if token != s.secret {
		return nil, common.ErrUnauthenticated
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}
