// package sadmin generated by wrapper_gen. DO NOT EDIT.
package sadminW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	sadmin "etop.vn/backend/pb/etop/sadmin"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	l "etop.vn/common/l"
)

var ll = l.New()

type (
	EmptyClaim     = claims.EmptyClaim
	UserClaim      = claims.UserClaim
	AdminClaim     = claims.AdminClaim
	PartnerClaim   = claims.PartnerClaim
	ShopClaim      = claims.ShopClaim
	AffiliateClaim = claims.AffiliateClaim
)

type Muxer interface {
	Handle(string, http.Handler)
}

func NewSadminServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&CreateUserEndpoint{})
	bus.Expect(&LoginAsAccountEndpoint{})
	bus.Expect(&ResetPasswordEndpoint{})
	mux.Handle(sadmin.MiscServicePathPrefix, sadmin.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(sadmin.UserServicePathPrefix, sadmin.NewUserServiceServer(UserService{}, hooks))
}

type SadminImpl struct {
	MiscService
	UserService
}

type MiscService struct{}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:           ctx,
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VersionInfoEndpoint{Empty: req}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UserService struct{}

type CreateUserEndpoint struct {
	*sadmin.SAdminCreateUserRequest
	Result  *etop.RegisterResponse
	Context EmptyClaim
}

func (s UserService) CreateUser(ctx context.Context, req *sadmin.SAdminCreateUserRequest) (resp *etop.RegisterResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/CreateUser"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:           ctx,
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateUserEndpoint{SAdminCreateUserRequest: req}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type LoginAsAccountEndpoint struct {
	*sadmin.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context EmptyClaim
}

func (s UserService) LoginAsAccount(ctx context.Context, req *sadmin.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/LoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:           ctx,
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LoginAsAccountEndpoint{LoginAsAccountRequest: req}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ResetPasswordEndpoint struct {
	*sadmin.SAdminResetPasswordRequest
	Result  *cm.Empty
	Context EmptyClaim
}

func (s UserService) ResetPassword(ctx context.Context, req *sadmin.SAdminResetPasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "sadmin.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:           ctx,
		RequireAuth:       true,
		RequireSuperAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ResetPasswordEndpoint{SAdminResetPasswordRequest: req}
	query.Context.IsSuperAdmin = session.IsSuperAdmin
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
