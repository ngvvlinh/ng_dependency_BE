// package admin generated by wrapper_gen. DO NOT EDIT.
package adminW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	admin "etop.vn/backend/pb/etop/admin"
	order "etop.vn/backend/pb/etop/order"
	common "etop.vn/backend/pkg/common"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	bus "etop.vn/common/bus"
	l "etop.vn/common/l"
)

var ll = l.New()

var Client Admin

type Admin interface {
	admin.MiscService
	admin.AccountService
	admin.OrderService
	admin.FulfillmentService
	admin.MoneyTransactionService
	admin.ShopService
	admin.CreditService
	admin.NotificationService
}

type AdminClient struct {
	_MiscService             admin.MiscService
	_AccountService          admin.AccountService
	_OrderService            admin.OrderService
	_FulfillmentService      admin.FulfillmentService
	_MoneyTransactionService admin.MoneyTransactionService
	_ShopService             admin.ShopService
	_CreditService           admin.CreditService
	_NotificationService     admin.NotificationService
}

func NewAdminClient(addr string, client *http.Client) Admin {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &AdminClient{
		_MiscService:             admin.NewMiscServiceProtobufClient(addr, client),
		_AccountService:          admin.NewAccountServiceProtobufClient(addr, client),
		_OrderService:            admin.NewOrderServiceProtobufClient(addr, client),
		_FulfillmentService:      admin.NewFulfillmentServiceProtobufClient(addr, client),
		_MoneyTransactionService: admin.NewMoneyTransactionServiceProtobufClient(addr, client),
		_ShopService:             admin.NewShopServiceProtobufClient(addr, client),
		_CreditService:           admin.NewCreditServiceProtobufClient(addr, client),
		_NotificationService:     admin.NewNotificationServiceProtobufClient(addr, client),
	}
}

func ConnectAdminService(addr string, client *http.Client) error {
	Client = NewAdminClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *AdminLoginAsAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreatePartnerEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GenerateAPIKeyEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrdersEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrdersByIDsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmMoneyTransactionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmMoneyTransactionShippingEtopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmMoneyTransactionShippingExternalEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmMoneyTransactionShippingExternalsEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *CreateMoneyTransactionShippingEtopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteMoneyTransactionShippingEtopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteMoneyTransactionShippingExternalEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionShippingEtopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionShippingEtopsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionShippingExternalEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionShippingExternalsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveMoneyTransactionShippingExternalLinesEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *UpdateMoneyTransactionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateMoneyTransactionShippingEtopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateMoneyTransactionShippingExternalEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *GetShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShopsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmCreditEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateCreditEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteCreditEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetCreditEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetCreditsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateCreditEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateNotificationsEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to AdminService at %v", addr)
	}
	return err
}

func MustConnectAdminService(addr string, client *http.Client) {
	err := ConnectAdminService(addr, client)
	if err != nil {
		ll.Fatal("Unable to connect Admin", l.Error(err))
	}
}

type (
	EmptyClaim   = claims.EmptyClaim
	UserClaim    = claims.UserClaim
	AdminClaim   = claims.AdminClaim
	PartnerClaim = claims.PartnerClaim
	ShopClaim    = claims.ShopClaim
)

func (c *AdminClient) AdminLoginAsAccount(ctx context.Context, in *admin.LoginAsAccountRequest) (*etop.LoginResponse, error) {
	resp, err := c._MiscService.AdminLoginAsAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) CreatePartner(ctx context.Context, in *admin.CreatePartnerRequest) (*etop.Partner, error) {
	resp, err := c._AccountService.CreatePartner(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GenerateAPIKey(ctx context.Context, in *admin.GenerateAPIKeyRequest) (*admin.GenerateAPIKeyResponse, error) {
	resp, err := c._AccountService.GenerateAPIKey(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetOrder(ctx context.Context, in *cm.IDRequest) (*order.Order, error) {
	resp, err := c._OrderService.GetOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetOrders(ctx context.Context, in *admin.GetOrdersRequest) (*order.OrdersResponse, error) {
	resp, err := c._OrderService.GetOrders(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetOrdersByIDs(ctx context.Context, in *cm.IDsRequest) (*order.OrdersResponse, error) {
	resp, err := c._OrderService.GetOrdersByIDs(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetFulfillment(ctx context.Context, in *cm.IDRequest) (*order.Fulfillment, error) {
	resp, err := c._FulfillmentService.GetFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetFulfillments(ctx context.Context, in *admin.GetFulfillmentsRequest) (*order.FulfillmentsResponse, error) {
	resp, err := c._FulfillmentService.GetFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) UpdateFulfillment(ctx context.Context, in *admin.UpdateFulfillmentRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._FulfillmentService.UpdateFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) ConfirmMoneyTransaction(ctx context.Context, in *admin.ConfirmMoneyTransactionRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._MoneyTransactionService.ConfirmMoneyTransaction(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) ConfirmMoneyTransactionShippingEtop(ctx context.Context, in *admin.ConfirmMoneyTransactionShippingEtopRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._MoneyTransactionService.ConfirmMoneyTransactionShippingEtop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) ConfirmMoneyTransactionShippingExternal(ctx context.Context, in *cm.IDRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._MoneyTransactionService.ConfirmMoneyTransactionShippingExternal(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) ConfirmMoneyTransactionShippingExternals(ctx context.Context, in *cm.IDsRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._MoneyTransactionService.ConfirmMoneyTransactionShippingExternals(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) CreateMoneyTransactionShippingEtop(ctx context.Context, in *cm.IDsRequest) (*order.MoneyTransactionShippingEtop, error) {
	resp, err := c._MoneyTransactionService.CreateMoneyTransactionShippingEtop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) DeleteMoneyTransactionShippingEtop(ctx context.Context, in *cm.IDRequest) (*cm.DeletedResponse, error) {
	resp, err := c._MoneyTransactionService.DeleteMoneyTransactionShippingEtop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) DeleteMoneyTransactionShippingExternal(ctx context.Context, in *cm.IDRequest) (*cm.RemovedResponse, error) {
	resp, err := c._MoneyTransactionService.DeleteMoneyTransactionShippingExternal(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransaction(ctx context.Context, in *cm.IDRequest) (*order.MoneyTransaction, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransaction(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransactionShippingEtop(ctx context.Context, in *cm.IDRequest) (*order.MoneyTransactionShippingEtop, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactionShippingEtop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransactionShippingEtops(ctx context.Context, in *admin.GetMoneyTransactionShippingEtopsRequest) (*order.MoneyTransactionShippingEtopsResponse, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactionShippingEtops(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransactionShippingExternal(ctx context.Context, in *cm.IDRequest) (*order.MoneyTransactionShippingExternal, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactionShippingExternal(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransactionShippingExternals(ctx context.Context, in *admin.GetMoneyTransactionShippingExternalsRequest) (*order.MoneyTransactionShippingExternalsResponse, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactionShippingExternals(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetMoneyTransactions(ctx context.Context, in *admin.GetMoneyTransactionsRequest) (*order.MoneyTransactionsResponse, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactions(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, in *admin.RemoveMoneyTransactionShippingExternalLinesRequest) (*order.MoneyTransactionShippingExternal, error) {
	resp, err := c._MoneyTransactionService.RemoveMoneyTransactionShippingExternalLines(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) UpdateMoneyTransaction(ctx context.Context, in *admin.UpdateMoneyTransactionRequest) (*order.MoneyTransaction, error) {
	resp, err := c._MoneyTransactionService.UpdateMoneyTransaction(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) UpdateMoneyTransactionShippingEtop(ctx context.Context, in *admin.UpdateMoneyTransactionShippingEtopRequest) (*order.MoneyTransactionShippingEtop, error) {
	resp, err := c._MoneyTransactionService.UpdateMoneyTransactionShippingEtop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) UpdateMoneyTransactionShippingExternal(ctx context.Context, in *admin.UpdateMoneyTransactionShippingExternalRequest) (*order.MoneyTransactionShippingExternal, error) {
	resp, err := c._MoneyTransactionService.UpdateMoneyTransactionShippingExternal(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetShop(ctx context.Context, in *cm.IDRequest) (*etop.Shop, error) {
	resp, err := c._ShopService.GetShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetShops(ctx context.Context, in *admin.GetShopsRequest) (*admin.GetShopsResponse, error) {
	resp, err := c._ShopService.GetShops(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) ConfirmCredit(ctx context.Context, in *admin.ConfirmCreditRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._CreditService.ConfirmCredit(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) CreateCredit(ctx context.Context, in *admin.CreateCreditRequest) (*etop.Credit, error) {
	resp, err := c._CreditService.CreateCredit(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) DeleteCredit(ctx context.Context, in *cm.IDRequest) (*cm.RemovedResponse, error) {
	resp, err := c._CreditService.DeleteCredit(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetCredit(ctx context.Context, in *admin.GetCreditRequest) (*etop.Credit, error) {
	resp, err := c._CreditService.GetCredit(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) GetCredits(ctx context.Context, in *admin.GetCreditsRequest) (*etop.CreditsResponse, error) {
	resp, err := c._CreditService.GetCredits(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) UpdateCredit(ctx context.Context, in *admin.UpdateCreditRequest) (*etop.Credit, error) {
	resp, err := c._CreditService.UpdateCredit(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *AdminClient) CreateNotifications(ctx context.Context, in *admin.CreateNotificationsRequest) (*admin.CreateNotificationsResponse, error) {
	resp, err := c._NotificationService.CreateNotifications(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewAdminServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&AdminLoginAsAccountEndpoint{})
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&CreatePartnerEndpoint{})
	bus.Expect(&GenerateAPIKeyEndpoint{})
	bus.Expect(&GetOrderEndpoint{})
	bus.Expect(&GetOrdersEndpoint{})
	bus.Expect(&GetOrdersByIDsEndpoint{})
	bus.Expect(&GetFulfillmentEndpoint{})
	bus.Expect(&GetFulfillmentsEndpoint{})
	bus.Expect(&UpdateFulfillmentEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingExternalsEndpoint{})
	bus.Expect(&CreateMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&DeleteMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&DeleteMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetMoneyTransactionEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingEtopsEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingExternalsEndpoint{})
	bus.Expect(&GetMoneyTransactionsEndpoint{})
	bus.Expect(&RemoveMoneyTransactionShippingExternalLinesEndpoint{})
	bus.Expect(&UpdateMoneyTransactionEndpoint{})
	bus.Expect(&UpdateMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&UpdateMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetShopEndpoint{})
	bus.Expect(&GetShopsEndpoint{})
	bus.Expect(&ConfirmCreditEndpoint{})
	bus.Expect(&CreateCreditEndpoint{})
	bus.Expect(&DeleteCreditEndpoint{})
	bus.Expect(&GetCreditEndpoint{})
	bus.Expect(&GetCreditsEndpoint{})
	bus.Expect(&UpdateCreditEndpoint{})
	bus.Expect(&CreateNotificationsEndpoint{})
	mux.Handle(admin.MiscServicePathPrefix, admin.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(admin.AccountServicePathPrefix, admin.NewAccountServiceServer(AccountService{}, hooks))
	mux.Handle(admin.OrderServicePathPrefix, admin.NewOrderServiceServer(OrderService{}, hooks))
	mux.Handle(admin.FulfillmentServicePathPrefix, admin.NewFulfillmentServiceServer(FulfillmentService{}, hooks))
	mux.Handle(admin.MoneyTransactionServicePathPrefix, admin.NewMoneyTransactionServiceServer(MoneyTransactionService{}, hooks))
	mux.Handle(admin.ShopServicePathPrefix, admin.NewShopServiceServer(ShopService{}, hooks))
	mux.Handle(admin.CreditServicePathPrefix, admin.NewCreditServiceServer(CreditService{}, hooks))
	mux.Handle(admin.NotificationServicePathPrefix, admin.NewNotificationServiceServer(NotificationService{}, hooks))
}

type AdminImpl struct {
	MiscService
	AccountService
	OrderService
	FulfillmentService
	MoneyTransactionService
	ShopService
	CreditService
	NotificationService
}

func NewAdmin() Admin {
	return AdminImpl{}
}

type MiscService struct{}

type AdminLoginAsAccountEndpoint struct {
	*admin.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context AdminClaim
}

func (s MiscService) AdminLoginAsAccount(ctx context.Context, req *admin.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/AdminLoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdminLoginAsAccountEndpoint{LoginAsAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "admin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type AccountService struct{}

type CreatePartnerEndpoint struct {
	*admin.CreatePartnerRequest
	Result  *etop.Partner
	Context AdminClaim
}

func (s AccountService) CreatePartner(ctx context.Context, req *admin.CreatePartnerRequest) (resp *etop.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/CreatePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePartnerEndpoint{CreatePartnerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GenerateAPIKeyEndpoint struct {
	*admin.GenerateAPIKeyRequest
	Result  *admin.GenerateAPIKeyResponse
	Context AdminClaim
}

func (s AccountService) GenerateAPIKey(ctx context.Context, req *admin.GenerateAPIKeyRequest) (resp *admin.GenerateAPIKeyResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/GenerateAPIKey"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GenerateAPIKeyEndpoint{GenerateAPIKeyRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type OrderService struct{}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result  *order.Order
	Context AdminClaim
}

func (s OrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersEndpoint struct {
	*admin.GetOrdersRequest
	Result  *order.OrdersResponse
	Context AdminClaim
}

func (s OrderService) GetOrders(ctx context.Context, req *admin.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *order.OrdersResponse
	Context AdminClaim
}

func (s OrderService) GetOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type FulfillmentService struct{}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.Fulfillment
	Context AdminClaim
}

func (s FulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetFulfillmentsEndpoint struct {
	*admin.GetFulfillmentsRequest
	Result  *order.FulfillmentsResponse
	Context AdminClaim
}

func (s FulfillmentService) GetFulfillments(ctx context.Context, req *admin.GetFulfillmentsRequest) (resp *order.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateFulfillmentEndpoint struct {
	*admin.UpdateFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s FulfillmentService) UpdateFulfillment(ctx context.Context, req *admin.UpdateFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentEndpoint{UpdateFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type MoneyTransactionService struct{}

type ConfirmMoneyTransactionEndpoint struct {
	*admin.ConfirmMoneyTransactionRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransaction(ctx context.Context, req *admin.ConfirmMoneyTransactionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionEndpoint{ConfirmMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingEtopEndpoint struct {
	*admin.ConfirmMoneyTransactionShippingEtopRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingEtop(ctx context.Context, req *admin.ConfirmMoneyTransactionShippingEtopRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingEtopEndpoint{ConfirmMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingExternalsEndpoint struct {
	*cm.IDsRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingExternals(ctx context.Context, req *cm.IDsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDsRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) CreateMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDsRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateMoneyTransactionShippingEtopEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) DeleteMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) DeleteMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransaction
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingEtopsEndpoint struct {
	*admin.GetMoneyTransactionShippingEtopsRequest
	Result  *order.MoneyTransactionShippingEtopsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingEtops(ctx context.Context, req *admin.GetMoneyTransactionShippingEtopsRequest) (resp *order.MoneyTransactionShippingEtopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopsEndpoint{GetMoneyTransactionShippingEtopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingExternalsEndpoint struct {
	*admin.GetMoneyTransactionShippingExternalsRequest
	Result  *order.MoneyTransactionShippingExternalsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingExternals(ctx context.Context, req *admin.GetMoneyTransactionShippingExternalsRequest) (resp *order.MoneyTransactionShippingExternalsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalsEndpoint{GetMoneyTransactionShippingExternalsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionsEndpoint struct {
	*admin.GetMoneyTransactionsRequest
	Result  *order.MoneyTransactionsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *admin.GetMoneyTransactionsRequest) (resp *order.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveMoneyTransactionShippingExternalLinesEndpoint struct {
	*admin.RemoveMoneyTransactionShippingExternalLinesRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, req *admin.RemoveMoneyTransactionShippingExternalLinesRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveMoneyTransactionShippingExternalLinesEndpoint{RemoveMoneyTransactionShippingExternalLinesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionEndpoint struct {
	*admin.UpdateMoneyTransactionRequest
	Result  *order.MoneyTransaction
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransaction(ctx context.Context, req *admin.UpdateMoneyTransactionRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionEndpoint{UpdateMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionShippingEtopEndpoint struct {
	*admin.UpdateMoneyTransactionShippingEtopRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransactionShippingEtop(ctx context.Context, req *admin.UpdateMoneyTransactionShippingEtopRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingEtopEndpoint{UpdateMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionShippingExternalEndpoint struct {
	*admin.UpdateMoneyTransactionShippingExternalRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransactionShippingExternal(ctx context.Context, req *admin.UpdateMoneyTransactionShippingExternalRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingExternalEndpoint{UpdateMoneyTransactionShippingExternalRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ShopService struct{}

type GetShopEndpoint struct {
	*cm.IDRequest
	Result  *etop.Shop
	Context AdminClaim
}

func (s ShopService) GetShop(ctx context.Context, req *cm.IDRequest) (resp *etop.Shop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShopsEndpoint struct {
	*admin.GetShopsRequest
	Result  *admin.GetShopsResponse
	Context AdminClaim
}

func (s ShopService) GetShops(ctx context.Context, req *admin.GetShopsRequest) (resp *admin.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsEndpoint{GetShopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreditService struct{}

type ConfirmCreditEndpoint struct {
	*admin.ConfirmCreditRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s CreditService) ConfirmCredit(ctx context.Context, req *admin.ConfirmCreditRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/ConfirmCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmCreditEndpoint{ConfirmCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateCreditEndpoint struct {
	*admin.CreateCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) CreateCredit(ctx context.Context, req *admin.CreateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/CreateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCreditEndpoint{CreateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteCreditEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context AdminClaim
}

func (s CreditService) DeleteCredit(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/DeleteCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCreditEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCreditEndpoint struct {
	*admin.GetCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) GetCredit(ctx context.Context, req *admin.GetCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditEndpoint{GetCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCreditsEndpoint struct {
	*admin.GetCreditsRequest
	Result  *etop.CreditsResponse
	Context AdminClaim
}

func (s CreditService) GetCredits(ctx context.Context, req *admin.GetCreditsRequest) (resp *etop.CreditsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredits"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditsEndpoint{GetCreditsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateCreditEndpoint struct {
	*admin.UpdateCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) UpdateCredit(ctx context.Context, req *admin.UpdateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/UpdateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCreditEndpoint{UpdateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type NotificationService struct{}

type CreateNotificationsEndpoint struct {
	*admin.CreateNotificationsRequest
	Result  *admin.CreateNotificationsResponse
	Context AdminClaim
}

func (s NotificationService) CreateNotifications(ctx context.Context, req *admin.CreateNotificationsRequest) (resp *admin.CreateNotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Notification/CreateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateNotificationsEndpoint{CreateNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
