// package admin generated by wrapper_gen. DO NOT EDIT.
package adminW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	admin "etop.vn/backend/pb/etop/admin"
	order "etop.vn/backend/pb/etop/order"
	common "etop.vn/backend/pkg/common"
	bus "etop.vn/backend/pkg/common/bus"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	l "etop.vn/common/l"
)

var ll = l.New()

type (
	EmptyClaim     = claims.EmptyClaim
	UserClaim      = claims.UserClaim
	AdminClaim     = claims.AdminClaim
	PartnerClaim   = claims.PartnerClaim
	ShopClaim      = claims.ShopClaim
	AffiliateClaim = claims.AffiliateClaim
)

type Muxer interface {
	Handle(string, http.Handler)
}

func NewAdminServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&AdminLoginAsAccountEndpoint{})
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&CreatePartnerEndpoint{})
	bus.Expect(&GenerateAPIKeyEndpoint{})
	bus.Expect(&GetOrderEndpoint{})
	bus.Expect(&GetOrdersEndpoint{})
	bus.Expect(&GetOrdersByIDsEndpoint{})
	bus.Expect(&GetFulfillmentEndpoint{})
	bus.Expect(&GetFulfillmentsEndpoint{})
	bus.Expect(&UpdateFulfillmentEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&ConfirmMoneyTransactionShippingExternalsEndpoint{})
	bus.Expect(&CreateMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&DeleteMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&DeleteMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetMoneyTransactionEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingEtopsEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetMoneyTransactionShippingExternalsEndpoint{})
	bus.Expect(&GetMoneyTransactionsEndpoint{})
	bus.Expect(&RemoveMoneyTransactionShippingExternalLinesEndpoint{})
	bus.Expect(&UpdateMoneyTransactionEndpoint{})
	bus.Expect(&UpdateMoneyTransactionShippingEtopEndpoint{})
	bus.Expect(&UpdateMoneyTransactionShippingExternalEndpoint{})
	bus.Expect(&GetShopEndpoint{})
	bus.Expect(&GetShopsEndpoint{})
	bus.Expect(&ConfirmCreditEndpoint{})
	bus.Expect(&CreateCreditEndpoint{})
	bus.Expect(&DeleteCreditEndpoint{})
	bus.Expect(&GetCreditEndpoint{})
	bus.Expect(&GetCreditsEndpoint{})
	bus.Expect(&UpdateCreditEndpoint{})
	bus.Expect(&CreateNotificationsEndpoint{})
	mux.Handle(admin.MiscServicePathPrefix, admin.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(admin.AccountServicePathPrefix, admin.NewAccountServiceServer(AccountService{}, hooks))
	mux.Handle(admin.OrderServicePathPrefix, admin.NewOrderServiceServer(OrderService{}, hooks))
	mux.Handle(admin.FulfillmentServicePathPrefix, admin.NewFulfillmentServiceServer(FulfillmentService{}, hooks))
	mux.Handle(admin.MoneyTransactionServicePathPrefix, admin.NewMoneyTransactionServiceServer(MoneyTransactionService{}, hooks))
	mux.Handle(admin.ShopServicePathPrefix, admin.NewShopServiceServer(ShopService{}, hooks))
	mux.Handle(admin.CreditServicePathPrefix, admin.NewCreditServiceServer(CreditService{}, hooks))
	mux.Handle(admin.NotificationServicePathPrefix, admin.NewNotificationServiceServer(NotificationService{}, hooks))
}

type AdminImpl struct {
	MiscService
	AccountService
	OrderService
	FulfillmentService
	MoneyTransactionService
	ShopService
	CreditService
	NotificationService
}

type MiscService struct{}

type AdminLoginAsAccountEndpoint struct {
	*admin.LoginAsAccountRequest
	Result  *etop.LoginResponse
	Context AdminClaim
}

func (s MiscService) AdminLoginAsAccount(ctx context.Context, req *admin.LoginAsAccountRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Misc/AdminLoginAsAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AdminLoginAsAccountEndpoint{LoginAsAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "admin.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type AccountService struct{}

type CreatePartnerEndpoint struct {
	*admin.CreatePartnerRequest
	Result  *etop.Partner
	Context AdminClaim
}

func (s AccountService) CreatePartner(ctx context.Context, req *admin.CreatePartnerRequest) (resp *etop.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/CreatePartner"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreatePartnerEndpoint{CreatePartnerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GenerateAPIKeyEndpoint struct {
	*admin.GenerateAPIKeyRequest
	Result  *admin.GenerateAPIKeyResponse
	Context AdminClaim
}

func (s AccountService) GenerateAPIKey(ctx context.Context, req *admin.GenerateAPIKeyRequest) (resp *admin.GenerateAPIKeyResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Account/GenerateAPIKey"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GenerateAPIKeyEndpoint{GenerateAPIKeyRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type OrderService struct{}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result  *order.Order
	Context AdminClaim
}

func (s OrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersEndpoint struct {
	*admin.GetOrdersRequest
	Result  *order.OrdersResponse
	Context AdminClaim
}

func (s OrderService) GetOrders(ctx context.Context, req *admin.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *order.OrdersResponse
	Context AdminClaim
}

func (s OrderService) GetOrdersByIDs(ctx context.Context, req *cm.IDsRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type FulfillmentService struct{}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.Fulfillment
	Context AdminClaim
}

func (s FulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetFulfillmentsEndpoint struct {
	*admin.GetFulfillmentsRequest
	Result  *order.FulfillmentsResponse
	Context AdminClaim
}

func (s FulfillmentService) GetFulfillments(ctx context.Context, req *admin.GetFulfillmentsRequest) (resp *order.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateFulfillmentEndpoint struct {
	*admin.UpdateFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s FulfillmentService) UpdateFulfillment(ctx context.Context, req *admin.UpdateFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Fulfillment/UpdateFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentEndpoint{UpdateFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type MoneyTransactionService struct{}

type ConfirmMoneyTransactionEndpoint struct {
	*admin.ConfirmMoneyTransactionRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransaction(ctx context.Context, req *admin.ConfirmMoneyTransactionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionEndpoint{ConfirmMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingEtopEndpoint struct {
	*admin.ConfirmMoneyTransactionShippingEtopRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingEtop(ctx context.Context, req *admin.ConfirmMoneyTransactionShippingEtopRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingEtopEndpoint{ConfirmMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmMoneyTransactionShippingExternalsEndpoint struct {
	*cm.IDsRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) ConfirmMoneyTransactionShippingExternals(ctx context.Context, req *cm.IDsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/ConfirmMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmMoneyTransactionShippingExternalsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDsRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) CreateMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDsRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/CreateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateMoneyTransactionShippingEtopEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *cm.DeletedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) DeleteMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context AdminClaim
}

func (s MoneyTransactionService) DeleteMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/DeleteMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransaction
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingEtopEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingEtop(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingEtopsEndpoint struct {
	*admin.GetMoneyTransactionShippingEtopsRequest
	Result  *order.MoneyTransactionShippingEtopsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingEtops(ctx context.Context, req *admin.GetMoneyTransactionShippingEtopsRequest) (resp *order.MoneyTransactionShippingEtopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingEtops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingEtopsEndpoint{GetMoneyTransactionShippingEtopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingExternalEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingExternal(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionShippingExternalsEndpoint struct {
	*admin.GetMoneyTransactionShippingExternalsRequest
	Result  *order.MoneyTransactionShippingExternalsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactionShippingExternals(ctx context.Context, req *admin.GetMoneyTransactionShippingExternalsRequest) (resp *order.MoneyTransactionShippingExternalsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactionShippingExternals"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionShippingExternalsEndpoint{GetMoneyTransactionShippingExternalsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionsEndpoint struct {
	*admin.GetMoneyTransactionsRequest
	Result  *order.MoneyTransactionsResponse
	Context AdminClaim
}

func (s MoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *admin.GetMoneyTransactionsRequest) (resp *order.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveMoneyTransactionShippingExternalLinesEndpoint struct {
	*admin.RemoveMoneyTransactionShippingExternalLinesRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) RemoveMoneyTransactionShippingExternalLines(ctx context.Context, req *admin.RemoveMoneyTransactionShippingExternalLinesRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/RemoveMoneyTransactionShippingExternalLines"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveMoneyTransactionShippingExternalLinesEndpoint{RemoveMoneyTransactionShippingExternalLinesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionEndpoint struct {
	*admin.UpdateMoneyTransactionRequest
	Result  *order.MoneyTransaction
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransaction(ctx context.Context, req *admin.UpdateMoneyTransactionRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionEndpoint{UpdateMoneyTransactionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionShippingEtopEndpoint struct {
	*admin.UpdateMoneyTransactionShippingEtopRequest
	Result  *order.MoneyTransactionShippingEtop
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransactionShippingEtop(ctx context.Context, req *admin.UpdateMoneyTransactionShippingEtopRequest) (resp *order.MoneyTransactionShippingEtop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingEtop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingEtopEndpoint{UpdateMoneyTransactionShippingEtopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateMoneyTransactionShippingExternalEndpoint struct {
	*admin.UpdateMoneyTransactionShippingExternalRequest
	Result  *order.MoneyTransactionShippingExternal
	Context AdminClaim
}

func (s MoneyTransactionService) UpdateMoneyTransactionShippingExternal(ctx context.Context, req *admin.UpdateMoneyTransactionShippingExternalRequest) (resp *order.MoneyTransactionShippingExternal, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.MoneyTransaction/UpdateMoneyTransactionShippingExternal"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateMoneyTransactionShippingExternalEndpoint{UpdateMoneyTransactionShippingExternalRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ShopService struct{}

type GetShopEndpoint struct {
	*cm.IDRequest
	Result  *etop.Shop
	Context AdminClaim
}

func (s ShopService) GetShop(ctx context.Context, req *cm.IDRequest) (resp *etop.Shop, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShopsEndpoint struct {
	*admin.GetShopsRequest
	Result  *admin.GetShopsResponse
	Context AdminClaim
}

func (s ShopService) GetShops(ctx context.Context, req *admin.GetShopsRequest) (resp *admin.GetShopsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Shop/GetShops"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopsEndpoint{GetShopsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreditService struct{}

type ConfirmCreditEndpoint struct {
	*admin.ConfirmCreditRequest
	Result  *cm.UpdatedResponse
	Context AdminClaim
}

func (s CreditService) ConfirmCredit(ctx context.Context, req *admin.ConfirmCreditRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/ConfirmCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmCreditEndpoint{ConfirmCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateCreditEndpoint struct {
	*admin.CreateCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) CreateCredit(ctx context.Context, req *admin.CreateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/CreateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCreditEndpoint{CreateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteCreditEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context AdminClaim
}

func (s CreditService) DeleteCredit(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/DeleteCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCreditEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCreditEndpoint struct {
	*admin.GetCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) GetCredit(ctx context.Context, req *admin.GetCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditEndpoint{GetCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCreditsEndpoint struct {
	*admin.GetCreditsRequest
	Result  *etop.CreditsResponse
	Context AdminClaim
}

func (s CreditService) GetCredits(ctx context.Context, req *admin.GetCreditsRequest) (resp *etop.CreditsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/GetCredits"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCreditsEndpoint{GetCreditsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateCreditEndpoint struct {
	*admin.UpdateCreditRequest
	Result  *etop.Credit
	Context AdminClaim
}

func (s CreditService) UpdateCredit(ctx context.Context, req *admin.UpdateCreditRequest) (resp *etop.Credit, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Credit/UpdateCredit"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCreditEndpoint{UpdateCreditRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type NotificationService struct{}

type CreateNotificationsEndpoint struct {
	*admin.CreateNotificationsRequest
	Result  *admin.CreateNotificationsResponse
	Context AdminClaim
}

func (s NotificationService) CreateNotifications(ctx context.Context, req *admin.CreateNotificationsRequest) (resp *admin.CreateNotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "admin.Notification/CreateNotifications"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:          ctx,
		RequireAuth:      true,
		RequireEtopAdmin: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateNotificationsEndpoint{CreateNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.IsEtopAdmin = session.IsEtopAdmin
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
