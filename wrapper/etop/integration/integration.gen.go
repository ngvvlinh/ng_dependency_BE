// package integration generated by wrapper_gen. DO NOT EDIT.
package integrationW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	integration "etop.vn/backend/pb/etop/integration"
	common "etop.vn/backend/pkg/common"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	model "etop.vn/backend/pkg/etop/model"
	bus "etop.vn/common/bus"
	l "etop.vn/common/l"
)

var ll = l.New()

var Client Integration

type Integration interface {
	integration.MiscService
	integration.IntegrationService
}

type IntegrationClient struct {
	_MiscService        integration.MiscService
	_IntegrationService integration.IntegrationService
}

func NewIntegrationClient(addr string, client *http.Client) Integration {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &IntegrationClient{
		_MiscService:        integration.NewMiscServiceProtobufClient(addr, client),
		_IntegrationService: integration.NewIntegrationServiceProtobufClient(addr, client),
	}
}

func ConnectIntegrationService(addr string, client *http.Client) error {
	Client = NewIntegrationClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GrantAccessEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *InitEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *LoginUsingTokenEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RegisterEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RequestLoginEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SessionInfoEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to IntegrationService at %v", addr)
	}
	return err
}

func MustConnectIntegrationService(addr string, client *http.Client) {
	err := ConnectIntegrationService(addr, client)
	if err != nil {
		ll.Fatal("Unable to connect Integration", l.Error(err))
	}
}

type (
	EmptyClaim   = claims.EmptyClaim
	UserClaim    = claims.UserClaim
	AdminClaim   = claims.AdminClaim
	PartnerClaim = claims.PartnerClaim
	ShopClaim    = claims.ShopClaim
)

func (c *IntegrationClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) GrantAccess(ctx context.Context, in *integration.GrantAccessRequest) (*integration.GrantAccessResponse, error) {
	resp, err := c._IntegrationService.GrantAccess(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) Init(ctx context.Context, in *integration.InitRequest) (*integration.LoginResponse, error) {
	resp, err := c._IntegrationService.Init(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) LoginUsingToken(ctx context.Context, in *integration.LoginUsingTokenRequest) (*integration.LoginResponse, error) {
	resp, err := c._IntegrationService.LoginUsingToken(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) Register(ctx context.Context, in *integration.RegisterRequest) (*integration.RegisterResponse, error) {
	resp, err := c._IntegrationService.Register(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) RequestLogin(ctx context.Context, in *integration.RequestLoginRequest) (*integration.RequestLoginResponse, error) {
	resp, err := c._IntegrationService.RequestLogin(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *IntegrationClient) SessionInfo(ctx context.Context, in *cm.Empty) (*integration.LoginResponse, error) {
	resp, err := c._IntegrationService.SessionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewIntegrationServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&GrantAccessEndpoint{})
	bus.Expect(&InitEndpoint{})
	bus.Expect(&LoginUsingTokenEndpoint{})
	bus.Expect(&RegisterEndpoint{})
	bus.Expect(&RequestLoginEndpoint{})
	bus.Expect(&SessionInfoEndpoint{})
	mux.Handle(integration.MiscServicePathPrefix, integration.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(integration.IntegrationServicePathPrefix, integration.NewIntegrationServiceServer(IntegrationService{}, hooks))
}

type IntegrationImpl struct {
	MiscService
	IntegrationService
}

func NewIntegration() Integration {
	return IntegrationImpl{}
}

type MiscService struct{}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "integration.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type IntegrationService struct{}

type GrantAccessEndpoint struct {
	*integration.GrantAccessRequest
	Result     *integration.GrantAccessResponse
	Context    UserClaim
	CtxPartner *model.Partner
}

func (s IntegrationService) GrantAccess(ctx context.Context, req *integration.GrantAccessRequest) (resp *integration.GrantAccessResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "integration.Integration/GrantAccess"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 2,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GrantAccessEndpoint{GrantAccessRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type InitEndpoint struct {
	*integration.InitRequest
	Result  *integration.LoginResponse
	Context EmptyClaim
}

func (s IntegrationService) Init(ctx context.Context, req *integration.InitRequest) (resp *integration.LoginResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "integration.Integration/Init"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &InitEndpoint{InitRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type LoginUsingTokenEndpoint struct {
	*integration.LoginUsingTokenRequest
	Result     *integration.LoginResponse
	Context    EmptyClaim
	CtxPartner *model.Partner
}

func (s IntegrationService) LoginUsingToken(ctx context.Context, req *integration.LoginUsingTokenRequest) (resp *integration.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "integration.Integration/LoginUsingToken"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		AuthPartner: 2,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LoginUsingTokenEndpoint{LoginUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type RegisterEndpoint struct {
	*integration.RegisterRequest
	Result     *integration.RegisterResponse
	Context    EmptyClaim
	CtxPartner *model.Partner
}

func (s IntegrationService) Register(ctx context.Context, req *integration.RegisterRequest) (resp *integration.RegisterResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "integration.Integration/Register"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		AuthPartner: 2,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterEndpoint{RegisterRequest: req}
	query.Context.Claim = session.Claim
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type RequestLoginEndpoint struct {
	*integration.RequestLoginRequest
	Result     *integration.RequestLoginResponse
	Context    EmptyClaim
	CtxPartner *model.Partner
}

func (s IntegrationService) RequestLogin(ctx context.Context, req *integration.RequestLoginRequest) (resp *integration.RequestLoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "integration.Integration/RequestLogin"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		AuthPartner: 2,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestLoginEndpoint{RequestLoginRequest: req}
	query.Context.Claim = session.Claim
	query.CtxPartner = session.CtxPartner
	// Verify captcha token
	if err := middleware.VerifyCaptcha(ctx, req.RecaptchaToken); err != nil {
		return nil, err
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type SessionInfoEndpoint struct {
	*cm.Empty
	Result     *integration.LoginResponse
	Context    EmptyClaim
	CtxPartner *model.Partner
}

func (s IntegrationService) SessionInfo(ctx context.Context, req *cm.Empty) (resp *integration.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "integration.Integration/SessionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		AuthPartner: 2,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SessionInfoEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
