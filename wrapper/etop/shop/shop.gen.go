// package shop generated by wrapper_gen. DO NOT EDIT.
package shopW

import (
	"context"
	"net/http"
	"time"

	"github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	order "etop.vn/backend/pb/etop/order"
	shop "etop.vn/backend/pb/etop/shop"
	common "etop.vn/backend/pkg/common"
	"etop.vn/backend/pkg/common/bus"
	"etop.vn/backend/pkg/common/l"
	"etop.vn/backend/pkg/common/metrics"
	cmWrapper "etop.vn/backend/pkg/common/wrapper"
	"etop.vn/backend/pkg/etop/authorize/claims"
	"etop.vn/backend/pkg/etop/authorize/middleware"
	"etop.vn/backend/pkg/etop/authorize/permission"
	"etop.vn/backend/pkg/etop/model"
)

var ll = l.New()

var Client Shop

type Shop interface {
	shop.MiscService
	shop.AccountService
	shop.CollectionService
	shop.ProductService
	shop.ProductSourceService
	shop.OrderService
	shop.FulfillmentService
	shop.ShipnowService
	shop.HistoryService
	shop.MoneyTransactionService
	shop.SummaryService
	shop.ExportService
	shop.NotificationService
	shop.AuthorizeService
}

type ShopClient struct {
	_MiscService             shop.MiscService
	_AccountService          shop.AccountService
	_CollectionService       shop.CollectionService
	_ProductService          shop.ProductService
	_ProductSourceService    shop.ProductSourceService
	_OrderService            shop.OrderService
	_FulfillmentService      shop.FulfillmentService
	_ShipnowService          shop.ShipnowService
	_HistoryService          shop.HistoryService
	_MoneyTransactionService shop.MoneyTransactionService
	_SummaryService          shop.SummaryService
	_ExportService           shop.ExportService
	_NotificationService     shop.NotificationService
	_AuthorizeService        shop.AuthorizeService
}

func NewShopClient(addr string, client *http.Client) Shop {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &ShopClient{
		_MiscService:             shop.NewMiscServiceProtobufClient(addr, client),
		_AccountService:          shop.NewAccountServiceProtobufClient(addr, client),
		_CollectionService:       shop.NewCollectionServiceProtobufClient(addr, client),
		_ProductService:          shop.NewProductServiceProtobufClient(addr, client),
		_ProductSourceService:    shop.NewProductSourceServiceProtobufClient(addr, client),
		_OrderService:            shop.NewOrderServiceProtobufClient(addr, client),
		_FulfillmentService:      shop.NewFulfillmentServiceProtobufClient(addr, client),
		_ShipnowService:          shop.NewShipnowServiceProtobufClient(addr, client),
		_HistoryService:          shop.NewHistoryServiceProtobufClient(addr, client),
		_MoneyTransactionService: shop.NewMoneyTransactionServiceProtobufClient(addr, client),
		_SummaryService:          shop.NewSummaryServiceProtobufClient(addr, client),
		_ExportService:           shop.NewExportServiceProtobufClient(addr, client),
		_NotificationService:     shop.NewNotificationServiceProtobufClient(addr, client),
		_AuthorizeService:        shop.NewAuthorizeServiceProtobufClient(addr, client),
	}
}

func ConnectShopService(addr string, client *http.Client) error {
	Client = NewShopClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateExternalAccountAhamoveEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetBalanceShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetExternalAccountAhamoveEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RegisterShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RequestVerifyExternalAccountAhamoveEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SetDefaultAddressEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateExternalAccountAhamoveVerificationImagesEndpoint) error {
		panic("Unexpected")
	})
	bus.AddHandler("client", func(ctx context.Context, q *UpdateShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetCollectionsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetCollectionsByIDsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveProductsCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductsCollectionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *AddProductsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProductEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProductsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProductsByIDsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveProductsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveVariantsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductImagesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductsTagsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateVariantEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateVariantImagesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateVariantsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateProductSourceEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateProductSourceCategoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateVariantEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProductSourceCategoriesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProductSourceCategoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShopProductSourcesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveProductSourceCategoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductSourceCategoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateProductsPSCategoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CancelOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmOrderAndCreateFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmOrdersAndCreateFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrdersEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrdersByIDsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateOrderPaymentStatusEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateOrdersStatusEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CancelFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateFulfillmentsForOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetExternalShippingServicesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetPublicExternalShippingServicesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetPublicFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateFulfillmentsShippingStateEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CancelShipnowFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ConfirmShipnowFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateShipnowFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShipnowFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShipnowFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShipnowServicesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateShipnowFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentHistoryEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetMoneyTransactionsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CalcBalanceShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SummarizeFulfillmentsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetExportsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RequestExportEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateDeviceEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteDeviceEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetNotificationEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetNotificationsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateNotificationsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *AuthorizePartnerEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetAuthorizedPartnersEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetAvailablePartnersEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to ShopService at %v", addr)
	}
	return err
}

func MustConnectShopService(addr string, client *http.Client) {
	err := ConnectShopService(addr, client)
	if err != nil {
		ll.Fatal("Unable to connect Shop", l.Error(err))
	}
}

type (
	EmptyClaim   = claims.EmptyClaim
	UserClaim    = claims.UserClaim
	AdminClaim   = claims.AdminClaim
	PartnerClaim = claims.PartnerClaim
	ShopClaim    = claims.ShopClaim
)

func (c *ShopClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateExternalAccountAhamove(ctx context.Context, in *cm.Empty) (*shop.ExternalAccountAhamove, error) {
	resp, err := c._AccountService.CreateExternalAccountAhamove(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) DeleteShop(ctx context.Context, in *cm.IDRequest) (*cm.Empty, error) {
	resp, err := c._AccountService.DeleteShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetBalanceShop(ctx context.Context, in *cm.Empty) (*shop.GetBalanceShopResponse, error) {
	resp, err := c._AccountService.GetBalanceShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetExternalAccountAhamove(ctx context.Context, in *cm.Empty) (*shop.ExternalAccountAhamove, error) {
	resp, err := c._AccountService.GetExternalAccountAhamove(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RegisterShop(ctx context.Context, in *shop.RegisterShopRequest) (*shop.RegisterShopResponse, error) {
	resp, err := c._AccountService.RegisterShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RequestVerifyExternalAccountAhamove(ctx context.Context, in *cm.Empty) (*cm.UpdatedResponse, error) {
	resp, err := c._AccountService.RequestVerifyExternalAccountAhamove(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) SetDefaultAddress(ctx context.Context, in *etop.SetDefaultAddressRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._AccountService.SetDefaultAddress(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateExternalAccountAhamoveVerificationImages(ctx context.Context, in *shop.UpdateXAccountAhamoveVerificationImagesRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._AccountService.UpdateExternalAccountAhamoveVerificationImages(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateShop(ctx context.Context, in *shop.UpdateShopRequest) (*shop.UpdateShopResponse, error) {
	resp, err := c._AccountService.UpdateShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateCollection(ctx context.Context, in *shop.CreateCollectionRequest) (*shop.Collection, error) {
	resp, err := c._CollectionService.CreateCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) DeleteCollection(ctx context.Context, in *cm.IDRequest) (*cm.RemovedResponse, error) {
	resp, err := c._CollectionService.DeleteCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetCollection(ctx context.Context, in *cm.IDRequest) (*shop.Collection, error) {
	resp, err := c._CollectionService.GetCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetCollections(ctx context.Context, in *cm.Empty) (*shop.CollectionsResponse, error) {
	resp, err := c._CollectionService.GetCollections(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetCollectionsByIDs(ctx context.Context, in *cm.IDsRequest) (*shop.CollectionsResponse, error) {
	resp, err := c._CollectionService.GetCollectionsByIDs(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RemoveProductsCollection(ctx context.Context, in *shop.RemoveProductsCollectionRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._CollectionService.RemoveProductsCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateCollection(ctx context.Context, in *shop.UpdateCollectionRequest) (*shop.Collection, error) {
	resp, err := c._CollectionService.UpdateCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProductsCollection(ctx context.Context, in *shop.UpdateProductsCollectionRequest) (*shop.UpdateProductsCollectionResponse, error) {
	resp, err := c._CollectionService.UpdateProductsCollection(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) AddProducts(ctx context.Context, in *shop.AddProductsRequest) (*shop.AddProductsResponse, error) {
	resp, err := c._ProductService.AddProducts(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetProduct(ctx context.Context, in *cm.IDRequest) (*shop.ShopProduct, error) {
	resp, err := c._ProductService.GetProduct(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetProducts(ctx context.Context, in *shop.GetVariantsRequest) (*shop.ShopProductsResponse, error) {
	resp, err := c._ProductService.GetProducts(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetProductsByIDs(ctx context.Context, in *cm.IDsRequest) (*shop.ShopProductsResponse, error) {
	resp, err := c._ProductService.GetProductsByIDs(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RemoveProducts(ctx context.Context, in *shop.RemoveVariantsRequest) (*cm.RemovedResponse, error) {
	resp, err := c._ProductService.RemoveProducts(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RemoveVariants(ctx context.Context, in *shop.RemoveVariantsRequest) (*cm.RemovedResponse, error) {
	resp, err := c._ProductService.RemoveVariants(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProduct(ctx context.Context, in *shop.UpdateProductRequest) (*shop.ShopProduct, error) {
	resp, err := c._ProductService.UpdateProduct(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProductImages(ctx context.Context, in *shop.UpdateVariantImagesRequest) (*shop.ShopProduct, error) {
	resp, err := c._ProductService.UpdateProductImages(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProductsTags(ctx context.Context, in *shop.UpdateProductsTagsRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._ProductService.UpdateProductsTags(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateVariant(ctx context.Context, in *shop.UpdateVariantRequest) (*shop.ShopVariant, error) {
	resp, err := c._ProductService.UpdateVariant(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateVariantImages(ctx context.Context, in *shop.UpdateVariantImagesRequest) (*shop.ShopVariant, error) {
	resp, err := c._ProductService.UpdateVariantImages(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateVariants(ctx context.Context, in *shop.UpdateVariantsRequest) (*shop.UpdateVariantsResponse, error) {
	resp, err := c._ProductService.UpdateVariants(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateProductSource(ctx context.Context, in *shop.CreateProductSourceRequest) (*shop.ProductSource, error) {
	resp, err := c._ProductSourceService.CreateProductSource(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateProductSourceCategory(ctx context.Context, in *shop.CreatePSCategoryRequest) (*shop.Category, error) {
	resp, err := c._ProductSourceService.CreateProductSourceCategory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateVariant(ctx context.Context, in *shop.CreateVariantRequest) (*shop.ShopProduct, error) {
	resp, err := c._ProductSourceService.CreateVariant(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetProductSourceCategories(ctx context.Context, in *shop.GetProductSourceCategoriesRequest) (*shop.CategoriesResponse, error) {
	resp, err := c._ProductSourceService.GetProductSourceCategories(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetProductSourceCategory(ctx context.Context, in *cm.IDRequest) (*shop.Category, error) {
	resp, err := c._ProductSourceService.GetProductSourceCategory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetShopProductSources(ctx context.Context, in *cm.Empty) (*shop.ProductSourcesResponse, error) {
	resp, err := c._ProductSourceService.GetShopProductSources(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RemoveProductSourceCategory(ctx context.Context, in *cm.IDRequest) (*cm.RemovedResponse, error) {
	resp, err := c._ProductSourceService.RemoveProductSourceCategory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProductSourceCategory(ctx context.Context, in *shop.UpdateProductSourceCategoryRequest) (*shop.Category, error) {
	resp, err := c._ProductSourceService.UpdateProductSourceCategory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateProductsPSCategory(ctx context.Context, in *shop.UpdateProductsPSCategoryRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._ProductSourceService.UpdateProductsPSCategory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CancelOrder(ctx context.Context, in *shop.CancelOrderRequest) (*order.OrderWithErrorsResponse, error) {
	resp, err := c._OrderService.CancelOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) ConfirmOrderAndCreateFulfillments(ctx context.Context, in *shop.OrderIDRequest) (*order.OrderWithErrorsResponse, error) {
	resp, err := c._OrderService.ConfirmOrderAndCreateFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) ConfirmOrdersAndCreateFulfillments(ctx context.Context, in *shop.OrderIDsRequest) (*cm.ErrorsResponse, error) {
	resp, err := c._OrderService.ConfirmOrdersAndCreateFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateOrder(ctx context.Context, in *order.CreateOrderRequest) (*order.Order, error) {
	resp, err := c._OrderService.CreateOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetOrder(ctx context.Context, in *cm.IDRequest) (*order.Order, error) {
	resp, err := c._OrderService.GetOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetOrders(ctx context.Context, in *shop.GetOrdersRequest) (*order.OrdersResponse, error) {
	resp, err := c._OrderService.GetOrders(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetOrdersByIDs(ctx context.Context, in *etop.IDsRequest) (*order.OrdersResponse, error) {
	resp, err := c._OrderService.GetOrdersByIDs(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateOrder(ctx context.Context, in *order.UpdateOrderRequest) (*order.Order, error) {
	resp, err := c._OrderService.UpdateOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateOrderPaymentStatus(ctx context.Context, in *shop.UpdateOrderPaymentStatusRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._OrderService.UpdateOrderPaymentStatus(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateOrdersStatus(ctx context.Context, in *shop.UpdateOrdersStatusRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._OrderService.UpdateOrdersStatus(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CancelFulfillment(ctx context.Context, in *cm.IDRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._FulfillmentService.CancelFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateFulfillmentsForOrder(ctx context.Context, in *shop.CreateFulfillmentsForOrderRequest) (*order.Order, error) {
	resp, err := c._FulfillmentService.CreateFulfillmentsForOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetExternalShippingServices(ctx context.Context, in *order.GetExternalShippingServicesRequest) (*order.GetExternalShippingServicesResponse, error) {
	resp, err := c._FulfillmentService.GetExternalShippingServices(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetFulfillment(ctx context.Context, in *cm.IDRequest) (*order.Fulfillment, error) {
	resp, err := c._FulfillmentService.GetFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetFulfillments(ctx context.Context, in *shop.GetFulfillmentsRequest) (*order.FulfillmentsResponse, error) {
	resp, err := c._FulfillmentService.GetFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetPublicExternalShippingServices(ctx context.Context, in *order.GetExternalShippingServicesRequest) (*order.GetExternalShippingServicesResponse, error) {
	resp, err := c._FulfillmentService.GetPublicExternalShippingServices(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetPublicFulfillment(ctx context.Context, in *shop.GetPublicFulfillmentRequest) (*order.PublicFulfillment, error) {
	resp, err := c._FulfillmentService.GetPublicFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateFulfillmentsShippingState(ctx context.Context, in *shop.UpdateFulfillmentsShippingStateRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._FulfillmentService.UpdateFulfillmentsShippingState(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CancelShipnowFulfillment(ctx context.Context, in *order.CancelShipnowFulfillmentRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._ShipnowService.CancelShipnowFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) ConfirmShipnowFulfillment(ctx context.Context, in *cm.IDRequest) (*order.ShipnowFulfillment, error) {
	resp, err := c._ShipnowService.ConfirmShipnowFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateShipnowFulfillment(ctx context.Context, in *order.CreateShipnowFulfillmentRequest) (*order.ShipnowFulfillment, error) {
	resp, err := c._ShipnowService.CreateShipnowFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetShipnowFulfillment(ctx context.Context, in *cm.IDRequest) (*order.ShipnowFulfillment, error) {
	resp, err := c._ShipnowService.GetShipnowFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetShipnowFulfillments(ctx context.Context, in *order.GetShipnowFulfillmentsRequest) (*order.ShipnowFulfillments, error) {
	resp, err := c._ShipnowService.GetShipnowFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetShipnowServices(ctx context.Context, in *order.GetShipnowServicesRequest) (*order.GetShipnowServicesResponse, error) {
	resp, err := c._ShipnowService.GetShipnowServices(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateShipnowFulfillment(ctx context.Context, in *order.UpdateShipnowFulfillmentRequest) (*order.ShipnowFulfillment, error) {
	resp, err := c._ShipnowService.UpdateShipnowFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetFulfillmentHistory(ctx context.Context, in *shop.GetFulfillmentHistoryRequest) (*etop.HistoryResponse, error) {
	resp, err := c._HistoryService.GetFulfillmentHistory(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetMoneyTransaction(ctx context.Context, in *cm.IDRequest) (*order.MoneyTransaction, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransaction(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetMoneyTransactions(ctx context.Context, in *shop.GetMoneyTransactionsRequest) (*order.MoneyTransactionsResponse, error) {
	resp, err := c._MoneyTransactionService.GetMoneyTransactions(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CalcBalanceShop(ctx context.Context, in *cm.Empty) (*shop.CalcBalanceShopResponse, error) {
	resp, err := c._SummaryService.CalcBalanceShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) SummarizeFulfillments(ctx context.Context, in *shop.SummarizeFulfillmentsRequest) (*shop.SummarizeFulfillmentsResponse, error) {
	resp, err := c._SummaryService.SummarizeFulfillments(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetExports(ctx context.Context, in *shop.GetExportsRequest) (*shop.GetExportsResponse, error) {
	resp, err := c._ExportService.GetExports(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) RequestExport(ctx context.Context, in *shop.RequestExportRequest) (*shop.RequestExportResponse, error) {
	resp, err := c._ExportService.RequestExport(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) CreateDevice(ctx context.Context, in *etop.CreateDeviceRequest) (*etop.Device, error) {
	resp, err := c._NotificationService.CreateDevice(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) DeleteDevice(ctx context.Context, in *etop.DeleteDeviceRequest) (*cm.DeletedResponse, error) {
	resp, err := c._NotificationService.DeleteDevice(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetNotification(ctx context.Context, in *cm.IDRequest) (*etop.Notification, error) {
	resp, err := c._NotificationService.GetNotification(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetNotifications(ctx context.Context, in *etop.GetNotificationsRequest) (*etop.NotificationsResponse, error) {
	resp, err := c._NotificationService.GetNotifications(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) UpdateNotifications(ctx context.Context, in *etop.UpdateNotificationsRequest) (*cm.UpdatedResponse, error) {
	resp, err := c._NotificationService.UpdateNotifications(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) AuthorizePartner(ctx context.Context, in *shop.AuthorizePartnerRequest) (*shop.AuthorizedPartnerResponse, error) {
	resp, err := c._AuthorizeService.AuthorizePartner(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetAuthorizedPartners(ctx context.Context, in *cm.Empty) (*shop.GetAuthorizedPartnersResponse, error) {
	resp, err := c._AuthorizeService.GetAuthorizedPartners(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *ShopClient) GetAvailablePartners(ctx context.Context, in *cm.Empty) (*shop.GetPartnersResponse, error) {
	resp, err := c._AuthorizeService.GetAvailablePartners(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewShopServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&CreateExternalAccountAhamoveEndpoint{})
	bus.Expect(&DeleteShopEndpoint{})
	bus.Expect(&GetBalanceShopEndpoint{})
	bus.Expect(&GetExternalAccountAhamoveEndpoint{})
	bus.Expect(&RegisterShopEndpoint{})
	bus.Expect(&RequestVerifyExternalAccountAhamoveEndpoint{})
	bus.Expect(&SetDefaultAddressEndpoint{})
	bus.Expect(&UpdateExternalAccountAhamoveVerificationImagesEndpoint{})
	bus.Expect(&UpdateShopEndpoint{})
	bus.Expect(&CreateCollectionEndpoint{})
	bus.Expect(&DeleteCollectionEndpoint{})
	bus.Expect(&GetCollectionEndpoint{})
	bus.Expect(&GetCollectionsEndpoint{})
	bus.Expect(&GetCollectionsByIDsEndpoint{})
	bus.Expect(&RemoveProductsCollectionEndpoint{})
	bus.Expect(&UpdateCollectionEndpoint{})
	bus.Expect(&UpdateProductsCollectionEndpoint{})
	bus.Expect(&AddProductsEndpoint{})
	bus.Expect(&GetProductEndpoint{})
	bus.Expect(&GetProductsEndpoint{})
	bus.Expect(&GetProductsByIDsEndpoint{})
	bus.Expect(&RemoveProductsEndpoint{})
	bus.Expect(&RemoveVariantsEndpoint{})
	bus.Expect(&UpdateProductEndpoint{})
	bus.Expect(&UpdateProductImagesEndpoint{})
	bus.Expect(&UpdateProductsTagsEndpoint{})
	bus.Expect(&UpdateVariantEndpoint{})
	bus.Expect(&UpdateVariantImagesEndpoint{})
	bus.Expect(&UpdateVariantsEndpoint{})
	bus.Expect(&CreateProductSourceEndpoint{})
	bus.Expect(&CreateProductSourceCategoryEndpoint{})
	bus.Expect(&CreateVariantEndpoint{})
	bus.Expect(&GetProductSourceCategoriesEndpoint{})
	bus.Expect(&GetProductSourceCategoryEndpoint{})
	bus.Expect(&GetShopProductSourcesEndpoint{})
	bus.Expect(&RemoveProductSourceCategoryEndpoint{})
	bus.Expect(&UpdateProductSourceCategoryEndpoint{})
	bus.Expect(&UpdateProductsPSCategoryEndpoint{})
	bus.Expect(&CancelOrderEndpoint{})
	bus.Expect(&ConfirmOrderAndCreateFulfillmentsEndpoint{})
	bus.Expect(&ConfirmOrdersAndCreateFulfillmentsEndpoint{})
	bus.Expect(&CreateOrderEndpoint{})
	bus.Expect(&GetOrderEndpoint{})
	bus.Expect(&GetOrdersEndpoint{})
	bus.Expect(&GetOrdersByIDsEndpoint{})
	bus.Expect(&UpdateOrderEndpoint{})
	bus.Expect(&UpdateOrderPaymentStatusEndpoint{})
	bus.Expect(&UpdateOrdersStatusEndpoint{})
	bus.Expect(&CancelFulfillmentEndpoint{})
	bus.Expect(&CreateFulfillmentsForOrderEndpoint{})
	bus.Expect(&GetExternalShippingServicesEndpoint{})
	bus.Expect(&GetFulfillmentEndpoint{})
	bus.Expect(&GetFulfillmentsEndpoint{})
	bus.Expect(&GetPublicExternalShippingServicesEndpoint{})
	bus.Expect(&GetPublicFulfillmentEndpoint{})
	bus.Expect(&UpdateFulfillmentsShippingStateEndpoint{})
	bus.Expect(&CancelShipnowFulfillmentEndpoint{})
	bus.Expect(&ConfirmShipnowFulfillmentEndpoint{})
	bus.Expect(&CreateShipnowFulfillmentEndpoint{})
	bus.Expect(&GetShipnowFulfillmentEndpoint{})
	bus.Expect(&GetShipnowFulfillmentsEndpoint{})
	bus.Expect(&GetShipnowServicesEndpoint{})
	bus.Expect(&UpdateShipnowFulfillmentEndpoint{})
	bus.Expect(&GetFulfillmentHistoryEndpoint{})
	bus.Expect(&GetMoneyTransactionEndpoint{})
	bus.Expect(&GetMoneyTransactionsEndpoint{})
	bus.Expect(&CalcBalanceShopEndpoint{})
	bus.Expect(&SummarizeFulfillmentsEndpoint{})
	bus.Expect(&GetExportsEndpoint{})
	bus.Expect(&RequestExportEndpoint{})
	bus.Expect(&CreateDeviceEndpoint{})
	bus.Expect(&DeleteDeviceEndpoint{})
	bus.Expect(&GetNotificationEndpoint{})
	bus.Expect(&GetNotificationsEndpoint{})
	bus.Expect(&UpdateNotificationsEndpoint{})
	bus.Expect(&AuthorizePartnerEndpoint{})
	bus.Expect(&GetAuthorizedPartnersEndpoint{})
	bus.Expect(&GetAvailablePartnersEndpoint{})
	mux.Handle(shop.MiscServicePathPrefix, shop.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(shop.AccountServicePathPrefix, shop.NewAccountServiceServer(AccountService{}, hooks))
	mux.Handle(shop.CollectionServicePathPrefix, shop.NewCollectionServiceServer(CollectionService{}, hooks))
	mux.Handle(shop.ProductServicePathPrefix, shop.NewProductServiceServer(ProductService{}, hooks))
	mux.Handle(shop.ProductSourceServicePathPrefix, shop.NewProductSourceServiceServer(ProductSourceService{}, hooks))
	mux.Handle(shop.OrderServicePathPrefix, shop.NewOrderServiceServer(OrderService{}, hooks))
	mux.Handle(shop.FulfillmentServicePathPrefix, shop.NewFulfillmentServiceServer(FulfillmentService{}, hooks))
	mux.Handle(shop.ShipnowServicePathPrefix, shop.NewShipnowServiceServer(ShipnowService{}, hooks))
	mux.Handle(shop.HistoryServicePathPrefix, shop.NewHistoryServiceServer(HistoryService{}, hooks))
	mux.Handle(shop.MoneyTransactionServicePathPrefix, shop.NewMoneyTransactionServiceServer(MoneyTransactionService{}, hooks))
	mux.Handle(shop.SummaryServicePathPrefix, shop.NewSummaryServiceServer(SummaryService{}, hooks))
	mux.Handle(shop.ExportServicePathPrefix, shop.NewExportServiceServer(ExportService{}, hooks))
	mux.Handle(shop.NotificationServicePathPrefix, shop.NewNotificationServiceServer(NotificationService{}, hooks))
	mux.Handle(shop.AuthorizeServicePathPrefix, shop.NewAuthorizeServiceServer(AuthorizeService{}, hooks))
}

type ShopImpl struct {
	MiscService
	AccountService
	CollectionService
	ProductService
	ProductSourceService
	OrderService
	FulfillmentService
	ShipnowService
	HistoryService
	MoneyTransactionService
	SummaryService
	ExportService
	NotificationService
	AuthorizeService
}

func NewShop() Shop {
	return ShopImpl{}
}

type MiscService struct{}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type AccountService struct{}

type CreateExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *shop.ExternalAccountAhamove
	Context ShopClaim
}

func (s AccountService) CreateExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *shop.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/CreateExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteShopEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context ShopClaim
}

func (s AccountService) DeleteShop(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/DeleteShop"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteShopEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "owner"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 8 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetBalanceShopEndpoint struct {
	*cm.Empty
	Result  *shop.GetBalanceShopResponse
	Context ShopClaim
}

func (s AccountService) GetBalanceShop(ctx context.Context, req *cm.Empty) (resp *shop.GetBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetBalanceShop"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBalanceShopEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *shop.ExternalAccountAhamove
	Context ShopClaim
}

func (s AccountService) GetExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *shop.ExternalAccountAhamove, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/GetExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RegisterShopEndpoint struct {
	*shop.RegisterShopRequest
	Result     *shop.RegisterShopResponse
	Context    UserClaim
	CtxPartner *model.Partner
}

func (s AccountService) RegisterShop(ctx context.Context, req *shop.RegisterShopRequest) (resp *shop.RegisterShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RegisterShop"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RegisterShopEndpoint{RegisterShopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RequestVerifyExternalAccountAhamoveEndpoint struct {
	*cm.Empty
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s AccountService) RequestVerifyExternalAccountAhamove(ctx context.Context, req *cm.Empty) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/RequestVerifyExternalAccountAhamove"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestVerifyExternalAccountAhamoveEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SetDefaultAddressEndpoint struct {
	*etop.SetDefaultAddressRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s AccountService) SetDefaultAddress(ctx context.Context, req *etop.SetDefaultAddressRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/SetDefaultAddress"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SetDefaultAddressEndpoint{SetDefaultAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateExternalAccountAhamoveVerificationImagesEndpoint struct {
	*shop.UpdateXAccountAhamoveVerificationImagesRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s AccountService) UpdateExternalAccountAhamoveVerificationImages(ctx context.Context, req *shop.UpdateXAccountAhamoveVerificationImagesRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateExternalAccountAhamoveVerificationImages"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateExternalAccountAhamoveVerificationImagesEndpoint{UpdateXAccountAhamoveVerificationImagesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateShopEndpoint struct {
	*shop.UpdateShopRequest
	Result  *shop.UpdateShopResponse
	Context ShopClaim
}

func (s AccountService) UpdateShop(ctx context.Context, req *shop.UpdateShopRequest) (resp *shop.UpdateShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Account/UpdateShop"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShopEndpoint{UpdateShopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "admin"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 4 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CollectionService struct{}

type CreateCollectionEndpoint struct {
	*shop.CreateCollectionRequest
	Result  *shop.Collection
	Context ShopClaim
}

func (s CollectionService) CreateCollection(ctx context.Context, req *shop.CreateCollectionRequest) (resp *shop.Collection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/CreateCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateCollectionEndpoint{CreateCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteCollectionEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context ShopClaim
}

func (s CollectionService) DeleteCollection(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/DeleteCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteCollectionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCollectionEndpoint struct {
	*cm.IDRequest
	Result  *shop.Collection
	Context ShopClaim
}

func (s CollectionService) GetCollection(ctx context.Context, req *cm.IDRequest) (resp *shop.Collection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCollectionsEndpoint struct {
	*cm.Empty
	Result  *shop.CollectionsResponse
	Context ShopClaim
}

func (s CollectionService) GetCollections(ctx context.Context, req *cm.Empty) (resp *shop.CollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollections"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetCollectionsByIDsEndpoint struct {
	*cm.IDsRequest
	Result  *shop.CollectionsResponse
	Context ShopClaim
}

func (s CollectionService) GetCollectionsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.CollectionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/GetCollectionsByIDs"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetCollectionsByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveProductsCollectionEndpoint struct {
	*shop.RemoveProductsCollectionRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s CollectionService) RemoveProductsCollection(ctx context.Context, req *shop.RemoveProductsCollectionRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/RemoveProductsCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductsCollectionEndpoint{RemoveProductsCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateCollectionEndpoint struct {
	*shop.UpdateCollectionRequest
	Result  *shop.Collection
	Context ShopClaim
}

func (s CollectionService) UpdateCollection(ctx context.Context, req *shop.UpdateCollectionRequest) (resp *shop.Collection, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/UpdateCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateCollectionEndpoint{UpdateCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductsCollectionEndpoint struct {
	*shop.UpdateProductsCollectionRequest
	Result  *shop.UpdateProductsCollectionResponse
	Context ShopClaim
}

func (s CollectionService) UpdateProductsCollection(ctx context.Context, req *shop.UpdateProductsCollectionRequest) (resp *shop.UpdateProductsCollectionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Collection/UpdateProductsCollection"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsCollectionEndpoint{UpdateProductsCollectionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ProductService struct{}

type AddProductsEndpoint struct {
	*shop.AddProductsRequest
	Result     *shop.AddProductsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductService) AddProducts(ctx context.Context, req *shop.AddProductsRequest) (resp *shop.AddProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/AddProducts"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AddProductsEndpoint{AddProductsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductEndpoint struct {
	*cm.IDRequest
	Result     *shop.ShopProduct
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductService) GetProduct(ctx context.Context, req *cm.IDRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProduct"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductsEndpoint struct {
	*shop.GetVariantsRequest
	Result     *shop.ShopProductsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductService) GetProducts(ctx context.Context, req *shop.GetVariantsRequest) (resp *shop.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProducts"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsEndpoint{GetVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductsByIDsEndpoint struct {
	*cm.IDsRequest
	Result     *shop.ShopProductsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductService) GetProductsByIDs(ctx context.Context, req *cm.IDsRequest) (resp *shop.ShopProductsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/GetProductsByIDs"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductsByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveProductsEndpoint struct {
	*shop.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context ShopClaim
}

func (s ProductService) RemoveProducts(ctx context.Context, req *shop.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveProducts"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductsEndpoint{RemoveVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveVariantsEndpoint struct {
	*shop.RemoveVariantsRequest
	Result  *cm.RemovedResponse
	Context ShopClaim
}

func (s ProductService) RemoveVariants(ctx context.Context, req *shop.RemoveVariantsRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/RemoveVariants"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveVariantsEndpoint{RemoveVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductEndpoint struct {
	*shop.UpdateProductRequest
	Result  *shop.ShopProduct
	Context ShopClaim
}

func (s ProductService) UpdateProduct(ctx context.Context, req *shop.UpdateProductRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProduct"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductEndpoint{UpdateProductRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductImagesEndpoint struct {
	*shop.UpdateVariantImagesRequest
	Result  *shop.ShopProduct
	Context ShopClaim
}

func (s ProductService) UpdateProductImages(ctx context.Context, req *shop.UpdateVariantImagesRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductImages"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductImagesEndpoint{UpdateVariantImagesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductsTagsEndpoint struct {
	*shop.UpdateProductsTagsRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s ProductService) UpdateProductsTags(ctx context.Context, req *shop.UpdateProductsTagsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateProductsTags"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsTagsEndpoint{UpdateProductsTagsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateVariantEndpoint struct {
	*shop.UpdateVariantRequest
	Result  *shop.ShopVariant
	Context ShopClaim
}

func (s ProductService) UpdateVariant(ctx context.Context, req *shop.UpdateVariantRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariant"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantEndpoint{UpdateVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateVariantImagesEndpoint struct {
	*shop.UpdateVariantImagesRequest
	Result  *shop.ShopVariant
	Context ShopClaim
}

func (s ProductService) UpdateVariantImages(ctx context.Context, req *shop.UpdateVariantImagesRequest) (resp *shop.ShopVariant, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariantImages"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantImagesEndpoint{UpdateVariantImagesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateVariantsEndpoint struct {
	*shop.UpdateVariantsRequest
	Result  *shop.UpdateVariantsResponse
	Context ShopClaim
}

func (s ProductService) UpdateVariants(ctx context.Context, req *shop.UpdateVariantsRequest) (resp *shop.UpdateVariantsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Product/UpdateVariants"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateVariantsEndpoint{UpdateVariantsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ProductSourceService struct{}

type CreateProductSourceEndpoint struct {
	*shop.CreateProductSourceRequest
	Result  *shop.ProductSource
	Context ShopClaim
}

func (s ProductSourceService) CreateProductSource(ctx context.Context, req *shop.CreateProductSourceRequest) (resp *shop.ProductSource, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSource"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceEndpoint{CreateProductSourceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateProductSourceCategoryEndpoint struct {
	*shop.CreatePSCategoryRequest
	Result  *shop.Category
	Context ShopClaim
}

func (s ProductSourceService) CreateProductSourceCategory(ctx context.Context, req *shop.CreatePSCategoryRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateProductSourceCategoryEndpoint{CreatePSCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateVariantEndpoint struct {
	*shop.CreateVariantRequest
	Result     *shop.ShopProduct
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductSourceService) CreateVariant(ctx context.Context, req *shop.CreateVariantRequest) (resp *shop.ShopProduct, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/CreateVariant"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateVariantEndpoint{CreateVariantRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductSourceCategoriesEndpoint struct {
	*shop.GetProductSourceCategoriesRequest
	Result     *shop.CategoriesResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductSourceService) GetProductSourceCategories(ctx context.Context, req *shop.GetProductSourceCategoriesRequest) (resp *shop.CategoriesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategories"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoriesEndpoint{GetProductSourceCategoriesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result     *shop.Category
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductSourceService) GetProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProductSourceCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShopProductSourcesEndpoint struct {
	*cm.Empty
	Result     *shop.ProductSourcesResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s ProductSourceService) GetShopProductSources(ctx context.Context, req *cm.Empty) (resp *shop.ProductSourcesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/GetShopProductSources"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShopProductSourcesEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveProductSourceCategoryEndpoint struct {
	*cm.IDRequest
	Result  *cm.RemovedResponse
	Context ShopClaim
}

func (s ProductSourceService) RemoveProductSourceCategory(ctx context.Context, req *cm.IDRequest) (resp *cm.RemovedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/RemoveProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveProductSourceCategoryEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "admin"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 4 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductSourceCategoryEndpoint struct {
	*shop.UpdateProductSourceCategoryRequest
	Result  *shop.Category
	Context ShopClaim
}

func (s ProductSourceService) UpdateProductSourceCategory(ctx context.Context, req *shop.UpdateProductSourceCategoryRequest) (resp *shop.Category, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductSourceCategory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductSourceCategoryEndpoint{UpdateProductSourceCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateProductsPSCategoryEndpoint struct {
	*shop.UpdateProductsPSCategoryRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s ProductSourceService) UpdateProductsPSCategory(ctx context.Context, req *shop.UpdateProductsPSCategoryRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.ProductSource/UpdateProductsPSCategory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateProductsPSCategoryEndpoint{UpdateProductsPSCategoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type OrderService struct{}

type CancelOrderEndpoint struct {
	*shop.CancelOrderRequest
	Result     *order.OrderWithErrorsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) CancelOrder(ctx context.Context, req *shop.CancelOrderRequest) (resp *order.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelOrderEndpoint{CancelOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmOrderAndCreateFulfillmentsEndpoint struct {
	*shop.OrderIDRequest
	Result     *order.OrderWithErrorsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) ConfirmOrderAndCreateFulfillments(ctx context.Context, req *shop.OrderIDRequest) (resp *order.OrderWithErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrderAndCreateFulfillments"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrderAndCreateFulfillmentsEndpoint{OrderIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmOrdersAndCreateFulfillmentsEndpoint struct {
	*shop.OrderIDsRequest
	Result     *cm.ErrorsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) ConfirmOrdersAndCreateFulfillments(ctx context.Context, req *shop.OrderIDsRequest) (resp *cm.ErrorsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/ConfirmOrdersAndCreateFulfillments"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmOrdersAndCreateFulfillmentsEndpoint{OrderIDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateOrderEndpoint struct {
	*order.CreateOrderRequest
	Result     *order.Order
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) CreateOrder(ctx context.Context, req *order.CreateOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/CreateOrder"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateOrderEndpoint{CreateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrderEndpoint struct {
	*cm.IDRequest
	Result     *order.Order
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) GetOrder(ctx context.Context, req *cm.IDRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrder"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersEndpoint struct {
	*shop.GetOrdersRequest
	Result     *order.OrdersResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) GetOrders(ctx context.Context, req *shop.GetOrdersRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrders"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersEndpoint{GetOrdersRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrdersByIDsEndpoint struct {
	*etop.IDsRequest
	Result     *order.OrdersResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) GetOrdersByIDs(ctx context.Context, req *etop.IDsRequest) (resp *order.OrdersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/GetOrdersByIDs"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrdersByIDsEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateOrderEndpoint struct {
	*order.UpdateOrderRequest
	Result     *order.Order
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) UpdateOrder(ctx context.Context, req *order.UpdateOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrder"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderEndpoint{UpdateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateOrderPaymentStatusEndpoint struct {
	*shop.UpdateOrderPaymentStatusRequest
	Result     *cm.UpdatedResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) UpdateOrderPaymentStatus(ctx context.Context, req *shop.UpdateOrderPaymentStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrderPaymentStatus"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrderPaymentStatusEndpoint{UpdateOrderPaymentStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateOrdersStatusEndpoint struct {
	*shop.UpdateOrdersStatusRequest
	Result     *cm.UpdatedResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s OrderService) UpdateOrdersStatus(ctx context.Context, req *shop.UpdateOrdersStatusRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Order/UpdateOrdersStatus"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateOrdersStatusEndpoint{UpdateOrdersStatusRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type FulfillmentService struct{}

type CancelFulfillmentEndpoint struct {
	*cm.IDRequest
	Result     *cm.UpdatedResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s FulfillmentService) CancelFulfillment(ctx context.Context, req *cm.IDRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/CancelFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateFulfillmentsForOrderEndpoint struct {
	*shop.CreateFulfillmentsForOrderRequest
	Result  *order.Order
	Context ShopClaim
}

func (s FulfillmentService) CreateFulfillmentsForOrder(ctx context.Context, req *shop.CreateFulfillmentsForOrderRequest) (resp *order.Order, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/CreateFulfillmentsForOrder"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateFulfillmentsForOrderEndpoint{CreateFulfillmentsForOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetExternalShippingServicesEndpoint struct {
	*order.GetExternalShippingServicesRequest
	Result     *order.GetExternalShippingServicesResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s FulfillmentService) GetExternalShippingServices(ctx context.Context, req *order.GetExternalShippingServicesRequest) (resp *order.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetFulfillmentEndpoint struct {
	*cm.IDRequest
	Result     *order.Fulfillment
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s FulfillmentService) GetFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetFulfillmentsEndpoint struct {
	*shop.GetFulfillmentsRequest
	Result     *order.FulfillmentsResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s FulfillmentService) GetFulfillments(ctx context.Context, req *shop.GetFulfillmentsRequest) (resp *order.FulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetFulfillments"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentsEndpoint{GetFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetPublicExternalShippingServicesEndpoint struct {
	*order.GetExternalShippingServicesRequest
	Result  *order.GetExternalShippingServicesResponse
	Context EmptyClaim
}

func (s FulfillmentService) GetPublicExternalShippingServices(ctx context.Context, req *order.GetExternalShippingServicesRequest) (resp *order.GetExternalShippingServicesResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicExternalShippingServices"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetPublicExternalShippingServicesEndpoint{GetExternalShippingServicesRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetPublicFulfillmentEndpoint struct {
	*shop.GetPublicFulfillmentRequest
	Result  *order.PublicFulfillment
	Context EmptyClaim
}

func (s FulfillmentService) GetPublicFulfillment(ctx context.Context, req *shop.GetPublicFulfillmentRequest) (resp *order.PublicFulfillment, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/GetPublicFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetPublicFulfillmentEndpoint{GetPublicFulfillmentRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateFulfillmentsShippingStateEndpoint struct {
	*shop.UpdateFulfillmentsShippingStateRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s FulfillmentService) UpdateFulfillmentsShippingState(ctx context.Context, req *shop.UpdateFulfillmentsShippingStateRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Fulfillment/UpdateFulfillmentsShippingState"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateFulfillmentsShippingStateEndpoint{UpdateFulfillmentsShippingStateRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "staff"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 2 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ShipnowService struct{}

type CancelShipnowFulfillmentEndpoint struct {
	*order.CancelShipnowFulfillmentRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s ShipnowService) CancelShipnowFulfillment(ctx context.Context, req *order.CancelShipnowFulfillmentRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CancelShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelShipnowFulfillmentEndpoint{CancelShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ConfirmShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.ShipnowFulfillment
	Context ShopClaim
}

func (s ShipnowService) ConfirmShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/ConfirmShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ConfirmShipnowFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateShipnowFulfillmentEndpoint struct {
	*order.CreateShipnowFulfillmentRequest
	Result  *order.ShipnowFulfillment
	Context ShopClaim
}

func (s ShipnowService) CreateShipnowFulfillment(ctx context.Context, req *order.CreateShipnowFulfillmentRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/CreateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateShipnowFulfillmentEndpoint{CreateShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShipnowFulfillmentEndpoint struct {
	*cm.IDRequest
	Result  *order.ShipnowFulfillment
	Context ShopClaim
}

func (s ShipnowService) GetShipnowFulfillment(ctx context.Context, req *cm.IDRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShipnowFulfillmentsEndpoint struct {
	*order.GetShipnowFulfillmentsRequest
	Result  *order.ShipnowFulfillments
	Context ShopClaim
}

func (s ShipnowService) GetShipnowFulfillments(ctx context.Context, req *order.GetShipnowFulfillmentsRequest) (resp *order.ShipnowFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowFulfillments"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowFulfillmentsEndpoint{GetShipnowFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShipnowServicesEndpoint struct {
	*order.GetShipnowServicesRequest
	Result  *order.GetShipnowServicesResponse
	Context ShopClaim
}

func (s ShipnowService) GetShipnowServices(ctx context.Context, req *order.GetShipnowServicesRequest) (resp *order.GetShipnowServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/GetShipnowServices"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShipnowServicesEndpoint{GetShipnowServicesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateShipnowFulfillmentEndpoint struct {
	*order.UpdateShipnowFulfillmentRequest
	Result  *order.ShipnowFulfillment
	Context ShopClaim
}

func (s ShipnowService) UpdateShipnowFulfillment(ctx context.Context, req *order.UpdateShipnowFulfillmentRequest) (resp *order.ShipnowFulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Shipnow/UpdateShipnowFulfillment"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateShipnowFulfillmentEndpoint{UpdateShipnowFulfillmentRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type HistoryService struct{}

type GetFulfillmentHistoryEndpoint struct {
	*shop.GetFulfillmentHistoryRequest
	Result     *etop.HistoryResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s HistoryService) GetFulfillmentHistory(ctx context.Context, req *shop.GetFulfillmentHistoryRequest) (resp *etop.HistoryResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.History/GetFulfillmentHistory"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentHistoryEndpoint{GetFulfillmentHistoryRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type MoneyTransactionService struct{}

type GetMoneyTransactionEndpoint struct {
	*cm.IDRequest
	Result  *order.MoneyTransaction
	Context ShopClaim
}

func (s MoneyTransactionService) GetMoneyTransaction(ctx context.Context, req *cm.IDRequest) (resp *order.MoneyTransaction, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransaction"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetMoneyTransactionsEndpoint struct {
	*shop.GetMoneyTransactionsRequest
	Result  *order.MoneyTransactionsResponse
	Context ShopClaim
}

func (s MoneyTransactionService) GetMoneyTransactions(ctx context.Context, req *shop.GetMoneyTransactionsRequest) (resp *order.MoneyTransactionsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.MoneyTransaction/GetMoneyTransactions"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetMoneyTransactionsEndpoint{GetMoneyTransactionsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SummaryService struct{}

type CalcBalanceShopEndpoint struct {
	*cm.Empty
	Result     *shop.CalcBalanceShopResponse
	Context    ShopClaim
	CtxPartner *model.Partner
}

func (s SummaryService) CalcBalanceShop(ctx context.Context, req *cm.Empty) (resp *shop.CalcBalanceShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/CalcBalanceShop"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CalcBalanceShopEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.CtxPartner = session.CtxPartner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SummarizeFulfillmentsEndpoint struct {
	*shop.SummarizeFulfillmentsRequest
	Result  *shop.SummarizeFulfillmentsResponse
	Context ShopClaim
}

func (s SummaryService) SummarizeFulfillments(ctx context.Context, req *shop.SummarizeFulfillmentsRequest) (resp *shop.SummarizeFulfillmentsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Summary/SummarizeFulfillments"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SummarizeFulfillmentsEndpoint{SummarizeFulfillmentsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	// Verify that the user has role "admin"
	if !session.IsOwner && permission.MaxRoleLevel(session.Roles) < 4 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ExportService struct{}

type GetExportsEndpoint struct {
	*shop.GetExportsRequest
	Result  *shop.GetExportsResponse
	Context ShopClaim
}

func (s ExportService) GetExports(ctx context.Context, req *shop.GetExportsRequest) (resp *shop.GetExportsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/GetExports"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetExportsEndpoint{GetExportsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RequestExportEndpoint struct {
	*shop.RequestExportRequest
	Result  *shop.RequestExportResponse
	Context ShopClaim
}

func (s ExportService) RequestExport(ctx context.Context, req *shop.RequestExportRequest) (resp *shop.RequestExportResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Export/RequestExport"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RequestExportEndpoint{RequestExportRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type NotificationService struct{}

type CreateDeviceEndpoint struct {
	*etop.CreateDeviceRequest
	Result  *etop.Device
	Context ShopClaim
}

func (s NotificationService) CreateDevice(ctx context.Context, req *etop.CreateDeviceRequest) (resp *etop.Device, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/CreateDevice"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateDeviceEndpoint{CreateDeviceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteDeviceEndpoint struct {
	*etop.DeleteDeviceRequest
	Result  *cm.DeletedResponse
	Context ShopClaim
}

func (s NotificationService) DeleteDevice(ctx context.Context, req *etop.DeleteDeviceRequest) (resp *cm.DeletedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/DeleteDevice"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteDeviceEndpoint{DeleteDeviceRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetNotificationEndpoint struct {
	*cm.IDRequest
	Result  *etop.Notification
	Context ShopClaim
}

func (s NotificationService) GetNotification(ctx context.Context, req *cm.IDRequest) (resp *etop.Notification, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotification"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetNotificationsEndpoint struct {
	*etop.GetNotificationsRequest
	Result  *etop.NotificationsResponse
	Context ShopClaim
}

func (s NotificationService) GetNotifications(ctx context.Context, req *etop.GetNotificationsRequest) (resp *etop.NotificationsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/GetNotifications"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetNotificationsEndpoint{GetNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateNotificationsEndpoint struct {
	*etop.UpdateNotificationsRequest
	Result  *cm.UpdatedResponse
	Context ShopClaim
}

func (s NotificationService) UpdateNotifications(ctx context.Context, req *etop.UpdateNotificationsRequest) (resp *cm.UpdatedResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Notification/UpdateNotifications"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateNotificationsEndpoint{UpdateNotificationsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type AuthorizeService struct{}

type AuthorizePartnerEndpoint struct {
	*shop.AuthorizePartnerRequest
	Result  *shop.AuthorizedPartnerResponse
	Context ShopClaim
}

func (s AuthorizeService) AuthorizePartner(ctx context.Context, req *shop.AuthorizePartnerRequest) (resp *shop.AuthorizedPartnerResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/AuthorizePartner"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AuthorizePartnerEndpoint{AuthorizePartnerRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetAuthorizedPartnersEndpoint struct {
	*cm.Empty
	Result  *shop.GetAuthorizedPartnersResponse
	Context ShopClaim
}

func (s AuthorizeService) GetAuthorizedPartners(ctx context.Context, req *cm.Empty) (resp *shop.GetAuthorizedPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAuthorizedPartners"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAuthorizedPartnersEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetAvailablePartnersEndpoint struct {
	*cm.Empty
	Result  *shop.GetPartnersResponse
	Context ShopClaim
}

func (s AuthorizeService) GetAvailablePartners(ctx context.Context, req *cm.Empty) (resp *shop.GetPartnersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "shop.Authorize/GetAvailablePartners"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireShop: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAvailablePartnersEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}
