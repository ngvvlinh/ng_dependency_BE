// package etop generated by wrapper_gen. DO NOT EDIT.
package etopW

import (
	"context"
	"net/http"
	"time"

	"github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	common "etop.vn/backend/pkg/common"
	"etop.vn/backend/pkg/common/metrics"
	cmWrapper "etop.vn/backend/pkg/common/wrapper"
	"etop.vn/backend/pkg/etop/authorize/claims"
	"etop.vn/backend/pkg/etop/authorize/middleware"
	"etop.vn/backend/pkg/etop/model"
	"etop.vn/common/bus"
	"etop.vn/common/l"
)

var ll = l.New()

var Client Etop

type Etop interface {
	etop.MiscService
	etop.UserService
	etop.AccountService
	etop.RelationshipService
	etop.LocationService
	etop.BankService
	etop.AddressService
}

type EtopClient struct {
	_MiscService         etop.MiscService
	_UserService         etop.UserService
	_AccountService      etop.AccountService
	_RelationshipService etop.RelationshipService
	_LocationService     etop.LocationService
	_BankService         etop.BankService
	_AddressService      etop.AddressService
}

func NewEtopClient(addr string, client *http.Client) Etop {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &EtopClient{
		_MiscService:         etop.NewMiscServiceProtobufClient(addr, client),
		_UserService:         etop.NewUserServiceProtobufClient(addr, client),
		_AccountService:      etop.NewAccountServiceProtobufClient(addr, client),
		_RelationshipService: etop.NewRelationshipServiceProtobufClient(addr, client),
		_LocationService:     etop.NewLocationServiceProtobufClient(addr, client),
		_BankService:         etop.NewBankServiceProtobufClient(addr, client),
		_AddressService:      etop.NewAddressServiceProtobufClient(addr, client),
	}
}

func ConnectEtopService(addr string, client *http.Client) error {
	Client = NewEtopClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ChangePasswordEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ChangePasswordUsingTokenEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *LoginEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RegisterEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ResetPasswordEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SendEmailVerificationEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SendPhoneVerificationEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SendSTokenEmailEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SessionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *SwitchAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdatePermissionEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpgradeAccessTokenEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *VerifyEmailUsingTokenEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *VerifyPhoneUsingTokenEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetPublicPartnerInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetPublicPartnersEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateURLSlugEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *AnswerInvitationEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetUsersInCurrentAccountsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *InviteUserToAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *LeaveAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveUserFromCurrentAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetDistrictsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetDistrictsByProvinceEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProvincesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetWardsEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetWardsByDistrictEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *ParseLocationEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetBanksEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetBranchesByBankProvinceEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetProvincesByBankEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateAddressEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetAddressesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *RemoveAddressEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *UpdateAddressEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to EtopService at %v", addr)
	}
	return err
}

func MustConnectEtopService(addr string, client *http.Client) {
	err := ConnectEtopService(addr, client)
	if err != nil {
		ll.Fatal("Unable to connect Etop", l.Error(err))
	}
}

type (
	EmptyClaim   = claims.EmptyClaim
	UserClaim    = claims.UserClaim
	AdminClaim   = claims.AdminClaim
	PartnerClaim = claims.PartnerClaim
	ShopClaim    = claims.ShopClaim
)

func (c *EtopClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) ChangePassword(ctx context.Context, in *etop.ChangePasswordRequest) (*cm.Empty, error) {
	resp, err := c._UserService.ChangePassword(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) ChangePasswordUsingToken(ctx context.Context, in *etop.ChangePasswordUsingTokenRequest) (*cm.Empty, error) {
	resp, err := c._UserService.ChangePasswordUsingToken(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) Login(ctx context.Context, in *etop.LoginRequest) (*etop.LoginResponse, error) {
	resp, err := c._UserService.Login(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) Register(ctx context.Context, in *etop.CreateUserRequest) (*etop.RegisterResponse, error) {
	resp, err := c._UserService.Register(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) ResetPassword(ctx context.Context, in *etop.ResetPasswordRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.ResetPassword(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) SendEmailVerification(ctx context.Context, in *etop.SendEmailVerificationRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.SendEmailVerification(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) SendPhoneVerification(ctx context.Context, in *etop.SendPhoneVerificationRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.SendPhoneVerification(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) SendSTokenEmail(ctx context.Context, in *etop.SendSTokenEmailRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.SendSTokenEmail(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) SessionInfo(ctx context.Context, in *cm.Empty) (*etop.LoginResponse, error) {
	resp, err := c._UserService.SessionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) SwitchAccount(ctx context.Context, in *etop.SwitchAccountRequest) (*etop.AccessTokenResponse, error) {
	resp, err := c._UserService.SwitchAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) UpdatePermission(ctx context.Context, in *etop.UpdatePermissionRequest) (*etop.UpdatePermissionResponse, error) {
	resp, err := c._UserService.UpdatePermission(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) UpgradeAccessToken(ctx context.Context, in *etop.UpgradeAccessTokenRequest) (*etop.AccessTokenResponse, error) {
	resp, err := c._UserService.UpgradeAccessToken(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) VerifyEmailUsingToken(ctx context.Context, in *etop.VerifyEmailUsingTokenRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.VerifyEmailUsingToken(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) VerifyPhoneUsingToken(ctx context.Context, in *etop.VerifyPhoneUsingTokenRequest) (*cm.MessageResponse, error) {
	resp, err := c._UserService.VerifyPhoneUsingToken(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetPublicPartnerInfo(ctx context.Context, in *cm.IDRequest) (*etop.PublicAccountInfo, error) {
	resp, err := c._AccountService.GetPublicPartnerInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetPublicPartners(ctx context.Context, in *cm.IDsRequest) (*etop.PublicAccountsResponse, error) {
	resp, err := c._AccountService.GetPublicPartners(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) UpdateURLSlug(ctx context.Context, in *etop.UpdateURLSlugRequest) (*cm.Empty, error) {
	resp, err := c._AccountService.UpdateURLSlug(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) AnswerInvitation(ctx context.Context, in *etop.AnswerInvitationRequest) (*etop.UserAccountInfo, error) {
	resp, err := c._RelationshipService.AnswerInvitation(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetUsersInCurrentAccounts(ctx context.Context, in *etop.GetUsersInCurrentAccountsRequest) (*etop.ProtectedUsersResponse, error) {
	resp, err := c._RelationshipService.GetUsersInCurrentAccounts(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) InviteUserToAccount(ctx context.Context, in *etop.InviteUserToAccountRequest) (*etop.UserAccountInfo, error) {
	resp, err := c._RelationshipService.InviteUserToAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) LeaveAccount(ctx context.Context, in *etop.LeaveAccountRequest) (*cm.Empty, error) {
	resp, err := c._RelationshipService.LeaveAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) RemoveUserFromCurrentAccount(ctx context.Context, in *etop.RemoveUserFromCurrentAccountRequest) (*cm.Empty, error) {
	resp, err := c._RelationshipService.RemoveUserFromCurrentAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetDistricts(ctx context.Context, in *cm.Empty) (*etop.GetDistrictsResponse, error) {
	resp, err := c._LocationService.GetDistricts(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetDistrictsByProvince(ctx context.Context, in *etop.GetDistrictsByProvinceRequest) (*etop.GetDistrictsResponse, error) {
	resp, err := c._LocationService.GetDistrictsByProvince(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetProvinces(ctx context.Context, in *cm.Empty) (*etop.GetProvincesResponse, error) {
	resp, err := c._LocationService.GetProvinces(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetWards(ctx context.Context, in *cm.Empty) (*etop.GetWardsResponse, error) {
	resp, err := c._LocationService.GetWards(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetWardsByDistrict(ctx context.Context, in *etop.GetWardsByDistrictRequest) (*etop.GetWardsResponse, error) {
	resp, err := c._LocationService.GetWardsByDistrict(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) ParseLocation(ctx context.Context, in *etop.ParseLocationRequest) (*etop.ParseLocationResponse, error) {
	resp, err := c._LocationService.ParseLocation(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetBanks(ctx context.Context, in *cm.Empty) (*etop.GetBanksResponse, error) {
	resp, err := c._BankService.GetBanks(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetBranchesByBankProvince(ctx context.Context, in *etop.GetBranchesByBankProvinceResquest) (*etop.GetBranchesByBankProvinceResponse, error) {
	resp, err := c._BankService.GetBranchesByBankProvince(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetProvincesByBank(ctx context.Context, in *etop.GetProvincesByBankResquest) (*etop.GetBankProvincesResponse, error) {
	resp, err := c._BankService.GetProvincesByBank(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) CreateAddress(ctx context.Context, in *etop.CreateAddressRequest) (*etop.Address, error) {
	resp, err := c._AddressService.CreateAddress(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) GetAddresses(ctx context.Context, in *cm.Empty) (*etop.GetAddressResponse, error) {
	resp, err := c._AddressService.GetAddresses(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) RemoveAddress(ctx context.Context, in *cm.IDRequest) (*cm.Empty, error) {
	resp, err := c._AddressService.RemoveAddress(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *EtopClient) UpdateAddress(ctx context.Context, in *etop.UpdateAddressRequest) (*etop.Address, error) {
	resp, err := c._AddressService.UpdateAddress(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewEtopServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&ChangePasswordEndpoint{})
	bus.Expect(&ChangePasswordUsingTokenEndpoint{})
	bus.Expect(&LoginEndpoint{})
	bus.Expect(&RegisterEndpoint{})
	bus.Expect(&ResetPasswordEndpoint{})
	bus.Expect(&SendEmailVerificationEndpoint{})
	bus.Expect(&SendPhoneVerificationEndpoint{})
	bus.Expect(&SendSTokenEmailEndpoint{})
	bus.Expect(&SessionInfoEndpoint{})
	bus.Expect(&SwitchAccountEndpoint{})
	bus.Expect(&UpdatePermissionEndpoint{})
	bus.Expect(&UpgradeAccessTokenEndpoint{})
	bus.Expect(&VerifyEmailUsingTokenEndpoint{})
	bus.Expect(&VerifyPhoneUsingTokenEndpoint{})
	bus.Expect(&GetPublicPartnerInfoEndpoint{})
	bus.Expect(&GetPublicPartnersEndpoint{})
	bus.Expect(&UpdateURLSlugEndpoint{})
	bus.Expect(&AnswerInvitationEndpoint{})
	bus.Expect(&GetUsersInCurrentAccountsEndpoint{})
	bus.Expect(&InviteUserToAccountEndpoint{})
	bus.Expect(&LeaveAccountEndpoint{})
	bus.Expect(&RemoveUserFromCurrentAccountEndpoint{})
	bus.Expect(&GetDistrictsEndpoint{})
	bus.Expect(&GetDistrictsByProvinceEndpoint{})
	bus.Expect(&GetProvincesEndpoint{})
	bus.Expect(&GetWardsEndpoint{})
	bus.Expect(&GetWardsByDistrictEndpoint{})
	bus.Expect(&ParseLocationEndpoint{})
	bus.Expect(&GetBanksEndpoint{})
	bus.Expect(&GetBranchesByBankProvinceEndpoint{})
	bus.Expect(&GetProvincesByBankEndpoint{})
	bus.Expect(&CreateAddressEndpoint{})
	bus.Expect(&GetAddressesEndpoint{})
	bus.Expect(&RemoveAddressEndpoint{})
	bus.Expect(&UpdateAddressEndpoint{})
	mux.Handle(etop.MiscServicePathPrefix, etop.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(etop.UserServicePathPrefix, etop.NewUserServiceServer(UserService{}, hooks))
	mux.Handle(etop.AccountServicePathPrefix, etop.NewAccountServiceServer(AccountService{}, hooks))
	mux.Handle(etop.RelationshipServicePathPrefix, etop.NewRelationshipServiceServer(RelationshipService{}, hooks))
	mux.Handle(etop.LocationServicePathPrefix, etop.NewLocationServiceServer(LocationService{}, hooks))
	mux.Handle(etop.BankServicePathPrefix, etop.NewBankServiceServer(BankService{}, hooks))
	mux.Handle(etop.AddressServicePathPrefix, etop.NewAddressServiceServer(AddressService{}, hooks))
}

type EtopImpl struct {
	MiscService
	UserService
	AccountService
	RelationshipService
	LocationService
	BankService
	AddressService
}

func NewEtop() Etop {
	return EtopImpl{}
}

type MiscService struct{}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UserService struct{}

type ChangePasswordEndpoint struct {
	*etop.ChangePasswordRequest
	Result  *cm.Empty
	Context UserClaim
}

func (s UserService) ChangePassword(ctx context.Context, req *etop.ChangePasswordRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePassword"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ChangePasswordEndpoint{ChangePasswordRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ChangePasswordUsingTokenEndpoint struct {
	*etop.ChangePasswordUsingTokenRequest
	Result  *cm.Empty
	Context EmptyClaim
}

func (s UserService) ChangePasswordUsingToken(ctx context.Context, req *etop.ChangePasswordUsingTokenRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ChangePasswordUsingToken"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &ChangePasswordUsingTokenEndpoint{ChangePasswordUsingTokenRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type LoginEndpoint struct {
	*etop.LoginRequest
	Result  *etop.LoginResponse
	Context EmptyClaim
}

func (s UserService) Login(ctx context.Context, req *etop.LoginRequest) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Login"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &LoginEndpoint{LoginRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RegisterEndpoint struct {
	*etop.CreateUserRequest
	Result  *etop.RegisterResponse
	Context EmptyClaim
}

func (s UserService) Register(ctx context.Context, req *etop.CreateUserRequest) (resp *etop.RegisterResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/Register"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &RegisterEndpoint{CreateUserRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ResetPasswordEndpoint struct {
	*etop.ResetPasswordRequest
	Result  *cm.MessageResponse
	Context EmptyClaim
}

func (s UserService) ResetPassword(ctx context.Context, req *etop.ResetPasswordRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.User/ResetPassword"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &ResetPasswordEndpoint{ResetPasswordRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SendEmailVerificationEndpoint struct {
	*etop.SendEmailVerificationRequest
	Result  *cm.MessageResponse
	Context UserClaim
}

func (s UserService) SendEmailVerification(ctx context.Context, req *etop.SendEmailVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendEmailVerification"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendEmailVerificationEndpoint{SendEmailVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SendPhoneVerificationEndpoint struct {
	*etop.SendPhoneVerificationRequest
	Result  *cm.MessageResponse
	Context UserClaim
}

func (s UserService) SendPhoneVerification(ctx context.Context, req *etop.SendPhoneVerificationRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendPhoneVerification"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendPhoneVerificationEndpoint{SendPhoneVerificationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SendSTokenEmailEndpoint struct {
	*etop.SendSTokenEmailRequest
	Result  *cm.MessageResponse
	Context UserClaim
}

func (s UserService) SendSTokenEmail(ctx context.Context, req *etop.SendSTokenEmailRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SendSTokenEmail"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SendSTokenEmailEndpoint{SendSTokenEmailRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SessionInfoEndpoint struct {
	*cm.Empty
	Result  *etop.LoginResponse
	Context UserClaim
}

func (s UserService) SessionInfo(ctx context.Context, req *cm.Empty) (resp *etop.LoginResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SessionInfo"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SessionInfoEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type SwitchAccountEndpoint struct {
	*etop.SwitchAccountRequest
	Result  *etop.AccessTokenResponse
	Context UserClaim
}

func (s UserService) SwitchAccount(ctx context.Context, req *etop.SwitchAccountRequest) (resp *etop.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/SwitchAccount"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &SwitchAccountEndpoint{SwitchAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdatePermissionEndpoint struct {
	*etop.UpdatePermissionRequest
	Result  *etop.UpdatePermissionResponse
	Context UserClaim
}

func (s UserService) UpdatePermission(ctx context.Context, req *etop.UpdatePermissionRequest) (resp *etop.UpdatePermissionResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpdatePermission"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdatePermissionEndpoint{UpdatePermissionRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpgradeAccessTokenEndpoint struct {
	*etop.UpgradeAccessTokenRequest
	Result  *etop.AccessTokenResponse
	Context UserClaim
}

func (s UserService) UpgradeAccessToken(ctx context.Context, req *etop.UpgradeAccessTokenRequest) (resp *etop.AccessTokenResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/UpgradeAccessToken"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpgradeAccessTokenEndpoint{UpgradeAccessTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type VerifyEmailUsingTokenEndpoint struct {
	*etop.VerifyEmailUsingTokenRequest
	Result  *cm.MessageResponse
	Context UserClaim
}

func (s UserService) VerifyEmailUsingToken(ctx context.Context, req *etop.VerifyEmailUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyEmailUsingToken"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyEmailUsingTokenEndpoint{VerifyEmailUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type VerifyPhoneUsingTokenEndpoint struct {
	*etop.VerifyPhoneUsingTokenRequest
	Result  *cm.MessageResponse
	Context UserClaim
}

func (s UserService) VerifyPhoneUsingToken(ctx context.Context, req *etop.VerifyPhoneUsingTokenRequest) (resp *cm.MessageResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.User/VerifyPhoneUsingToken"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &VerifyPhoneUsingTokenEndpoint{VerifyPhoneUsingTokenRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type AccountService struct{}

type GetPublicPartnerInfoEndpoint struct {
	*cm.IDRequest
	Result  *etop.PublicAccountInfo
	Context EmptyClaim
}

func (s AccountService) GetPublicPartnerInfo(ctx context.Context, req *cm.IDRequest) (resp *etop.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartnerInfo"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnerInfoEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetPublicPartnersEndpoint struct {
	*cm.IDsRequest
	Result  *etop.PublicAccountsResponse
	Context EmptyClaim
}

func (s AccountService) GetPublicPartners(ctx context.Context, req *cm.IDsRequest) (resp *etop.PublicAccountsResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/GetPublicPartners"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetPublicPartnersEndpoint{IDsRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateURLSlugEndpoint struct {
	*etop.UpdateURLSlugRequest
	Result  *cm.Empty
	Context UserClaim
}

func (s AccountService) UpdateURLSlug(ctx context.Context, req *etop.UpdateURLSlugRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Account/UpdateURLSlug"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateURLSlugEndpoint{UpdateURLSlugRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RelationshipService struct{}

type AnswerInvitationEndpoint struct {
	*etop.AnswerInvitationRequest
	Result  *etop.UserAccountInfo
	Context UserClaim
}

func (s RelationshipService) AnswerInvitation(ctx context.Context, req *etop.AnswerInvitationRequest) (resp *etop.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/AnswerInvitation"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AnswerInvitationEndpoint{AnswerInvitationRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetUsersInCurrentAccountsEndpoint struct {
	*etop.GetUsersInCurrentAccountsRequest
	Result  *etop.ProtectedUsersResponse
	Context UserClaim
}

func (s RelationshipService) GetUsersInCurrentAccounts(ctx context.Context, req *etop.GetUsersInCurrentAccountsRequest) (resp *etop.ProtectedUsersResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/GetUsersInCurrentAccounts"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetUsersInCurrentAccountsEndpoint{GetUsersInCurrentAccountsRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type InviteUserToAccountEndpoint struct {
	*etop.InviteUserToAccountRequest
	Result  *etop.UserAccountInfo
	Context UserClaim
}

func (s RelationshipService) InviteUserToAccount(ctx context.Context, req *etop.InviteUserToAccountRequest) (resp *etop.UserAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/InviteUserToAccount"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &InviteUserToAccountEndpoint{InviteUserToAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type LeaveAccountEndpoint struct {
	*etop.LeaveAccountRequest
	Result  *cm.Empty
	Context UserClaim
}

func (s RelationshipService) LeaveAccount(ctx context.Context, req *etop.LeaveAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/LeaveAccount"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &LeaveAccountEndpoint{LeaveAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveUserFromCurrentAccountEndpoint struct {
	*etop.RemoveUserFromCurrentAccountRequest
	Result  *cm.Empty
	Context UserClaim
}

func (s RelationshipService) RemoveUserFromCurrentAccount(ctx context.Context, req *etop.RemoveUserFromCurrentAccountRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Relationship/RemoveUserFromCurrentAccount"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveUserFromCurrentAccountEndpoint{RemoveUserFromCurrentAccountRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type LocationService struct{}

type GetDistrictsEndpoint struct {
	*cm.Empty
	Result  *etop.GetDistrictsResponse
	Context EmptyClaim
}

func (s LocationService) GetDistricts(ctx context.Context, req *cm.Empty) (resp *etop.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistricts"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetDistrictsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetDistrictsByProvinceEndpoint struct {
	*etop.GetDistrictsByProvinceRequest
	Result  *etop.GetDistrictsResponse
	Context EmptyClaim
}

func (s LocationService) GetDistrictsByProvince(ctx context.Context, req *etop.GetDistrictsByProvinceRequest) (resp *etop.GetDistrictsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetDistrictsByProvince"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetDistrictsByProvinceEndpoint{GetDistrictsByProvinceRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProvincesEndpoint struct {
	*cm.Empty
	Result  *etop.GetProvincesResponse
	Context EmptyClaim
}

func (s LocationService) GetProvinces(ctx context.Context, req *cm.Empty) (resp *etop.GetProvincesResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetProvinces"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetProvincesEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetWardsEndpoint struct {
	*cm.Empty
	Result  *etop.GetWardsResponse
	Context EmptyClaim
}

func (s LocationService) GetWards(ctx context.Context, req *cm.Empty) (resp *etop.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWards"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetWardsEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetWardsByDistrictEndpoint struct {
	*etop.GetWardsByDistrictRequest
	Result  *etop.GetWardsResponse
	Context EmptyClaim
}

func (s LocationService) GetWardsByDistrict(ctx context.Context, req *etop.GetWardsByDistrictRequest) (resp *etop.GetWardsResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "etop.Location/GetWardsByDistrict"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	query := &GetWardsByDistrictEndpoint{GetWardsByDistrictRequest: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type ParseLocationEndpoint struct {
	*etop.ParseLocationRequest
	Result  *etop.ParseLocationResponse
	Context EmptyClaim
}

func (s LocationService) ParseLocation(ctx context.Context, req *etop.ParseLocationRequest) (resp *etop.ParseLocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Location/ParseLocation"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &ParseLocationEndpoint{ParseLocationRequest: req}
	query.Context.Claim = session.Claim
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type BankService struct{}

type GetBanksEndpoint struct {
	*cm.Empty
	Result  *etop.GetBanksResponse
	Context UserClaim
}

func (s BankService) GetBanks(ctx context.Context, req *cm.Empty) (resp *etop.GetBanksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBanks"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBanksEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetBranchesByBankProvinceEndpoint struct {
	*etop.GetBranchesByBankProvinceResquest
	Result  *etop.GetBranchesByBankProvinceResponse
	Context UserClaim
}

func (s BankService) GetBranchesByBankProvince(ctx context.Context, req *etop.GetBranchesByBankProvinceResquest) (resp *etop.GetBranchesByBankProvinceResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetBranchesByBankProvince"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetBranchesByBankProvinceEndpoint{GetBranchesByBankProvinceResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetProvincesByBankEndpoint struct {
	*etop.GetProvincesByBankResquest
	Result  *etop.GetBankProvincesResponse
	Context UserClaim
}

func (s BankService) GetProvincesByBank(ctx context.Context, req *etop.GetProvincesByBankResquest) (resp *etop.GetBankProvincesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Bank/GetProvincesByBank"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetProvincesByBankEndpoint{GetProvincesByBankResquest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type AddressService struct{}

type CreateAddressEndpoint struct {
	*etop.CreateAddressRequest
	Result  *etop.Address
	Context UserClaim
}

func (s AddressService) CreateAddress(ctx context.Context, req *etop.CreateAddressRequest) (resp *etop.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/CreateAddress"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAddressEndpoint{CreateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type GetAddressesEndpoint struct {
	*cm.Empty
	Result     *etop.GetAddressResponse
	Context    UserClaim
	CtxPartner *model.Partner
}

func (s AddressService) GetAddresses(ctx context.Context, req *cm.Empty) (resp *etop.GetAddressResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/GetAddresses"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
		AuthPartner: 1,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetAddressesEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	query.CtxPartner = session.CtxPartner
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type RemoveAddressEndpoint struct {
	*cm.IDRequest
	Result  *cm.Empty
	Context UserClaim
}

func (s AddressService) RemoveAddress(ctx context.Context, req *cm.IDRequest) (resp *cm.Empty, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/RemoveAddress"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &RemoveAddressEndpoint{IDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}

type UpdateAddressEndpoint struct {
	*etop.UpdateAddressRequest
	Result  *etop.Address
	Context UserClaim
}

func (s AddressService) UpdateAddress(ctx context.Context, req *etop.UpdateAddressRequest) (resp *etop.Address, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "etop.Address/UpdateAddress"
	defer func() {
		recovered := recover()
		err = cmWrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmWrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:     ctx,
		RequireAuth: true,
		RequireUser: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &UpdateAddressEndpoint{UpdateAddressRequest: req}
	query.Context.Claim = session.Claim
	query.Context.User = session.User
	query.Context.Admin = session.Admin
	// Verify that the user has correct service type
	if session.Claim.AuthPartnerID != 0 {
		return nil, common.ErrPermissionDenied
	}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmWrapper.HasErrors(resp)
	}
	return resp, err
}
