// package partner generated by wrapper_gen. DO NOT EDIT.
package partnerW

import (
	"context"
	"net/http"
	"time"

	twirp "github.com/twitchtv/twirp"

	cm "etop.vn/backend/pb/common"
	etop "etop.vn/backend/pb/etop"
	external "etop.vn/backend/pb/external"
	partner "etop.vn/backend/pb/external/partner"
	common "etop.vn/backend/pkg/common"
	metrics "etop.vn/backend/pkg/common/metrics"
	cmwrapper "etop.vn/backend/pkg/common/wrapper"
	claims "etop.vn/backend/pkg/etop/authorize/claims"
	middleware "etop.vn/backend/pkg/etop/authorize/middleware"
	bus "etop.vn/common/bus"
	l "etop.vn/common/l"
)

var ll = l.New()

var Client Partner

type Partner interface {
	partner.MiscService
	partner.ShopService
	partner.WebhookService
	partner.HistoryService
	partner.ShippingService
}

type PartnerClient struct {
	_MiscService     partner.MiscService
	_ShopService     partner.ShopService
	_WebhookService  partner.WebhookService
	_HistoryService  partner.HistoryService
	_ShippingService partner.ShippingService
}

func NewPartnerClient(addr string, client *http.Client) Partner {
	if client == nil {
		client = &http.Client{
			Timeout: 10 * time.Second,
		}
	}

	addr = "http://" + addr
	return &PartnerClient{
		_MiscService:     partner.NewMiscServiceProtobufClient(addr, client),
		_ShopService:     partner.NewShopServiceProtobufClient(addr, client),
		_WebhookService:  partner.NewWebhookServiceProtobufClient(addr, client),
		_HistoryService:  partner.NewHistoryServiceProtobufClient(addr, client),
		_ShippingService: partner.NewShippingServiceProtobufClient(addr, client),
	}
}

func ConnectPartnerService(addr string, client *http.Client) error {
	Client = NewPartnerClient(addr, client)
	bus.AddHandler("client", func(ctx context.Context, q *CurrentAccountEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetLocationListEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *VersionInfoEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *AuthorizeShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CurrentShopEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateWebhookEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *DeleteWebhookEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetWebhooksEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetChangesEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CancelOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *CreateAndConfirmOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetFulfillmentEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetOrderEndpoint) error { panic("Unexpected") })
	bus.AddHandler("client", func(ctx context.Context, q *GetShippingServicesEndpoint) error { panic("Unexpected") })
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	_, err := Client.VersionInfo(ctx, &cm.Empty{})
	if err == nil {
		ll.S.Infof("Connected to PartnerService at %v", addr)
	}
	return err
}

func MustConnectPartnerService(addr string, client *http.Client) {
	err := ConnectPartnerService(addr, client)
	if err != nil {
		ll.Fatal("Unable to connect Partner", l.Error(err))
	}
}

type (
	EmptyClaim   = claims.EmptyClaim
	UserClaim    = claims.UserClaim
	AdminClaim   = claims.AdminClaim
	PartnerClaim = claims.PartnerClaim
	ShopClaim    = claims.ShopClaim
)

func (c *PartnerClient) CurrentAccount(ctx context.Context, in *cm.Empty) (*external.Partner, error) {
	resp, err := c._MiscService.CurrentAccount(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetLocationList(ctx context.Context, in *cm.Empty) (*external.LocationResponse, error) {
	resp, err := c._MiscService.GetLocationList(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) VersionInfo(ctx context.Context, in *cm.Empty) (*cm.VersionInfoResponse, error) {
	resp, err := c._MiscService.VersionInfo(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) AuthorizeShop(ctx context.Context, in *partner.AuthorizeShopRequest) (*partner.AuthorizeShopResponse, error) {
	resp, err := c._ShopService.AuthorizeShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) CurrentShop(ctx context.Context, in *cm.Empty) (*etop.PublicAccountInfo, error) {
	resp, err := c._ShopService.CurrentShop(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) CreateWebhook(ctx context.Context, in *external.CreateWebhookRequest) (*external.Webhook, error) {
	resp, err := c._WebhookService.CreateWebhook(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) DeleteWebhook(ctx context.Context, in *external.DeleteWebhookRequest) (*external.WebhooksResponse, error) {
	resp, err := c._WebhookService.DeleteWebhook(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetWebhooks(ctx context.Context, in *cm.Empty) (*external.WebhooksResponse, error) {
	resp, err := c._WebhookService.GetWebhooks(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetChanges(ctx context.Context, in *external.GetChangesRequest) (*external.Callback, error) {
	resp, err := c._HistoryService.GetChanges(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) CancelOrder(ctx context.Context, in *external.CancelOrderRequest) (*external.OrderAndFulfillments, error) {
	resp, err := c._ShippingService.CancelOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) CreateAndConfirmOrder(ctx context.Context, in *external.CreateOrderRequest) (*external.OrderAndFulfillments, error) {
	resp, err := c._ShippingService.CreateAndConfirmOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetFulfillment(ctx context.Context, in *external.FulfillmentIDRequest) (*external.Fulfillment, error) {
	resp, err := c._ShippingService.GetFulfillment(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetOrder(ctx context.Context, in *external.OrderIDRequest) (*external.OrderAndFulfillments, error) {
	resp, err := c._ShippingService.GetOrder(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}
func (c *PartnerClient) GetShippingServices(ctx context.Context, in *external.GetShippingServicesRequest) (*external.GetShippingServicesResponse, error) {
	resp, err := c._ShippingService.GetShippingServices(ctx, in)

	node, ok := ctx.(*bus.NodeContext)
	if !ok {
		return resp, err
	}
	newNode := node.WithMessage(map[string]interface{}{
		"Request": in,
		"Result":  resp,
	})
	newNode.Error = err
	return resp, err
}

type Muxer interface {
	Handle(string, http.Handler)
}

func NewPartnerServer(mux Muxer, hooks *twirp.ServerHooks) {
	bus.Expect(&CurrentAccountEndpoint{})
	bus.Expect(&GetLocationListEndpoint{})
	bus.Expect(&VersionInfoEndpoint{})
	bus.Expect(&AuthorizeShopEndpoint{})
	bus.Expect(&CurrentShopEndpoint{})
	bus.Expect(&CreateWebhookEndpoint{})
	bus.Expect(&DeleteWebhookEndpoint{})
	bus.Expect(&GetWebhooksEndpoint{})
	bus.Expect(&GetChangesEndpoint{})
	bus.Expect(&CancelOrderEndpoint{})
	bus.Expect(&CreateAndConfirmOrderEndpoint{})
	bus.Expect(&GetFulfillmentEndpoint{})
	bus.Expect(&GetOrderEndpoint{})
	bus.Expect(&GetShippingServicesEndpoint{})
	mux.Handle(partner.MiscServicePathPrefix, partner.NewMiscServiceServer(MiscService{}, hooks))
	mux.Handle(partner.ShopServicePathPrefix, partner.NewShopServiceServer(ShopService{}, hooks))
	mux.Handle(partner.WebhookServicePathPrefix, partner.NewWebhookServiceServer(WebhookService{}, hooks))
	mux.Handle(partner.HistoryServicePathPrefix, partner.NewHistoryServiceServer(HistoryService{}, hooks))
	mux.Handle(partner.ShippingServicePathPrefix, partner.NewShippingServiceServer(ShippingService{}, hooks))
}

type PartnerImpl struct {
	MiscService
	ShopService
	WebhookService
	HistoryService
	ShippingService
}

func NewPartner() Partner {
	return PartnerImpl{}
}

type MiscService struct{}

type CurrentAccountEndpoint struct {
	*cm.Empty
	Result  *external.Partner
	Context PartnerClaim
}

func (s MiscService) CurrentAccount(ctx context.Context, req *cm.Empty) (resp *external.Partner, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Misc/CurrentAccount"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CurrentAccountEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetLocationListEndpoint struct {
	*cm.Empty
	Result  *external.LocationResponse
	Context PartnerClaim
}

func (s MiscService) GetLocationList(ctx context.Context, req *cm.Empty) (resp *external.LocationResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Misc/GetLocationList"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetLocationListEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type VersionInfoEndpoint struct {
	*cm.Empty
	Result  *cm.VersionInfoResponse
	Context EmptyClaim
}

func (s MiscService) VersionInfo(ctx context.Context, req *cm.Empty) (resp *cm.VersionInfoResponse, err error) {
	t0 := time.Now()
	var errs []*cm.Error
	const rpcName = "partner.Misc/VersionInfo"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, nil, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	query := &VersionInfoEndpoint{Empty: req}
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ShopService struct{}

type AuthorizeShopEndpoint struct {
	*partner.AuthorizeShopRequest
	Result  *partner.AuthorizeShopResponse
	Context PartnerClaim
}

func (s ShopService) AuthorizeShop(ctx context.Context, req *partner.AuthorizeShopRequest) (resp *partner.AuthorizeShopResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shop/AuthorizeShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &AuthorizeShopEndpoint{AuthorizeShopRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CurrentShopEndpoint struct {
	*cm.Empty
	Result  *etop.PublicAccountInfo
	Context ShopClaim
}

func (s ShopService) CurrentShop(ctx context.Context, req *cm.Empty) (resp *etop.PublicAccountInfo, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shop/CurrentShop"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CurrentShopEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type WebhookService struct{}

type CreateWebhookEndpoint struct {
	*external.CreateWebhookRequest
	Result  *external.Webhook
	Context PartnerClaim
}

func (s WebhookService) CreateWebhook(ctx context.Context, req *external.CreateWebhookRequest) (resp *external.Webhook, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/CreateWebhook"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateWebhookEndpoint{CreateWebhookRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type DeleteWebhookEndpoint struct {
	*external.DeleteWebhookRequest
	Result  *external.WebhooksResponse
	Context PartnerClaim
}

func (s WebhookService) DeleteWebhook(ctx context.Context, req *external.DeleteWebhookRequest) (resp *external.WebhooksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/DeleteWebhook"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &DeleteWebhookEndpoint{DeleteWebhookRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetWebhooksEndpoint struct {
	*cm.Empty
	Result  *external.WebhooksResponse
	Context PartnerClaim
}

func (s WebhookService) GetWebhooks(ctx context.Context, req *cm.Empty) (resp *external.WebhooksResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Webhook/GetWebhooks"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetWebhooksEndpoint{Empty: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type HistoryService struct{}

type GetChangesEndpoint struct {
	*external.GetChangesRequest
	Result  *external.Callback
	Context PartnerClaim
}

func (s HistoryService) GetChanges(ctx context.Context, req *external.GetChangesRequest) (resp *external.Callback, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.History/GetChanges"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:        ctx,
		RequireAuth:    true,
		RequireAPIKey:  true,
		RequirePartner: true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetChangesEndpoint{GetChangesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Partner = session.Partner
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type ShippingService struct{}

type CancelOrderEndpoint struct {
	*external.CancelOrderRequest
	Result  *external.OrderAndFulfillments
	Context ShopClaim
}

func (s ShippingService) CancelOrder(ctx context.Context, req *external.CancelOrderRequest) (resp *external.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/CancelOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CancelOrderEndpoint{CancelOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type CreateAndConfirmOrderEndpoint struct {
	*external.CreateOrderRequest
	Result  *external.OrderAndFulfillments
	Context ShopClaim
}

func (s ShippingService) CreateAndConfirmOrder(ctx context.Context, req *external.CreateOrderRequest) (resp *external.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/CreateAndConfirmOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &CreateAndConfirmOrderEndpoint{CreateOrderRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetFulfillmentEndpoint struct {
	*external.FulfillmentIDRequest
	Result  *external.Fulfillment
	Context ShopClaim
}

func (s ShippingService) GetFulfillment(ctx context.Context, req *external.FulfillmentIDRequest) (resp *external.Fulfillment, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetFulfillment"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetFulfillmentEndpoint{FulfillmentIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetOrderEndpoint struct {
	*external.OrderIDRequest
	Result  *external.OrderAndFulfillments
	Context ShopClaim
}

func (s ShippingService) GetOrder(ctx context.Context, req *external.OrderIDRequest) (resp *external.OrderAndFulfillments, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetOrder"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetOrderEndpoint{OrderIDRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}

type GetShippingServicesEndpoint struct {
	*external.GetShippingServicesRequest
	Result  *external.GetShippingServicesResponse
	Context ShopClaim
}

func (s ShippingService) GetShippingServices(ctx context.Context, req *external.GetShippingServicesRequest) (resp *external.GetShippingServicesResponse, err error) {
	t0 := time.Now()
	var session *middleware.Session
	var errs []*cm.Error
	const rpcName = "partner.Shipping/GetShippingServices"
	defer func() {
		recovered := recover()
		err = cmwrapper.RecoverAndLog(ctx, rpcName, session, req, resp, recovered, err, errs, t0)
		metrics.CountRequest(rpcName, err)
	}()
	defer cmwrapper.Censor(req)
	sessionQuery := &middleware.StartSessionQuery{
		Context:                  ctx,
		RequireAuth:              true,
		RequireAPIPartnerShopKey: true,
		RequireShop:              true,
	}
	if err := bus.Dispatch(ctx, sessionQuery); err != nil {
		return nil, err
	}
	session = sessionQuery.Result
	query := &GetShippingServicesEndpoint{GetShippingServicesRequest: req}
	query.Context.Claim = session.Claim
	query.Context.Shop = session.Shop
	query.Context.IsOwner = session.IsOwner
	query.Context.Roles = session.Roles
	query.Context.Permissions = session.Permissions
	ctx = bus.NewRootContext(ctx)
	err = bus.Dispatch(ctx, query)
	resp = query.Result
	if err == nil {
		if resp == nil {
			return nil, common.Error(common.Internal, "", nil).Log("nil response")
		}
		errs = cmwrapper.HasErrors(resp)
	}
	return resp, err
}
